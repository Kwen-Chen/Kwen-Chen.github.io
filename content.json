{"meta":{"title":"热爱折腾，享受生活","subtitle":"这里是CK的小世界","description":"描绘昨天，畅想明天","author":"KernChen","url":"http://ckblogs.cn","root":"/"},"pages":[{"title":"","date":"2021-06-05T04:42:55.960Z","updated":"2021-06-05T04:42:55.960Z","comments":true,"path":"google0b3aa3aa9ec334d1.html","permalink":"http://ckblogs.cn/google0b3aa3aa9ec334d1.html","excerpt":"","text":"google-site-verification: google0b3aa3aa9ec334d1.html"},{"title":"标签","date":"2021-04-13T08:36:52.000Z","updated":"2021-04-13T08:37:50.154Z","comments":true,"path":"tags/index.html","permalink":"http://ckblogs.cn/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-18T16:00:00.000Z","updated":"2021-08-19T11:28:23.296Z","comments":true,"path":"about/index.html","permalink":"http://ckblogs.cn/about/index.html","excerpt":"","text":"我是谁？ 一名酷爱计算机技术的电子科技大学2020级本科生。此博客于2021年四月开始建立，于五月基本建设完毕，目前仍处于不断地更新完善之中。 我喜欢去整一些我认为很酷炫的东西，有时候当我决定去做一件事的时候，仅仅是因为一个小小的契机。2021年四月的一个晚上，我无意闯入一位学长的个人博客，这个让我惊艳到的网站让我内心澎湃。然后就决定也搭建一个自己的网站，说干就干，从那一周开始，每个晚自习，就是我坐在电脑前不断出错改错，尝试，的过程。结果当然是令我满意的。 同样是因为一个小小的契机，我看到学校有人能写一些小脚本达到抢课或者抢票的目的，在我看来，那实在是很酷炫。于是，说干就干，我去研究Python 爬虫，研究Python自动化测试，OK，果然，目的达到（具体做了什么嘛，天机不可泄露！）。 虽然这些东西对我的学业成绩而言并没有任何帮助，但是看到自己亲手描绘的博客网站从无到有，看到自己的爬虫技术竟然能赚到钱，还是很欣慰的。 放几张学校美照！ 如何联系到我? 首页有我的QQ、微信、GitHub、以及哔哩哔哩等我常用的社交平台账号，可以通过添加这些账号的方式联系到我，与我一起沟通交流或者分享。当然也可以通过评论留言的方式留下你的看法。我将通过电子邮件的方式给你回信，（另外说一句，回信有惊喜哦！） QQ微信Bilibili QQ 企鹅账号 平时工作学习用到的最多的社交软件 微信账号 平时除聊天外很少用 朋友圈几乎不更新。。。 如果可以的话，支持支持我这个“立志成为百大”的小up主吧。不定时更新哈哈哈。"},{"title":"分类","date":"2021-04-13T08:38:06.000Z","updated":"2021-04-13T08:38:39.194Z","comments":true,"path":"categories/index.html","permalink":"http://ckblogs.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-13T08:38:58.000Z","updated":"2021-04-13T08:39:28.323Z","comments":true,"path":"link/index.html","permalink":"http://ckblogs.cn/link/index.html","excerpt":"","text":""}],"posts":[{"title":"2022 至微公益团队第十三届支教总结","slug":"至微公益团队第十三届支教总结","date":"2022-07-20T14:11:42.000Z","updated":"2022-07-20T14:41:10.562Z","comments":true,"path":"2022/07/20/至微公益团队第十三届支教总结/","link":"","permalink":"http://ckblogs.cn/2022/07/20/%E8%87%B3%E5%BE%AE%E5%85%AC%E7%9B%8A%E5%9B%A2%E9%98%9F%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E6%94%AF%E6%95%99%E6%80%BB%E7%BB%93/","excerpt":"","text":"至微公益团队第十三届支教总结 ​ 陈坤 支教结束第五天了，陆陆续续接到孩子们的电话，翻开着自己随手拍下的相片，每张照片都是一个值得回忆的故事，每个故事都是这半个月支教充满意义的生活中的一小部分。五天后的今天，开始动笔写下这篇总结，希望这些美好回忆能在我心中真正沉淀下来。 启程 作为第二次参加支教的我来说，今年的身份与去年不同，我首先是一个队长。抛开对支教生活的期待，更多的是心中的担忧。是否所有物资都准备充分了？是否出发行程都安排妥当了？是否已经把支教的学校安置清楚了？一切的未知都化作了担忧，因为这一切的一切，关系到每一位队员这十几天的生活，关系到每一位参加的孩子们。我丝毫不敢怠慢，也绝对不能怠慢。 伴随着六月三十日的阳光，我们启程了。 提着大包小包，拿着符合气质的上一届留下来的暖水壶，一行人就这样出发了。 虽然，支教地简阳市平泉镇荷桥村对我已经不再陌生，但每次回到这个风景如画的小村庄，总要不禁感叹这的美丽，这里生活的惬意与美好，这可能就是我心中的巴蜀风光吧。还是熟悉的小学，但是心情五味杂陈，未来的十五天，我们能否上好每一节课，能否做到至细至微呢？故事从这里开启。 合照啦！以及我们即将上课的教室。 课堂内外 课堂 首先作为一名老师，今年我承担两门课程的教授《当数学走进艺术》、《大国崛起》，与去年不同的是，这两门课都是对我不小的考验。但我一直认为，备课与上课的过程是幸福且伟大的，课程准备的过程，也是提升自我的过程。高中的数学老师告诉我，数学是美丽的，我也一直这么认为，这个世界最美丽的东西可能莫过于数学了，我想让孩子们知道数学不止是枯燥无味的数字和公式，想让孩子们爱上数学，也能感受到数学的美丽与神奇。对于一个没有什么艺术天赋的我，想要上好一节数学艺术课是不容易的，对此，我要不断地查询资料，不断地尝试与改进。带领孩子们看雪花曲线，画分形树，感受分形数学的魅力；带领孩子们做莫比乌斯环，研究内克尔立方体等不可能图形的奥秘，探索神奇的数学世界；和孩子们做一笔画，做数学魔术，感受神奇数学背后的原理。 一起绘制分形树，和孩子们一起来做莫比乌斯环 十五天带给孩子们的，除了真正的课内知识外，更重要的应当是思想上的引领。作为一名要上三个年级思政课《大国崛起》的老师，我深知这节课的意义。虽然这节课只上一课时，却整整花了我很多个晚上去查找相关的资料，去寻找一些视频资源。能够让孩子们认识到革命先辈遭受的苦难，能够让孩子们认识到自己胸前飘扬的红领巾的意义，能够培养孩子们哪怕一点点民族自信心与责任感，就是我这节课最高的目标。作为一名中共预备党员，我特地在上课之前戴上了的党徽，戴上党徽，站在讲台前看到一朵朵祖国的花朵的那一刻，我知道自己所做的正是一个伟大的事业。当我讲到南京大屠杀日本牲畜的恶行时，我能感受到孩子们的气愤；当我讲到抗日战争时期的川军十几岁就出川上战场杀敌时，我能感受到孩子们的敬佩；当我讲到新中国的成立，中国原子弹的研制与航天的发展时，我能感受到孩子们骄傲的神情。作为准备时间最长的一门课，我希望能为这些孩子们的心中埋下一颗种子，能真正发芽，结果！ 我的第一枚党徽与思政课上给孩子们看的一个老兵回忆小视频 家访 支教中家访的环节是必不可少的，在家访的过程中，即是我们和孩子家长相互了解的过程，更是让我们和孩子家长对孩子在课堂和家庭表现的重要获取通道。令人痛心的是，经过家访的我们，更能发现当地孩子的不容易，大部分孩子都是留守儿童，父母离异、父母外出打工、或者父母去世，成为这些孩子中的大部分家庭。缺少父母的陪伴可能是大部分问题儿童产生问题的一个重要因素。不过，令人高兴的一方面是，大部分留守儿童家庭的爷爷奶奶对孩子的教育都是十分支持的，无论家庭条件如何艰难，都表示会让孩子上学上到底。在这样家庭环境下成长的孩子们，真的很让人心疼，我为他们的坚强点赞，也坚信他们会将这些不利条件化为前进的动力，只要方向明确，一定未来充满希望！ 在我去家访的过程中，孩子家里的老人对我们十分的热情，真的很感谢他们对我们的支持，以及对我们的帮助，他们的信任更是对我们的要求，只有上好每一节课，才是对他们信任最好的回报。 家访 点滴生活 来到这里之前，我已做好了十足的准备，无论是物理意义上的还是心理意义上的。来到这里的点滴生活，更让我在平时劳累的生活中充满了乐趣： 住宿 第一次住大通铺，第一次在这么一间小房子里打地铺的感觉别提有多美妙了，十几个人挤在这样的小房间里，即使房顶可能会漏雨，即使我的脸上经常掉落一些神奇没见过的虫子，即使要点满蚊香还会经受蚊虫叮咬，这个小房间每天也会因为睡觉发生无数有趣的事。无论是某人睡梦中梦话大喊，还是某人一觉醒来总是睡在床缝中，无论是某人睡梦中向另外一人要裤子，还是某人早起的誓言迟迟没有实现。条件的艰苦不代表着不能苦中作乐，大通铺也能看到生活的精彩。 就这样，一个可以住下十四人的大通铺被建成了 餐食 得益于荷桥各位大厨们精湛的厨艺，我从来没有感觉到我们自己做的饭菜能这么好吃，尽管为了省钱，食材匮乏到每天都是茄子、土豆，尽管做饭的空间那么狭窄，尽管一顿饭下来热的要出几轮的汗。每一位大厨都为了饭菜更可口，为了饭菜更多样化，精益求精。买菜、做饭、洗碗，这样日常的事，每一位队员每天都在参与其中，我看到的是没有人把这些事情当作任务去完成，更多的是当作一次展现自我，为大家奉献服务的机会。有人专门写好了每天的食谱，有人换着花样做些新奇的菜，有人特地打电话给家里人远程指导。虽然比起大鱼大肉，这样的饭菜简约朴素的多，但做饭的整个过程也让艰苦的支教生活充满了乐趣。 朝瑾老师在做煎豆腐以及我远程向我妈取经做的两道素菜！ 饭后小憩 荷桥的风景总是让人感叹，吃完饭后，几个小孩子非常乐意带我们老师去荷桥的各个地方游玩，无论是水库边的壮阔，还是荷花池荷花的优美，无论是狡黠的月光，还是别具风味的小屋，都让人留恋忘返。孩子们会给我们采荷花送给我们，也会逮“癞疙宝”来“吓唬”胆小的女老师。 孩子们自发组织的篝火晚会也让人感动，我能感受到孩子们从策划、执行、构想到实现，想要给我们每个人一个惊喜，想让我们在这里玩得开心，想让我们真正爱上荷桥。 一天的疲惫总是能被这样的一些小确幸冲散，我们和孩子们也在相互给予，相互学习，可能这就是支教另一方面的意义吧。 荷桥美丽的荷花池与荷桥水库 球场上的少年与下课后的宿舍 尾声 终究是要分离，终究是要离开这群孩子们。我不知道我们这十五天能带给孩子们什么，但我知道的是，当我问一个孩子的梦想时，他坚定的告诉我，他要上电子科大，他也要当一名军人；另一个孩子告诉我，他以后也要上电子科大，也要参加至微。从坚定的眼神里，从坚定的话语里，我知道了我们来这里的意义，可能并不能在这十五天带给孩子们多少专业知识上的提高，但这段经历，希望能为他未来还很长的人生中指明一个方向，甚至是能带领他们走一段路。 希望我们的出现能带给他们哪怕一点点对广阔世界探索的雄心，希望我们的出现能为他的日常所思所想带来哪怕一点点帮助，希望我们的出现能让他们永远记得我们相处这十五天！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Qt C++ Python 混合编程测试使用文档","slug":"Qt Python 混合编程测试文档","date":"2022-03-14T13:40:00.000Z","updated":"2022-07-20T14:43:41.623Z","comments":true,"path":"2022/03/14/Qt Python 混合编程测试文档/","link":"","permalink":"http://ckblogs.cn/2022/03/14/Qt%20Python%20%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/","excerpt":"","text":"Qt C++ Python 混合编程测试文档 [TOC] 环境版本 Qt：5.9.0 （MSVC 2017 64bit） Python： 3.10.2 (64 bit) 开发步骤 将 Python 集成到 Qt 中 安装Python环境（略） Qt 配置 Python 解释器 选项——环境——外部工具 添加工具：Python3 构建执行档：python.exe路径（我这里是 D:\\python\\python.exe） 参数：%{CurrentDocument:FilePath} 工作目录：%{CurrentDocument:Path} 添加 Python 脚本文件 打开项目文件，选择添加 Python File 文件。 本文将用下面的两个函数作为测试函数，分别接受一个 Python 列表和一个 numpy.darray, 将他们排序后并返回。具体如下所示： 注意：这里不能命名文件为 test.py。 会和python定义的test.py重复，运行会报错找不到.py文件。所以不要将.py文件命名为test.py。 123456789101112131415# list_test.pyimport numpydef sort_by_list(mylist): print(&#x27;使用python列表&#x27;) mylist.sort() return mylistdef sort_by_numpy_list(myarray): # if type(myarray) is not numpy.ndarray: # return print(&#x27;使用numpy数组&#x27;) myarray.sort() return myarray 添加 Python 程序文件后，可用测试程序，按照下面的方式运行，检测是否添加文件成功。 Qt 调用Python脚本 pro 导入Python环境 12INCLUDEPATH +&#x3D; -I D:\\python\\includeLIBS +&#x3D; -LD:\\python\\libs -lpython310 注意： += -LD:\\python 中的 LD 不可分开 -lpython310 根据自己python版本决定，比如python 3.9 为 -lpython39 我的python路径如下所示： C++ 调用 Python 函数接口 API介绍 本文以上文两个函数为例，分别测试参数和返回值为 list 类型和 numpy.darray 类型的函数调用。 从操作步骤上看，C++调用 Python 低层接口可以分为几个阶段 初始化Python解释器 从C++到Python转换数据 用转换后的数据做参数调用Python函数 把函数返回值转换为C++数据结构 初始化Python解释器 123456#include &lt;Python.h&gt;...Py_Initialize();PyRun_SimpleString(&quot;import sys&quot;);PyRun_SimpleString(&quot;sys.argv = [&#x27;python.py&#x27;]&quot;);PyRun_SimpleString(&quot;sys.path.append(&#x27;./&#x27;)&quot;); 初始化Python后，可以通过 int PyRun_SimpleString(const char *command) 函数令解释器执行任意 python 代码。这种叫做高层接口。高层接口虽然方便，但很难与C/C++交换数据。所以对于复杂需求，应该使用低层接口。虽然需要多写很多C代码，但可以灵活的实现很多复杂功能。 C++ 数据转化为 PyObject PyObject 为 C++ 中 Python 的数据类型，传入 Python 函数的参数和从 Python 函数得到的返回值，必须以 PyObject 的形式存在。 基本数据类型转换 可以采用下面的库函数进行基本数据的转换： 123PyObject* PyLong_FromLong(long v)PyObject* PyBool_FromLong(long v)PyObject* PyFloat_FromDouble(double v) 可以采用 Py_BuildValue() 函数进行转换 PyObject *Py_BuildValue(const char **format*, ...) 下面给出几个例子 12345678910111213141516171819202122232425Py_BuildValue(&quot;&quot;) None Py_BuildValue(&quot;i&quot;, 123) 123 Py_BuildValue(&quot;iii&quot;, 123, 456, 789) (123, 456, 789) Py_BuildValue(&quot;s&quot;, &quot;hello&quot;) &#x27;hello&#x27; Py_BuildValue(&quot;ss&quot;, &quot;hello&quot;, &quot;world&quot;) (&#x27;hello&#x27;, &#x27;world&#x27;) Py_BuildValue(&quot;s#&quot;, &quot;hello&quot;, 4) &#x27;hell&#x27; Py_BuildValue(&quot;()&quot;) () Py_BuildValue(&quot;(i)&quot;, 123) (123,) Py_BuildValue(&quot;(ii)&quot;, 123, 456) (123, 456) Py_BuildValue(&quot;(i,i)&quot;, 123, 456) (123, 456) Py_BuildValue(&quot;[i,i]&quot;, 123, 456) [123, 456] Py_BuildValue(&quot;&#123;s:i,s:i&#125;&quot;, &quot;abc&quot;, 123, &quot;def&quot;, 456) &#123;&#x27;abc&#x27;: 123, &#x27;def&#x27;: 456&#125; Py_BuildValue(&quot;((ii)(ii)) (ii)&quot;, 1, 2, 3, 4, 5, 6) (((1, 2), (3, 4)), (5, 6)) 列表、元组类型转换 PyList、PyTuple List API 简单介绍 123456789101112131415161718192021222324252627282930// 判断是否是一个Python List（列表）int PyList_Check(PyObject *p) // 创建一个列表PyObject* PyList_New(Py_ssize_t len) // 获取列表元素的个数 len(list)Py_ssize_t PyList_Size(PyObject *list) // 和PyList_Size 一样，但是就是没有错误检查Py_ssize_t PyList_GET_SIZE(PyObject *list) // 从列表里面获取一个元素,计数器不会加1PyObject PyList_GetItem(PyObject list, Py_ssize_t index) // 和PyList_GetItem一样，但是就是没有错误检查PyObject PyList_GET_ITEM(PyObject list, Py_ssize_t i) // 设置别表指定位置的值，下标的所在的位置必须是有值的，并且是有效的int PyList_SetItem(PyObject list, Py_ssize_t index, PyObject item) // 和PyList_SetItem一样，但是就是没有错误检查void PyList_SET_ITEM(PyObject list, Py_ssize_t i, PyObject o) // 在列表指定位置插入值 list.insert(index, item)int PyList_Insert(PyObject list, Py_ssize_t index, PyObject item) // 在列表尾部追加值 list.append(item)int PyList_Append(PyObject list, PyObject item) // 获取列表里面一段切片数据，一段指定范围的数据 list[low:higt]PyObject PyList_GetSlice(PyObject list, Py_ssize_t low, Py_ssize_t high) // 设置列表分片数据，指定列表范围的数据 list[low:higt] = itemlistint PyList_SetSlice(PyObject list, Py_ssize_t low, Py_ssize_t high, PyObject itemlist) // 对列表数据进行排序 list.sort()int PyList_Sort(PyObject *list) // 把列表里面的所有数据反转 list.reverse()int PyList_Reverse(PyObject *list) // 将Python列表转为Python元组 tuple(list)PyObject PyList_AsTuple(PyObject list) 具体使用如下所示： 12345678// 将C++ 数组 array_1 转化为 PyList PyObject *PyList = PyList_New(SizeOfList) // 定义一个长度为 SizeOfList 的列表for(int Index_i = 0; Index_i &lt; SizeOfList; Index_i++)&#123; PyList_SetItem(PyList, Index_i, Py_BuildValue(&quot;i&quot;, arrayA[Index_i])); &#125; Tuple API 简单介绍 1234567891011121314151617181920// 判断是否是一个元组对象int PyTuple_Check(PyObject *p) // 创建Python元组对象，注意元组创建是必须设置长度的，如果设置长度为0，则这个元组对象是一个空的元组PyObject* PyTuple_New(Py_ssize_t len) // 获取元组的长度，即元组的大小Py_ssize_t PyTuple_Size(PyObject *p) // 和PyTuple_Size一样，只不过这个方法没有错误检查的机制Py_ssize_t PyTuple_GET_SIZE(PyObject *p) // 获取元组内指定下标的值PyObject PyTuple_GetItem(PyObject p, Py_ssize_t pos) // 和PyTuple_GetItem一样，只不过这个方法没有错误检查的机制PyObject PyTuple_GET_ITEM(PyObject p, Py_ssize_t pos) // 获取分片数据 p[lwo, higt]PyObject PyTuple_GetSlice(PyObject p, Py_ssize_t low, Py_ssize_t high) // 设置元组指定下标的值int PyTuple_SetItem(PyObject p, Py_ssize_t pos, PyObject o) // 和PyTuple_SetItem一样，只不过这个方法没有错误检查的机制void PyTuple_SET_ITEM(PyObject p, Py_ssize_t pos, PyObject o) // 改变元组的大小int _PyTuple_Resize(PyObject **p, Py_ssize_t newsize) 用法与 PyList 基本一致。 numpy.darray API 简单介绍 在使用此类型之前，必须进行一些配置： 在Pro文件中，加入下面语句，使得配置环境包括numpy/arrayobject.h： 1INCLUDEPATH += -I D:\\python\\Lib\\site-packages\\numpy\\core\\include 添加头文件 #include &lt;numpy/arrayobject.h&gt; 添加函数 init() 并在 Py_Initialize();后调用函数，注意，这里可能出错，需要调整使用 Release 编译而不是 Debug 编译。 123456789#include &lt;numpy/arrayobject.h&gt;...int init_numpy() &#123; import_array();&#125;...Py_Initialize();init_numpy(); 做完初始化后，我们就可以使用 PyArrayObject 对象。先对PyArrayObject 对象做一个简单的介绍。PyArrayObject 实际上是一个结构体，结构体内包含四个元素，用来访问 Numpy Array 中的数据： int nd：Numpy Array数组的维度。 int *dimensions ：Numpy Array 数组每一维度数据的个数。 int *strides：Numpy Array 数组每一维度的步长。 char *data： Numpy Array 中指向数据的头指针。 所以当我们要访问 PyArrayObject 对象中的数据时，有: 123456 //对于一维 Numpy Array 数组，我们访问[i]位置处的元素的值 PyArrayObject *array array-&gt;data + i*array-&gt;strides[0] //对于二维 Numpy Array 数组，我们访问[i, j]位置处的元素的值 PyArrayObject *array array-&gt;data + i*array-&gt;strides[0] + j*array-&gt;strides[1] 我们以创建一维数组为例： 1234567npy_intp Dims[1] = &#123;colCnt&#125;; //给定维度信息for(int i = 0;i &lt; colCnt; i++)&#123; arrayA[i]=ui-&gt;tableA-&gt;item(0,i)-&gt;text().toInt();&#125;PyObject *PyArray = PyArray_SimpleNewFromData(1, Dims, NPY_INT, arrayA); 调用 Python 函数 我们首先需要指定 模块和函数： 12PyObject* PyModule = PyImport_ImportModule(&quot;list_test&quot;); // 指定模块 list_test.pyPyObject* PyFun= PyObject_GetAttrString(PyModule,&quot;sort_by_numpy_list&quot;);// 指定函数 所有的参数通过一个元组数据结构进行传递，具体如下所示： 123 //定义一个Tuple对象，Tuple对象的长度与Python函数参数个数一致PyObject *PyArg = PyTuple_New(1); PyTuple_SetItem(PyArg, 0, PyArray); //参数设置,PyArray 是要传递进去的参数 采用下面的方式调用函数并且获得返回值： 1PyObject *PyResult = (PyArrayObject *)PyObject_CallObject(PyFun, PyArg); 返回值转化为 C++ 数据结构 基本数据结构 可以使用基本库函数 12345// 使用一系列库函数转换基本变量long PyLong_AsLong(PyObject *obj)long PyInt_AsLong(PyObject *obj)double PyFloat_AsDouble(PyObject *obj)string PyString_AsString(PyObject *obj) 可以使用 PyArg_Parse() 函数 1int PyArg_Parse(PyObject *args, const char *format, ...) 具体使用如下所示： 12345678 int num;int SizeOfList = PyList_Size(PyResult);//List对象的大小，这里SizeOfList = 3 for(int Index_i = 0; Index_i &lt; SizeOfList; Index_i++) &#123; PyObject *Item = PyList_GetItem(PyResult, Index_i);//获取List对象中的每一个元 PyArg_Parse(Item, &quot;i&quot;, &amp;num); cout &lt;&lt; num &lt;&lt; endl; &#125; PyList、PyTurpe 只能通过上例，单独访问转换获得每一个元素，进而组成 C++ 数组形式。 numpy.darray 只能通过下例，单独访问转换获得每一个元素，进而组成 C++ 数组形式。 123456789 int num; // 临时数据存储 int SizeOfList = PyResult-&gt;dimensions[0];//List对象的大小，这里SizeOfList = 3 for(int Index_i = 0; Index_i &lt; SizeOfList; Index_i++) &#123; //访问数据，Index_m 和 Index_n 分别是数组元素的坐标，乘上相应维度的步长，即可以访问数组元素 num = *(int *)(PyResult-&gt;data + Index_i * PyResult-&gt;strides[0]);cout &lt;&lt; num &lt;&lt; endl; &#125; 在接受 numpy.darray 返回值时，需要通过下面的方式： 1PyArrayObject *PyResult = (PyArrayObject *)PyObject_CallObject(PyFun, PyArg); 常见问题总结 **坑1、**首先是.py程序的名称，别命名为test.py，会和python定义的重复的，随便都想，就是别用这个名字，否则不管你里面写什么函数一律找不到，以为它压根读到的就不是这个文件。 **坑3、**怎么导入静态库： Pro文件下右键–添加库–然后外部库–然后看图– **坑4、**如果提示你找不到 python37_d.lib 怎么办 那就把libs文件夹下的python37.lib文件，重新拷一份回来并且重命名为python37_d.lib就行了 **坑5、**提示打不开python.h文件 首先你导入库正确了，就像第三条说的那样做就行，接下来是这里的问题： 你只需要更改下构建的路径就行了，或者更简单的直接将对号去掉构建在当前工程同一个文件夹下。 **坑6、**当你做完第五步，你会发现尼玛还有问题，提示的error：error: expected unqualified-id before ‘;’ token 将error展开说是在python中的object.h文件中的slots冲突，天哪，发生了什么？解决吧 原因：由于QT中定义了slots作为关键了，而python3中有使用slot作为变量，所以有冲突 坑7、 你还要将你的.py文件放在和QT的EXE文件在同一目录下，否则还会持续报错 坑8、 QT Creator 使用 design 修改 ui界面编译后界面未更新问题的解决。项目设置文件.pro内增加 UI_DIR=./UI，同时删除掉源代码目录中ui_*.h，clear all,-&gt;qmake-&gt;rebuilt all 坑9、 fatal error: numpy/arrayobject.h: No such file or directory：在Pro文件添加路径，详情请看上文有提到。 坑10、 Qt Creator mainwindow.obj-1: error: LNK2019 请先把已经存在的debug和release文件夹删除，重新编译，看会不会再出现这个问题； 如果还在出现，那绝对说明你的一些成员函数只有声明没有实现，或者两者不一致 官方文档与参考博文 官方文档 Python/C API 参考手册 NumPy C-API 参考博文 C++(Qt)与Python混合编程(一) Python + C/C++ 嵌入式编程（1）：多维数组Numpy.Array()在Python和C/C++文件间的传递问题 C/C++调用Python函数（CodeBlocks平台实现） C++调用Python的API总结 Py_BuildValue()函数 Python C API的使用详解（一） Python C API的使用详解（二） QT调用python脚本时遇到的坑（十一大坑全有） fatal error: numpy/arrayobject.h: No such file or directory","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Qt - C++","slug":"Qt-C","permalink":"http://ckblogs.cn/tags/Qt-C/"},{"name":"Python - 混合编程","slug":"Python-混合编程","permalink":"http://ckblogs.cn/tags/Python-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}]},{"title":"Qt C++ Matlab 混合编程测试使用文档","slug":"Qt Matlab 混合编程测试使用文档","date":"2022-03-14T13:35:00.000Z","updated":"2022-07-20T14:42:01.703Z","comments":true,"path":"2022/03/14/Qt Matlab 混合编程测试使用文档/","link":"","permalink":"http://ckblogs.cn/2022/03/14/Qt%20Matlab%20%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/","excerpt":"","text":"Qt C++ Matlab 混合编程测试使用文档 [TOC] 环境版本 Qt：5.9.0 MSVC 2017 64bit 编译器 Matlab：R2019b （64bit） Windows 11 64位 开发步骤 本文就介绍使用 Qt 5.9 和 Matlab 进行混合编程的基本流程，主要包括： 如何在Matlab中将m文件编译为C++语言的DLL文件 如何在Qt项目中加入自定义DLL相关的LIB文件，以及MATLAB相关的LIB文件和H文件搜索路径 如何在Qt中调用自定义DLL中的函数，如何通过mwArray类传递输入输出参数 Matlab 动态链接库的生成 Matlab 函数的编写 在 Matlab 中编写函数，这里编者以两个矩阵相加函数 matAdd 作为测试函数。并保存为 matAdd.m 文件。 1234function C= matAdd(A,B)% C= matAdd(A,B), 两个矩阵相加C=A+B;end 注意：需要多个 Matlab 函数时，需要将各个文件保存到不同的Matlab文件中，在下面的步骤中统一集合成相关动态链接库和头文件。 设置MATLABCompiler 编译器 在 Matlab 命令行输入下面的内容。 12&gt;&gt; mbuild -setup C++MBUILD 配置为使用 &#x27;Microsoft Visual C++ 2017&#x27; 以进行 C++ 语言编译。 注意：编者采用 ‘Microsoft Visual C++ 2017’ 进行 C++ 编译，和 Qt 编译器保持一致，暂不清楚不同编译器是否会对结果造成影响。电脑上安装了Visual Studio 2017，MATLAB会自己查找可用的编译器。 Library Compiler 在 Matlab 命令行输入下面的内容： 1&gt;&gt; deploytool 并选择 ‘Library Compiler’ :“ApplicationCompiler”用于将m文件编译为exe文件直接运行，“Library Compiler”用于将m文件编译为DLL、COM组件等形式。我们要生成DLL文件，所以选择“Library Compiler”。 ‘TYPE’ 部分选择 C++ Shared Library ，“EXPORTED FUNCTIONS” 选择待添加的文件（这里可以添加多个函数文件）。右侧是MATLAB运行时库的安装打包方式，在本机上测试可选择“Runtime downloaded from web”。添加完毕后点击‘Package’ 进行编译和打包。 Qt 调用环境配置 打包完毕后，项目文件 matAdd.prj 目录下生成与其项目同名的子目录，即 \\matAdd，该目录下有 3 个文件夹。我们主要需要 matAdd\\for_redistribution_files_only 目录下是编译生成的.dll 、.lib和.h文件。其中.lib和.h文件是在Qt项目编译时需要用到的，.dll文件是程序运行时需要用到的。 这三个文件，需要复制到 Qt 的 pro 目录下。 matAdd.lib 文件的加入 打开 pro 库，右键选择添加库，选择添加外部库，加入目录中的 matAdd.lib 文件，其他选择如图所示： 在 pro 文件中，将会出现下面几段代码： 1234567win32: LIBS += -L$$PWD/./ -lmatAdd INCLUDEPATH += $$PWD/.DEPENDPATH += $$PWD/.win32:!win32-g++: PRE_TARGETDEPS += $$PWD/./matAdd.libelse:win32-g++: PRE_TARGETDEPS += $$PWD/./libmatAdd.a 为了方便查看matAdd.h的内容，还可以将matAdd.h文件添加到项目中，但是要注意不要修改matAdd.h文件的内容。 Matlab 依赖库和头文件搜索路径的加入。 除了自己编译生成的DLL相关的.lib文件和头文件，要编译此Qt项目，还需要用到MATLAB的几个.lib文件和.h文件。 我的电脑上，MATLAB2019b安装在 D:/Program/matlab2019 目录下，在 testAdd.pro 文件中需要加入如下的设置： 1234567891011121314INCLUDEPATH += &#x27;D:/Program/matlab2019/matlab/extern/include&#x27;INCLUDEPATH += &#x27;D:/Program/matlab2019/matlab/extern/include/win64&#x27;win32: LIBS += -L&#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft/&#x27; -llibmexwin32: LIBS += -L&#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft/&#x27; -llibmxwin32: LIBS += -L&#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft/&#x27; -llibmatwin32: LIBS += -L&#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft/&#x27; -llibengwin32: LIBS += -L&#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft/&#x27; -lmclmcrwin32: LIBS += -L&#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft/&#x27; -lmclmcrrtINCLUDEPATH += &#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft&#x27;DEPENDPATH += &#x27;D:/Program/matlab2019/matlab/extern/lib/win64/microsoft&#x27;INCLUDEPATH += &#x27;D:/Program/matlab2019/matlab/extern/lib/win64&#x27;DEPENDPATH += &#x27;D:/Program/matlab2019/matlab/extern/lib/win64&#x27; 注意：注意，若路径名称中含有空格，需要使用quote()，如 #INCLUDEPATH+=$$quote(D:/MATLAB2017b/extern/include) 系统环境变量的配置 若是程序发布到没有安装MATLAB的电脑上，需要用Matlab Compiler编译生成的安装包，本例就是 matAdd\\for_redistribution目录下的MyAppInstaller_web.exe。 若只是要独立安装MATLAB运行时库，在MATLAB 命令行里输入 mcrinstaller可以得到离线的MATLAB运行时库安装文件的路径。 1&gt;&gt; mcrinstaller 更多相关内容见：在没有安装MATLAB的电脑上运行MATLAB程序 C++ 对 Matlab 函数调用 测试设计 UI 界面如下所示： 所用到的控件如下图所示： matAdd.dll 的初始化 在使用 matAdd.dll 函数之前，需要调用 matAdd.h 里的函数 matAddInitialize 进行初始化 我们将初始化在窗口的构造函数里完成。下面是构造函数的代码： 12345678910111213141516MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); // 不执行matAddInitialize()会报错，注意matAdd为文件名 if(matAddInitialize()) &#123; ui-&gt;TextEdit-&gt;setText(&quot;matlab程序DLL初始化成功.&quot;); &#125; else &#123; ui-&gt;TextEdit-&gt;setText(&quot;*** matlab程序DLL初始化失败&quot;); return; &#125;&#125; mwArray 类的使用 （1）构造函数如下所示： 1mwArray(num_rows,num_cols,mxID,cmplx=mxREAL) num_rows表示行数， mwSize是整数类型 num_cols表示列数 mxID是mxClassID类型，表示元素的基本数据类型，常见的有如下的一些取值mxLOGICAL_CLASS mxCHAR_CLASS mxDOUBLE_CLASS mxSINGLE_CLASS mxINT8_CLASS mxUINT8_CLASS mxINT16_CLASS mxUINT16_CLASS mxINT32_CLASS mxUINT32_CLASS mxINT64_CLASS mxUINT64_CLASS cmplx是mxComplexity类型，有mxREAL和mxCOMPLEX两种取值，标书数组元素是实数或复数，缺省为mxREAL （2）mwArray数组的赋值 1mwArray:: SetData(mxUint64* buffer, mwSizelen) 其中，buffer必须是一维数组，即便mwArray变量是一个二维数组，len是一维数组的元素个数，等于行数乘以列数。在给二维数组赋值时，buffer必须按列存储数据（见代码内容）。 123456789101112131415161718192021void MainWindow::on_pushButton_clicked()&#123;// 两个矩阵相加， C=A+B//读取矩阵A int rowCntA=ui-&gt;spinBoxA_Row-&gt;value(); int colCntA=ui-&gt;spinBoxA_Col-&gt;value(); int elementCntA=rowCntA*colCntA; //元素个数 //一维数组，用于C++向 MATLAB数组传递数据 double *arrayA=new double[elementCntA]; int N=0; //C++的一维数组的元素索引号 for(int i=0;i&lt;ui-&gt;tableA-&gt;columnCount();i++) //逐列读取，序列化存储到一维数组 for (int j=0; j&lt;ui-&gt;tableA-&gt;rowCount();j++) &#123; arrayA[N]=ui-&gt;tableA-&gt;item(j,i)-&gt;text().toDouble(); N++; &#125; //定义数组，行，列，double类型 mwArray matrixA(rowCntA,colCntA,mxDOUBLE_CLASS, mxREAL); //将C++ 的一维数组arrayA存储到 MATLAB的二维数组matrixA matrixA.SetData(arrayA,elementCntA); （3）mwArray数组元素的读取 可以使用mwArray::Get()函数读取数组的元素， 例如，对于二维数组，采用Get()函数读取数据的代码一般是 12int dim=2; // 二维数组double value=matrixA.Get(dim,j,i); //按照dim维数数组读出，第j行， 第i列 也可以不用行号、列号，而用序号读取，如 12int dim=2; // 二维数组double value=matrixA.Get(dim,N); //按照dim维数数组读出，第N个元素 这里的N是按列排列的元素的总的序号。对于二维数组，还是按照行号、列号更直观一些。 也可以直接使用mwArray的“()”操作符读取数组元素，如 12double value=matrixC(j,i); //直接用数组下标索引，第j行，第i列double value=matrixC(N); //直接按元素序号读取, 第N个元素 Matlab 函数的调用 在我们已经通过上述方式进行 mwArray 进行 数组的定义与赋值后，我们可以直接通过 Matlab 函数文件的原函数名进行函数的调用，需要传入的参数为： nargout：输出变量个数 matrixC: 保存返回矩阵的 mwArray类，需要指定相关属性。 matrixA、matrixB：matlab 原函数中的两个参数矩阵。 12345678 //计算, C=A+B int rowCntC=rowCntA; int colCntC=colCntA;//定义数组，行，列，double类型 mwArray matrixC(rowCntC,colCntC,mxDOUBLE_CLASS, mxREAL); int nargout=1;//输出变量个数// 调用函数，计算 C = A + B matAdd(nargout,matrixC,matrixA,matrixB); 其他官方文档及常见问题 mwArray 类官方文档 Class used to pass input/output arguments to C++ functions generated by MATLAB Compiler SDK 常见问题 错误使用 mbuild (line 166) Unable to complete successfully. 未找到支持的编译器。 Qt与Matlab混合编程细节总结 学习笔记：Qt与Matlab混合编程及遇到的诸多问题（附DEMO） 以上链接内容仅供参考，实际操作过程会遇到无数的坑。。。下面的网址可以解决百分之八九十的问题： stackoverflow CSDN","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Qt - C++","slug":"Qt-C","permalink":"http://ckblogs.cn/tags/Qt-C/"},{"name":"Matlab - 混合编程","slug":"Matlab-混合编程","permalink":"http://ckblogs.cn/tags/Matlab-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}]},{"title":"数据通信与计算机网络——（一）概述","slug":"数据通信与计算机网络","date":"2022-03-13T13:40:00.000Z","updated":"2022-07-20T14:43:33.072Z","comments":true,"path":"2022/03/13/数据通信与计算机网络/","link":"","permalink":"http://ckblogs.cn/2022/03/13/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"数据通信与计算机网络——（一）概述 [TOC] 概述 数据通信系统模型 源系统 **源点：**它是生成数据的设备。如计算机输出的数字比特流。 **发送器：**通常源点生成的数据要通过发送器编码后才能够成为在传输系统中进行传输的电磁信号。典型的发送器是调制器，它将计算机输出的数字比特流转换成可在电话网上传输的模拟信号。 传输系统 传输线或网络系统。 目的系统 **接收器：**接收来自传输系统的信号，并将其转换成终点可处理的信息。典型的接收器是解调器，它把来自传输线路上的模拟信号进行解调，还原出发送端产生的数字比特流。 终点： 获取来自接收器数据的设备。 *数字通信系统主要性能指标 有效性指标 指衡量数据通信系统的传输能力的指标。 常用带宽、传输速率和频带利用率等指标来表示。 特征性指标 指衡量数据通信系统的传输质量的指标。这些指标与有效性指标有很大关系。 常用有差错率、可靠性、通信的建立时间、适应性和可维性、经济性、标准性。 有效性指标 带宽 传输速率 频带利用率 特征性指标 差错率 可靠性 主要靠以下两个指标来描述。这里假设一个通讯系统从它工作开始至 TTT 时刻，共发生过 NNN 次故障，进行过 NNN 次维修，每次正常运行的时间是Δti\\Delta t_iΔti​ ，每次维修时间是 ΔtFi\\Delta t_{Fi}ΔtFi​，则这两个指标分别是： 平均无故障工作时间 MTBF（Mean Time Between Failure）：指系统各部件相邻两次发生故障的平均间隔时间。 MTBF=∑i=1NΔti/NMTBF= \\sum^{N}_{i=1}\\Delta t_i/N MTBF=i=1∑N​Δti​/N 平均故障维修时间 MTTR (Mean Time To Repair) ：指系统发生故障时所需要维修花费的平均时间。 MTTR=∑i=1NΔtFi/NMTTR=\\sum^{N}_{i=1}\\Delta t_{Fi}/N MTTR=i=1∑N​ΔtFi​/N 系统有效度：系统在规定条件和规定时间内，维持规定功能的概率。 A=MTBFMTBF+MTTRA=\\cfrac{MTBF}{MTBF+MTTR} A=MTBF+MTTRMTBF​ 数据通信网络 数据通信网络的组成 数据通信网络由硬件和软件两部分组成。硬件指数据传输设备、数据交换设备和通信线路等。软件指支持硬件配置实现网络协议功能的各种程序。 数据通信网络的分类 广域网 指覆盖范围很广的远程网络，由结点交换机及其连接的线路组成。目前主要采用分组交换技术。 局域网 指通过通信线路，把较小地域范围内的各种设备连接在一起的通信网络。 城域网 指覆盖范围界于前两者之间的，面向企业的公用网络。 计算机网络概述 计算机网络的组成 根据因特网的工作方式，它由两大部分组成。 ① 核心部分 由大量的各种网络和连接这些网络的路由器组成。它为周边部分提供连通和交换服务。 在核心部分起特殊作用的是路由器(router)。路由器是一种专用计算机，它的主要功能是转发接收到的分组，是因特网上实现分组交换(packet switching)的关键部件。 ② 周边部分 由所有连接在因特网上的主机组成。它为用户提供通信(传送数据、音频或视频)和资源共享服务。位于因特周边部分任何两台主机之间的通信，实际上是指：“主机A的某个进程和主机B上的另一个进程进行通信”。通常把这些主机称为端系统（end system）。 端系统之间的通信有两种模式： 客户/服务器模式(Client/Server model) 主机A(客户)向主机B。 (服务器)发出请求服务。主机B(服务器) B向主机A(客户)提供服务。 对等模式(Peer-to-Peer) 对等模式 (peer-to-peer，简写 P2P)是指两个主机通信时所处的地位是对等的，它们运行着对等软件就可以同时起着客户或服务器的作用向对方提供服务。 计算机网络的分类 按照不同范围的网络：互联网、广域网WAN、城域网MAN、局域网LAN、个人区域网PAN。 按照不同服务对象：公用网络、专用网络 *计算机网络的性能指标 速率（speed） 定义：计算机网络中的主机在信道上单位时间内的传输量。也称数据率（data rate）或比特率（bit rate）。 单位：比特/秒 （bit/s）或者 bps 注意：这里是额定速率，实际速率要比此值更低。 带宽 (bandwidth) 定义：是指某个信号所具有的频带宽度。一个信号可能包含不同的频率成分，它的带宽就是这个信号不同频率成分所占的频率范围。如今的网络通信线路，将带宽表示通信线路传送数据的能力，即从网络中的某一点到另外一点所能达到的最高数据传输速率。 单位：比特/秒(bit/s) 注意：在“带宽”的上述两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。 吞吐量（throughput） 定义：指单位时间内通过某个网络(或信道、接口)的数据量。 单位：比特/秒 （bit/s）或者 bps 注意：吞吐量更经常用于对某个网络的性能测试，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。如 100Mbit/s 的以太网，带宽是 100Mbit/s ，典型的吞吐量可能只有 70Mbit/s。 时延（delay） 定义：时延指数据(一个报文或分组或比特)从网络(或链路)的一端传送到另一端所需的时间。 单位：秒（s） 总时延 = 传输时延 + 传播时延 + 处理时延+ 排队时延 发送时延 指主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 发送时延=数据帧长度(b)信道带宽(b/s)\\text{发送时延}=\\cfrac{\\text{数据帧长度}(b)}{信道带宽(b/s)} 发送时延=信道带宽(b/s)数据帧长度(b)​ 传播时延 指电磁波在信道中传播一定距离所花费的时间。 传播时延=信道长度(m)电磁波在信道中的传播速率(m/s)\\text{传播时延}=\\cfrac{\\text{信道长度}(m)}{电磁波在信道中的传播速率(m/s)} 传播时延=电磁波在信道中的传播速率(m/s)信道长度(m)​ 自由空间中电磁波的传播速率为 3.0×105km/s3.0×10^5 km/s3.0×105km/s 铜线电缆中电磁波的传播速率为 2.3×105km/s2.3×10^5 km/s2.3×105km/s 光缆中电磁波的传播速率为 2.0×105km/s2.0×10^5 km/s2.0×105km/s 处理时延 指主机或网络结点(路由器或交换机) 处理分组所花费的时间。包括对分组的首部分析、从分组中提取数据部分、进行差错检验或查找适当的路由等 。 排队时延 指分组进入网络结点后，需先在输入队列中排队等待处理，以及处理完毕后在输出队列中排队等待转发的时间。排队时延的长短往往取决于网络中当时的通信量。当网络的通信量很大时，会发生队列溢出，使分组丢失，这相当于处理时延为无穷大。 往返时间 RTT (Round-Trip Time) 表示从发送端发送数据开始，到发送端收到来自接收端的确认应答所经历的全部时间。如果接收端收到数据后立即发送确认，这相当于传播时延的两倍。 时延带宽积 定义：时延带宽积是指传播时延与带宽之乘积。 $$ 时延带宽积=传播时延\\times 带宽 $$ 单位：b 注意：链路的时延带宽积又称为以比特为单位的链路长度。 利用率 定义： 信道利用率：指在规定时间内信道上用于传输数据的时间比例。完全空闲的信道的利用率是零。 网络利用率：指全网络的信道利用率的加权平均值。 U=1−D0DU=1-\\cfrac{D_0}{D} U=1−DD0​​ 式中，D0D_0D0​表示网络空闲时的时延，DDD 表示网络当前的时延。UUU 的数值在 0 到 1 之间。 注意：信道利用率力求高些，但并非越高越好。因为信道的利用率增大时，该信道引起的时延也就迅速增加。拥有较大主干网的ISP都把信道利用率控制在50%以内，否则就采取扩容措施。 计算机网络体结构模型 基本分层结构模型 网络协议 为进行网络中的数据交换而建立的规则、标准或约定即网络协议(network protocol)，简称为协议。这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。网络协议需要包括： 语法 数据与控制信息的结构或格式。 语义 需要发出何种控制信息，完成何种动作以及做出何种响应。 同步 事件实现顺序的详细说明。 OSI模型 TCP/IP模型 应用层 该层向用务提供一组常用的应用程序，为不同主机上的进程或应用之间提供通信。 传输层 该层提供端对端系统的数据传送服务。 互联网层 该层使用网际协议实现穿越多个网络的路由选择功能。 网络接口层 该层是端系统和通信子网之间的接口，实现端系统与其相连的网络进行数据交换 五层体系结构 应用层(application layer) 确定进程间通信的性质以满足用户的需求，直接为用户的应用进程提供服务。 传输层(transport layer) 负责主机中两个进程之间的通信(端到端通信)。 网络层(network layer) 负责为分组交换网上的不同主机提供通信。 数据链路层(data link layer，简称链路层) 在两个相邻结点间的线路上无差错地传送以帧为单位的数据。 物理层(physical layer) 透明地传送比特流。 其他重要概念 实体 实体(entity) 指任何可发送或接收信息的硬件或软件进程。实体通常指一个特定的软件模块。 协议 协议(protocol)是控制两个对等实体进行通信的规则的集合。协议的语法定义了所交换信息的结构或格式；协议的语义定义了源端和目的端所要完成的操作。 服务 服务(service)指同一开放系统中某一层向它的上一层提供的操作，但不涉及这些操作的具体实现。 服务访问点（端口） 服务访问点 SAP (Service Access Point)指同一开放系统中相邻层的实体提供服务的交互处。是位于相邻层的界面上，也就是相邻层实体交互的逻辑接口。又称端口(port)。 在OSI模型中，对等层实体传送数据的单位，称为协议数据单元PDU(Protocol Data Unit)。相邻层实体间传送数据的单位，称为服务数据单元SDU(Service Data Unit)。相邻层实体通过SAP一次交互信息的数据单位，称为接口数据单元IDU(interface Data Unit)。 面向连接服务与无连接服务 面向连接服务(connection-oriented) 面向连接服务具有连接建立、数据传输和连接释放三个阶段。 传输的数据具有顺序性。 适用于在一定时期内向同一地发送多个报文的场合。 无连接服务(connectionless) 两个实体之间的通信不需要先建立好一个连接，下层的资源无需事先预作准备，即资源可进行动态分配。无连接服务是一种不可靠的服务，常被描述为“尽最大努力交付”(best effort delivery)或“尽力而为”。 两个通信实体无需同时处于活跃(active)状态。 无连接服务最主要的类型：数据报(datagram) 优点：灵活、方便。缺点：不能防止报文的丢失、重复和失序。 服务原语 在OSI模型中，相邻层之间的服务可用原语(primitive)和参数(parameter)来表示。 原语是相邻层实体交互时所交换的一些必要信息，定义了所执行的操作，其具体实现是通过中断、函数调用、系统调用或OS提供的进程控制机制完成的。 参数用于传递数据和控制信息。 一个完整的服务原语由名字、类型和参数组成。","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ckblogs.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Python 语法糖：你真的会用 Python 吗？","slug":"Python 语法糖：你真的会用 Python 吗？","date":"2022-02-16T09:00:00.000Z","updated":"2022-03-14T13:29:52.330Z","comments":true,"path":"2022/02/16/Python 语法糖：你真的会用 Python 吗？/","link":"","permalink":"http://ckblogs.cn/2022/02/16/Python%20%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%20Python%20%E5%90%97%EF%BC%9F/","excerpt":"","text":"Python 语法糖：你真的会用 Python 吗？ [TOC] 人生苦短，我用 Python！ 作为一门以简洁、优美为代表的语言，Python 受到众多开发者的喜爱。相信有部分 Python 的开发者们，知道“Python 之禅”即“The Zen of Python”，通过 import this 语句就可以看到，Python 创建者对 Python 语言书写规范的建议： 123456789101112131415161718192021The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#39;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#39;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#39;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#39;s do more of those! 这篇文章，向大家介绍十个 Python 语法糖，意在帮助大家写出更加优美简洁的 Python 程序。 变量的交换 在 C语言等其他大部分语言中，变量的交换通常需要定义一个临时变量作为桥梁，但在 Python 语言中，下面的交换变量方式显得更加方便： 12345678// C语言中的变量交换int a = 1;int b = 2;int temp;temp = a;a = b;b = temp; 1234# python 语言中的变量交换a = 1b = 2b, a = a, b 字符串的格式化 通常在字符串的组合与拼接中，我们通常采用字符串和 + 号的形式将他们联系起来，你是否是这样的呢？ 12name = &#x27;Peter&#x27;print(&#x27;Hello, I am &#x27; + name) 但是，当变量很多时，这样的方式写会使程序变得十分的杂乱： 12345name = &#x27;Peter&#x27;country = &#x27;China&#x27;age = 17print(&#x27;Hello, My name is &#x27; + name + &#x27;, I am &#x27; + str(age) + &#x27;, I come from &#x27; + country + &#x27;.&#x27;) 就会显得十分的杂乱。因此，有下面几个解决措施： format 函数 上面的代码，我们通过 format 以下面的形式进行解决： 12345name = &#x27;Peter&#x27;country = &#x27;China&#x27;age = 17print(&#x27;Hello, My name is&#123;&#125;, I am &#123;&#125; ,I come from &#123;&#125;.&#x27;.format(name, country, age)) 我们将 &#123;&#125; 去临时替代将要使用的变量名称，而最终，它会和 format 中传入的参数值一一对应，这种方式也可以避免了不同类型变量的类型转换。 f-string 写法 对于 Python 3.6 即以上的版本，下面这种写法相信是对字符串最简单的写法： 12345name = &#x27;Peter&#x27;country = &#x27;China&#x27;age = 17print(f&#x27;Hello, My name is&#123;name&#125;, I am &#123;country&#125; ,I come from &#123;age&#125;.&#x27;) 我们只需要将字符串前写一个 ‘f ’， 花括号中的内容将会自动替换为其中的变量指定表达式的值。由于这里说明是表达式的值，意思是如果花括号中为&#123;age+1&#125;那字符串中也将会被自动替换为‘18’，这里甚至可以传进去一个函数，那么字符串中将会显示函数中的返回值。 Yield 语法 接下来是一个斐波那契数列的生成函数如下所示： 1234567891011def fibonacci(n): a = 0 b = 1 nums = [] for _ in range(n): nums.append(a) a, b = b, a + b return numsfor i in fibonacci(15): print(i) 这个程序的运行结果是打印出斐波那契数列的前十五个数。 通过 Python 的 yield 函数，下面的方式可以完整的替换上面的方式： 123456789def fibonacci(n): a = 0 b = 1 for _ in range(n): yield a a, b = b, a + bfor i in fibonacci(15): print(i) 在调用这个函数时，每当我们计算出一个元素，yield 就会立马将这个元素给送出去，这样做的好处，我们并不需要等待整个列表生成完毕时才将他产出，解决一些耗时问题时，可以很有帮助。 简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。 列表解析式 假如说，我们有一个列表，里面存放了各个水果的名称，我们想要将其中的每个名字的首字母大写，将使用下面的方式： 1234fruits = [&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;]for i in range(len(fruits)): fruits[i] = fruits[i].upper 其实这里有一个更简单的方法： 123fruits = [&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;]fruits = [fruit.upper() for fruit in fruits] 列表解析式在生成列表的过程中也可以有筛选的功能，假如我们要挑选所有首字母为 ‘a’ 的水果，我们可能会这样写： 123456fruits = [&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;]filtered_fruit = []for f in fruits: if f.startswith(&quot;a&quot;): filtered_fruit.append(f) 通过列表解析式的方式，我们可以很简洁的采用下面的方式代替： 123fruits = [&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;]fruits = [fruit for fruit in fruits if fruit.startswitch(&#x27;a&#x27;)] Enumerate 函数 Python 对循环的技巧。 如果我们同时想获取循环项的索引值和元素的内容，我们可以通过采用enumerate函数的方法，具体使用可以见下所示; 1234fruits = [&#x27;apple&#x27;, &#x27;pear&#x27;,&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;]for i, fruit in enumerate(fruits): print(i, fruit) # i 为索引值， fruit 为内容 遍历方法 对上一条的衍生。 反向遍历 如果我们想反向遍历一个列表，我们可以采用下面的方法，即设置一个 reversed() 函数。 1234fruits = [&#x27;apple&#x27;, &#x27;pear&#x27;,&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;]for i, fruit in enumerate(reversed(fruits): print(i, fruit) # i 为索引值， fruit 为内容 按顺序遍历 如果我们想按照各个水果首字母在字典中的顺序，我们可以采用下面的方法，即设置一个 sorted() 函数。 1234fruits = [&#x27;apple&#x27;, &#x27;pear&#x27;,&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pineapple&#x27;]for i, fruit in enumerate(sorted(fruits): print(i, fruit) # i 为索引值， fruit 为内容 字典的合并 在这里我们有两个字典，分别存放用户的用户名和密码，我们要将他们合并为同一个字典，Python 中不允许对字典直接相加。因此可以采用下面的方式： 1234567a = &#123;&quot;tom&quot;: &quot;112235&quot;, &quot;xiaoming&quot;: &quot;464323&quot;&#125;b = &#123;&quot;tony&quot;: &quot;156735&quot;, &quot;xiaowang&quot;: &quot;476587&quot;&#125;c = &#123;&#125;for key in a: c[key] = a[key]for key in b: c[key] = b[key] 其实这里有更简单的 方法合并两个字典： 1234a = &#123;&quot;tom&quot;: &quot;112235&quot;, &quot;xiaoming&quot;: &quot;464323&quot;&#125;b = &#123;&quot;tony&quot;: &quot;156735&quot;, &quot;xiaowang&quot;: &quot;476587&quot;&#125;c = &#123;**a, **b&#125; 这里的两个 * 代表 Python 中的解包（unpacking），这里的 **a 和 **b 相当于将字典中的 a 和 b 中的内容直接填写到了这里。 三元运算符 在 Python 中我们常会用到下面的操作：根据某个条件的不同，将不同变量设置成不同的值 1234if score &gt; 60: s = &#x27;pass&#x27;else: s = &#x27;fail&#x27; 而我们使用三元运算符可以直接改为这样： 1s = &#x27;pass&#x27; if score &gt; 60 else &#x27;fail&#x27; 序列解包 假如我们需要将一个字符串通过空格分割得到多个字符串，我们可以采用下面的方法： 12345name = &#x27;San Zhang&#x27;str_list = name.split()first_name = str_list[0]last_name = str_list[1] 如果使用Python中的序列解包的方式，我们可以直接采用下面的方法： 12name = &#x27;San Zhang&#x27;first_name, last_name = name.split() 这里被解包的序列不一定是列表，也可以是元组，甚至是 range. With 语句 在 Python 中，我们可以通过 open 语句打开一个文件，但在打开使用后，我们要即时调用 close 函数，如果不关闭文件，程序将会一直调用文件进程直到程序退出为止： 123f = open(&#x27;test.txt&#x27;, &#x27;r&#x27;)s = f.read()f.close() 使用Python中的with语句可以避免程序员忘记调用close语句，它可以在文件调用完，自动关闭。 12with open(&#x27;test.txt&#x27;, &#x27;r&#x27;) as f: s = f.read() 参考视频：B站 奇乐编程学院","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://ckblogs.cn/tags/Python/"},{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"数据结构（上） —— 线性表、栈、队列、串","slug":"数据结构","date":"2022-01-12T03:00:00.000Z","updated":"2022-02-16T09:04:27.976Z","comments":true,"path":"2022/01/12/数据结构/","link":"","permalink":"http://ckblogs.cn/2022/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构（上) —— 线性表、栈、队列、串 当我开始这篇博客的书写时，我将知道，这是一个艰难而且繁杂的过程。一向追求实际作用的我，在学习数据分析、网络爬虫乃至自动化和前端UI等更能看得见摸得着的东西时，更能保持我的积极性和专注力。而以数据结构为代表的算法，始终无法让我静下心来，慢慢研究。我知道，算法的背后是数学，而要想让自己的编程技术上一个台阶，学习算法是必不可少的。这篇博客以程杰老师的《大话数据结构》为依托，写下我对相关数据结构的总结和学习笔记。希望对您和我都有十足的帮助。 CK出品，必属精品！ [TOC] 数据结构概述 程序设计 = 数据结构 + 算法 基本概念和术语 数据： 描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据不仅仅包括整型、实型等数值类型，还包括字符以及声音、图像、视频等非数值类型。 数据元素： 是组成数据的、有一定意义的基本单位，再计算机中通常作为整体处理。也被称为记录。 数据项： 一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象： 是性质相同的数据元素的集合，是数据的子集。 数据结构： 是相互之间存在一种或多种特定关系的数据元素的集合。 抽象数据类型（Absrtract Data Type）： 是指一个数学模型及定义 123456789101112ADT 抽象数据结构Data 数据元素之间的逻辑关系定义Operation 操作1 初始条件 操作结果描述 操作2 ... 操作3 ...endADT 线性表 线性表的抽象数据类型定义如下： 12345678910111213ADT 线性表（List）Data 线性表的数据对象集合是&#123;a, b, c, ...&#125;，每个元素的类型均为 DataType。其中，除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后驱元素。数据元素之间的关系是一对一的。Operation InitList(*L): 初始化操作，建立一个线性表L。 ListEmpty(L): 若线性表为空，返回 true，否则返回 false。 ClearList(*L): 将线性表清空。 GetElem(L, i, *e): 将线性表L中的第 i 个元素值返回给 e。 LocateElem(*L, e): 查找线性表中与 e 相同的元素,返回其序号,若不存在则返回 0. Listinsert(*L, i, e): 将 e 元素插入到 L 中的第 i 个位置. ListDelete(*L, i, *e): 删除线性表 L 中的第 i 个位置元素, 并将其值返回给 e. ListLength(L): 返回 L 中的元素个数.endADT 线性表的顺序存储结构 (SqList) 在算法的代码实现之前，首先声明展示这些定义和重命名，能够让我们的代码的可读性进一步提高： 12345678#define MAXSIZE 20#define OK 1#define ERROR 0#define TRUE 1#define False 0typedef int ElemType;typedef int Status; 在 C语言中，存储线性表的顺序存储结构是数组，所以可以定义下面的顺序存储结构代码： 12345typedef int ElemType;typedef struct &#123; ElemType data[MAXSIZE]; int length;&#125;SqLsit; 获取元素操作 1234567891011// 获得数据元素Status GetElem(SqList L, int pos, ElemType* e)&#123; // 如果获取元素的位置小于 1 或者大于线性表长度，则返回错误 if(pos &lt; 1 || pos &gt; L.length)&#123; return ERROR; &#125;else&#123; // 将第 pos - 1个元素赋给 e *e = L.data[pos - 1]; return OK; &#125;&#125; 插入元素操作 123456789101112131415161718// 插入元素操作Status ListInsert(SqList * L, int pos, ElemType e)&#123; // 如果插入元素的位置小于 1 或者大于线性表的长度 或者线性表的长度为 MAXSIZE，则返回错误 if(pos &lt; 1 || pos &gt; L-&gt;length+1 || L-&gt;length == MAXSIZE)&#123; return ERROR; &#125; // 若插入元素不在表尾 else if(pos &lt;= L-&gt;length)&#123; // 将线性表中从 length-1 到 pos-1 全部向后移动一位 for (int i = L-&gt;length-1; i &gt;= pos-1 ; --i) &#123; L-&gt;data[i+1] = L-&gt;data[i]; &#125; &#125; // 将元素 e 赋给线性表中的 pos-1 L-&gt;data[pos-1] = e; L-&gt;length ++; return OK;&#125; 删除元素操作 123456789101112131415161718// 删除元素操作Status ListDelete(SqList * L, int pos, ElemType* e)&#123; // 如何删除元素的位置小于 1 或者大于线性表长度，返回错误 if(pos &lt; 1 || pos &gt; L-&gt;length)&#123; return ERROR; &#125; // 将第 pos-1 个元素赋值给 e *e = L-&gt;data[pos-1]; // 如果不是删除最后一个元素 if(pos &lt; L-&gt;length)&#123; // 将第 pos 到第 length-1 元素向前移动一位 for (int i = pos; i &lt; L-&gt;length; ++i) &#123; L-&gt;data[i-1] = L-&gt;data[i]; &#125; &#125; L-&gt;length --; return OK;&#125; 线性表的链式存储结构(LinkList) n个结点链结成一个链表，即为线性表的链式存储结构，因为链表的每个结点中只包含一个指针域，所以叫做单链表。 单链表的第一个结点的存储位置叫做头指针，那么整个链表的存取就必须从头指针开始进行了。最后一个链表的结点指针域为空。 有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，或者有时也可以存储如线性表的长度等附加信息。 头指针和头结点的异同： 头指针： 是指向链表第一个结点的指针，若链表有头结点，头指针指向头结点。 头指针具有标识作用，所以常用头指针冠以链表的名字 无论链表是否为空，头指针均不为空。头指针是链表的必要元素 头结点： 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度） 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了 头结点不一定是链表必须要素 综上，带有头结点的单链表可以用下图表示： 而空的单链表可以用下图所示： 1234typedef struct Node&#123; ElemType data; struct Node* next;&#125;Node; 读取元素操作 12345678910111213141516Status GetElem(LinkList L, int pos, ElemType* e)&#123; // 定义计数器和遍历指针 int j = 1; LinkList p = L -&gt; next; // 当 p 不为空并且 j &lt; i 时工作指针后移 while(p &amp;&amp; j &lt; i)&#123; p = p-&gt;next; j++; &#125; // 如果 p 为空，则返回ERROR if(!p) return ERROR; *e = p-&gt;data; return OK;&#125; 插入元素操作 若想将 s 结点插入到 p 结点和 p-&gt;next 结点之间，只需要将 p-&gt;next 和 s-&gt;next 做一点改变即可。即做出如下操作： 12s-&gt;next = p-&gt;next;p-&gt;next = s; 注意：这两句代码不可交换位置 对于单链表的表头和表尾的特殊情况，操作是相同的： 12345678910111213141516171819// 单链表元素的插入Status ListInsert(LinkList *L, int pos, ElemType e)&#123; // 定义计数器和工作指针 int j = 1; LinkList p = *HL; // 遍历，寻找目标位置的前一个结点 while(p &amp;&amp; j &lt; pos)&#123; p = p-&gt;next; j++; &#125; // 如果 p 不存在，返回 ERROR if (!p) return ERROR; LinkList s = (LinkList) malloc(sizeof(Node)); s-&gt;data = e; s-&gt;next = p-&gt;data; p-&gt;next = s; return OK;&#125; 删除元素操作 若想将 q 结点删除，只需要将 p-&gt;next 做一点改变即可。即做出如下操作： 123q = p-&gt;next;p-&gt;next = q-&gt;next;free(q); 注意：这两句代码不可交换位置 12345678910111213141516171819Status ListDelete(LinkList * L, int pos, ElemType* e)&#123; // 定义计数器和工作指针 int j = 1; LinkList p = *L; // 遍历到目标位置的前一个结点 while (p &amp;&amp; j &lt; pos)&#123; p = p-&gt;next; j++; &#125; if(!p)&#123; return ERROR; &#125; // 删除p的下一个元素 LinkList q = p-&gt;next; p-&gt;next = q-&gt;next; *e = q-&gt;data; free(q); return OK;&#125; 单链表的整表创建 整表创建的算法思路： 声明一结点 p 和计数器变量 i； 初始化一空链表； 让 L 的头结点指针指向 NULL，即建立一个带头结点的空链表； 循环： 头插法： 12345678910111213141516// 头插法创建一个空列表void CreateListHead(LinkList *L, int n) &#123; LinkList p; srand(time(0)); // 初始化头结点 *L = (LinkList) malloc(sizeof(Node)); (*L)-&gt;next = NULL; for (int i = 0; i &lt; n; ++i) &#123; // 生成新结点 p = (LinkList) malloc(sizeof (Node)); p-&gt;data = rand()%100 +1; // 插入到头结点后 p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; &#125;&#125; 尾插法： 123456789101112131415161718// 尾插法创建一个空列表void CreateListTail(LinkList *L, int n)&#123; LinkList p,r; srand(time(0)); // 初始化头结点 *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL; // r 为指向尾部的结点 r = *L; for (int i = 0; i &lt; n; ++i) &#123; // 生成新结点 p = (LinkList) malloc(sizeof (Node)); p-&gt;data = rand()%100 +1; r-&gt;next = p; r = p; &#125; r -&gt; next = NULL;&#125; 单链表的整表删除 12345678910111213Status ClearList(LinkList * L)&#123; LinkList p,q; // p指向第一个结点 p = (*L) -&gt; next; while (p) &#123; q = p-&gt;next; free(p); p = q; &#125; (*L)-&gt;next = NULL; return OK;&#125; 线性表的其他存储结构 静态链表 用数组描述的链表叫做静态链表 1234567#define MAXSIZE 1000typedef int ElemType;typedef struct&#123; ElemType data; int cur; // 游标（Cursor）&#125;Component, StaticLinkList[MAXSIZE]; 双向链表 **双向链表( double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。**所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 12345typedef struct DulNode&#123; ElemType data; struct DulNode* prior; struct DulNode* next;&#125;DulNode, *DuLinkList; 双向链表在插入和删除的过程中，需要额外指定一个指针变量 插入操作： 1234s-&gt;perior = p;s-&gt;next = p-&gt;next;p-&gt;next-&gt;perior = s;p-&gt;next = s; s插入顺序的关键在于先解决 s 在解决 s-&gt;next的前驱，最后解决 s-&gt;perior 的后继。 删除操作： 123p-&gt;prior-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior;free(p); 循环列表 合并循环列表： 要想实现合并操作，只需要进行下面的步骤就可以了： 12345p = rearA-&gt;next;q = rearB-&gt;next;raarA-&gt;next = q-&gt;next;rearB-&gt;next = p;free(q); 栈 **栈( stack)是限定仅在表尾进行插入和删除操作的线性表。**我们把允许插入和删除的一端称为栈顶(top),另一端称为栈底( bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出( Last In First Out)的线性表，简称LIFO结构。 栈的抽象数据类型定义如下： 12345678910111213ADT 栈（stack）Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。Operation InitStack(*S): 初始化操作，建立一个空栈S。 DestroyStack(*S): 若栈存在，则销毁它。 ClearStack(*S): 将栈清空。 StackEmpty(S): 栈为空则返回 true， 否则返回 false。 GetTop(S,*e): 返回栈的栈顶元素 e。 Push(*S, e): 插入元素 e 到栈顶。 Pop(*S, *e): 弹出栈顶元素，并用 e 返回其值。 StckLength(L): 返回 S 中的元素个数。endADT 栈的顺序存储结构及其实现 1234typedef struct &#123; ElemType data[MAXSIZE]; int top;&#125;SqStack; 进栈操作 1234567891011// 将元素 e 插入栈中 ———— 进栈Status Push(SqStack * S, ElemType e)&#123; // 如果栈满，返回 Error if(S-&gt;top == MAXSIZE - 1)&#123; return ERROR; &#125; // 将 top ++，并将 top + 1赋值 S-&gt;top++; S-&gt;data[S-&gt;top] = e; return OK;&#125; 出栈操作 123456789Status Pop(SqStack *S, ElemType *e)&#123; if(S-&gt;top == -1)&#123; return ERROR; &#125; // 将栈顶元素返回值给e，然后top-- *e = S-&gt;data[S-&gt;top]; S-&gt;top--; return OK;&#125; 栈的复用 采用如图所示的方式，两栈各自向中间靠拢： 存储结构： 12345typedef struct &#123; ElemType data[MAXSIZE]; int top1; int top2;&#125;SqDoubleStack; 插入元素： 1234567891011121314Status Push(SqDoubleStack *S, ElemType e, int StackNumber)&#123; // 如果 top1 + 1 == top2 说明栈满 if(S-&gt;top1 == S-&gt;top2 + 1)&#123; return ERROR; &#125; if(StackNumber==1)&#123; S-&gt;top1++; S-&gt;data[S-&gt;top1] = e; &#125;else if(StackNumber == 2)&#123; S-&gt;top2--; S-&gt;data[S-&gt;top2] = e; &#125; return OK;&#125; 删除元素： 123456789101112131415161718Status Pup(SqDoubleStack *S, ElemType *e, int StackNumber)&#123; if(StackNumber==1)&#123; // 如果 top1 == 0 说明栈空 if(S-&gt;top1 == -1)&#123; return ERROR; &#125; *e = S-&gt;data[S-&gt;top1]; S-&gt;top1--; &#125;else if(StackNumber == 2)&#123; // 如果 top2 == MAXSIZE 说明栈空 if(S-&gt;top1 == MAXSIZE)&#123; return ERROR; &#125; *e = S-&gt;data[S-&gt;top2]; S-&gt;top2++; &#125; return OK;&#125; 栈的链式存储结构及其实现 链栈的结构代码： 123456789typedef struct StackNode&#123; ElemType data; struct StackNode* next;&#125;StackNode, *LinkStackPtr;typedef struct LinkStack&#123; LinkStackPtr top; int count&#125;LinkStack; 进栈操作 12345678Status Push(LinkStack * S, ElemType e)&#123; LinkStackPtr s = (LinkStackPtr) malloc(sizeof(StackNode)); s-&gt;data = e; s-&gt;next = S-&gt;top; S-&gt;top = s; S-&gt;count++; return OK;&#125; 出栈操作 1234567891011Status Pop(LinkStack* S, ElemType*e)&#123; if(S-&gt;count == 0)&#123; return ERROR; &#125; LinkStackPtr p = S-&gt;top; *e = p-&gt;data; S-&gt;top = p-&gt;next; free(p); S-&gt;count --; return OK;&#125; 队列 **队列( queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。**队列是一种先进先出( First In First Out)的线性表，简称FIFO。允许插入的端称为队尾，允许删除的一端称为队头。 12345678910111213ADT队列( Queue)Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation Initqueue(*Q):初始化操作，建立一个空队列Q Destroyqueue(*Q):若队列Q存在，则销毁它。 Clearqueue(E*Q):将队列Q清空。 QueueEmpty(Q):若队列Q为空，返回true,否则返回false。 GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素。 Enqueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素。 Dequeue(*Q,*e):删除队列Q中队头元素，并用e返回其值。 Queuelength(Q):返回队列Q的元素个数endadt 队列的顺序存储结构 循环队列 存储结构代码： 12345typedef struct &#123; ElemType data[MAXSIZE]; int front; // 头指针 int rear; // 尾指针，指向队尾的下一个元素&#125;SqQueue; 循环队列的初始化 12345Status InitQueue(SqQueue* Q)&#123; Q-&gt;front = 0; Q-&gt;rear = 0; return OK;&#125; 判断队列是否满 在判断是否已经满了的时候可以采用两种办法： 空队列时， front等于rear,现在当队列满时，也是 front等于rear,那么如何判断此时的队列究竟是空还是满呢？ 办法一是设置一个标志变量 tag ,当font==rear,且tag=0时为队列空，当font==rear,且tag=1时为队列满 办法二是当队列空时，条件就是 front=rear,当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 在方法二中： 可能会遇见上图中的两种情况，则判断队列是否为满的条件是：(rear+1)%MAXSIZE == front 求队列的长度 1234// 求循环队列的长度int QueueLength(SqQueue Q)&#123; return (Q.rear - Q.front + MAXSIZE)%MAXSIZE;&#125; 入队 1234567891011// 入队Status EnQueue(SqQueue* Q, ElemType e)&#123; // 如果队满返回 ERROR if((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)&#123; return ERROR; &#125; Q-&gt;data[Q-&gt;rear] = e; // 尾指针向后移动一位 Q-&gt;rear = (Q-&gt;rear+1)%MAXSIZE; return OK;&#125; 出队 1234567891011// 出队Status DeQueue(SqQueue *Q, ElemType* e)&#123; // 如果队空，返回 ERROR if(Q-&gt;front == Q-&gt;rear)&#123; return ERROR; &#125; *e = Q-&gt;data[Q-&gt;front]; // 头指针向后移动一位 Q-&gt;front = (Q-&gt;front + 1)% MAXSIZE; return OK;&#125; 队列的链式存储结构 队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。 存储结构代码： 12345678typedef struct QNode&#123; ElemType data; struct QNode* next;&#125;QNode, *QueuePtr;typedef struct &#123; QueuePtr front, rear;&#125;LinkQueue; 入队操作 12345678910Status EnQueue(LinkQueue *Q, ElemType e)&#123; // 创建 s 结点 QueuePtr s = (QueuePtr) malloc(sizeof(QNode)); s-&gt;data = e; s-&gt;next = NULL; // 将尾结点连上 s 结点，并将尾结点向后移动一位 Q-&gt;rear-&gt;next = s; Q-&gt;rear = s; return OK;&#125; 出队操作 12345678910111213141516Status DeQueue(LinkQueue* Q, ElemType* e)&#123; // 判断是否为空 if(Q-&gt;rear == Q-&gt;front)&#123; return ERROR; &#125; // 1. 获取第一个元素结点 2. 赋值给 e 3. 将头结点连上第二个结点 4. 释放原第一元素结点空间 QueuePtr p = Q-&gt;front-&gt;next; *e = p-&gt;data; Q-&gt;front-&gt;next = p-&gt;next; // 若队头是队尾，删除后，将队尾指向头结点，见上图 if(p == Q-&gt;rear)&#123; Q-&gt;rear = Q-&gt;front; &#125; free(p); return OK;&#125; 串 串( string)是由零个或多个字符组成的有限序列，又名叫字符串。 串的抽象数据类型： 1234567891011121314151617ADT 串(string)Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。Operation StrAssign(T,* chars):生成一个其值等于字符串常量 chars的串T。 StrCopy(T,S):串S存在，由串S复制得串T。 ClearString(S):串S存在，将串清空。 StringEmpty(S):若串S为空，返回true,否则返回 false。 StrLength(S):返回串S的元素个数，即串的长度。 StrCompare(S,T):若S&gt;T,返回值&gt;0,若S=T,返回0,若S&lt;m,返回值&lt;0。 Concat(T,S1,S2):用T返回由S1和S2联接而成的新串。 Substring(Sub,S,pos,len):串S存在，用Sub返回串S的第pos个字符起长度为1en的子串。 Index(S,T,pos):串S和T存在，T是非空串，若主串S中存在和串值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。 Replace(S,T,V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。 StrInsert(S,pos,T):串S和T存在，在串S的第pos个字符之前插入串T。 StrDelete(s,pos,len):串S存在，从串S中删除第pos个字符起长度为1en的子串。ENDADT 串的比较 串的比较 给定两个串: s= a1 a2⋯⋯ a ns= \\ {a}_{1} \\ {a}_{2} \\cdots \\cdots \\ {a}_{\\ {n}}s= a1​ a2​⋯⋯ a n​ , t=b 1 b 2⋯⋯ b m\\ {t}= {b}_{\\ {1}} \\ {b}_{\\ {2}} \\cdots \\cdots \\ {b}_{\\ {m}} t=b 1​ b 2​⋯⋯ b m​ , 当满足以下条件之一时, s&lt; t\\ {s}&lt;\\ {t} s&lt; t 。 n&lt; m\\ {n}&lt;\\ {m} n&lt; m, 且 a i= b i( i= 1,2,⋯⋯ , n)\\ {a}_{\\ {i}}=\\ {b}_{\\ {i}}(\\ {i}=\\ {1}, 2, \\cdots \\cdots, \\ {n}) a i​= b i​( i= 1,2,⋯⋯, n) 。 例如当 s=s=s= “hap&quot;, t=t=t= “happy”, 就有 s&lt;ts&lt;ts&lt;t 。因为 ttt 比 sss 多出了两个字母。 存在某个 k⩽ min( m, n)\\ {k} \\leqslant \\ {m i n}(\\ {m}, \\ {n}) k⩽ min( m, n), 使得 a i= b i\\ {a}_{\\ {i}}=\\ {b}_{\\ {i}} a i​= b i​ （ i= 1,2,⋯⋯ , k− 1\\ {i}=\\ {1}, 2, \\cdots \\cdots, \\ {k}-\\ {1} i= 1,2,⋯⋯, k− 1 ), a k&lt; b k\\ {a}_{\\ {k}}&lt;\\ {b}_{\\ {k}} a k​&lt; b k​ 。 例如当 s=s=s= “happen”, t=t=t= “happy”, 因为两串的前 4 个字母均相同, 而两串第 5 个字母 ( k\\mathrm{k}k 值), 字母 e\\mathrm{e}e 的 ASCII 码是 101, 而字母 y\\mathrm{y}y 的 ASCII 码是 121, 显然 e&lt;y\\mathrm{e}&lt;\\mathrm{y}e&lt;y, 所以 s&lt;t\\mathrm{s}&lt;\\mathrm{t}s&lt;t 。 只有当两个串的长度和它们各个位置对应的字符都相等时，才算相等。 串的顺序存储结构 1234typedef struct&#123; char str[MAXSIZE]; int len;&#125;SqString; 串的链式存储结构 1234typedef struct Node&#123; char data; struct Node* next;&#125;SNode;","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法 - C语言","slug":"算法-C语言","permalink":"http://ckblogs.cn/tags/%E7%AE%97%E6%B3%95-C%E8%AF%AD%E8%A8%80/"}]},{"title":"Verilog 学习使用实验技术报告","slug":"Verilog 学习使用实验技术报告","date":"2021-12-14T04:00:00.000Z","updated":"2022-01-13T00:41:57.324Z","comments":true,"path":"2021/12/14/Verilog 学习使用实验技术报告/","link":"","permalink":"http://ckblogs.cn/2021/12/14/Verilog%20%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/","excerpt":"","text":"Verilog 学习使用实验技术报告 Verilog 是一个硬件语言，说实话，我真的很不喜欢这门语言。无奈要学，身不由己！ [TOC] 24 译码器 模块： 12345678910111213141516module Vr2to4dec(A0, A1, EN, Y0, Y1, Y2, Y3); input A0, A1, EN; output reg Y0, Y1, Y2, Y3; always @ (A0, A1, EN) if (EN == 1) &#123;Y3, Y2, Y1, Y0&#125; = 4&#x27;b0000; else case(&#123;A0, A1&#125;) 2&#x27;b00: &#123;Y3, Y2, Y1, Y0&#125; = 4&#x27;b0001; 2&#x27;b01: &#123;Y3, Y2, Y1, Y0&#125; = 4&#x27;b0010; 2&#x27;b10: &#123;Y3, Y2, Y1, Y0&#125; = 4&#x27;b0100; 2&#x27;b11: &#123;Y3, Y2, Y1, Y0&#125; = 4&#x27;b1000; default: &#123;Y3, Y2, Y1, Y0&#125; = 4&#x27;b0000; endcaseendmodule RTL: 波形测试： 8输入优先编码器 模块： 1234567891011121314151617module Vr8inprior(I, A, IDLE); input [7:0] I; output reg [2:0] A; output reg IDLE; integer j; always @(*) begin IDLE = 1; A = 0; for(j = 0; j &lt;= 7; j = j + 1) if(I[j] == 1) begin IDLE = 0; end endendmodule 模块： 波形仿真： 奇偶效验电路 模块： 1234567891011121314module Vrparity9(I, ODD);input [1:9] I;output reg ODD;integer j;always @ (*) begin ODD = 1&#x27;b0; for(j = 1; j &lt;= 9; j = j + 1) if (I[j]) ODD = ~ODD; endendmodule RTL： 波形仿真： 八位数值比较器 模块： 12345678910111213141516171819202122232425262728293031module Vr8bitcmp(P, Q, PGTQ, PEQQ, PLTQ); input [7:0] P, Q; output reg PGTQ, PEQQ, PLTQ; always @ (*) if(P == Q) begin PGTQ = 1&#x27;b0; PEQQ = 1&#x27;b1; PLTQ = 1&#x27;b0; end else if(P &gt; Q) begin PGTQ = 1&#x27;b1; PEQQ = 1&#x27;b0; PLTQ = 1&#x27;b0; end else if(P &lt; Q) begin PGTQ = 1&#x27;b0; PEQQ = 1&#x27;b0; PLTQ = 1&#x27;b1; end else begin PGTQ = 1&#x27;bx; PEQQ = 1&#x27;bx; PLTQ = 1&#x27;bx; endendmodule RTL： 波形仿真： 加法器 模块： 123456789module VrNbitadder(A, B, CIN, S, COUT); parameter N = 16; // 加数与和的宽度 input [N-1:0] A, B; input CIN; output [N-1:0] S; output COUT; assign &#123;COUT, S&#125; = A + B + CIN;endmodule RTL： 部分波形仿真： 带异步清零和门使能的D锁存器模型 模块： 12345678910111213141516module VrDff(CLK, CLR, D, Q, QN); input CLK, CLR, D; output reg Q, QN; always @ (posedge CLK or posedge CLR) if (CLR == 1) begin Q &lt;= 0; QN &lt;= 1; end else begin Q &lt;= D; QN &lt;= ~Q; endendmodule RTL： 波形仿真： 四位二进制计数器 P424 模块： 12345678910111213141516171819202122module Vrcntr4u(CLK, CLR, LD, ENP, ENT, D, Q, RCO); input CLK, CLR, LD, ENP, ENT; input [3:0] D; output reg [3:0] Q; output reg RCO; always @ (posedge CLK) if(CLR == 1) Q &lt;= 4&#x27;d0; else if(LD == 1) Q &lt;= D; else if ((ENT == 1) &amp;&amp; (ENP == 1)) Q &lt;= Q+1; else Q &lt;= Q; always @ (Q or ENT) if ((ENT == 1) &amp;&amp; (Q == 4&#x27;b1111)) RCO = 1; else RCO = 0;endmodule RTL： 波形仿真： 通用四位移位寄存器 P436 模块： 123456789101112131415161718module Vrshrg4u(CLK, CLR, RIN, LIN, S0, S1, A, B, C, D, QA, QB, QC, QD); input CLK, CLR, RIN, LIN, S0, S1, A, B, C, D; output reg QA, QB, QC, QD; always @ (posedge CLK) begin if (CLR == 1) &#123;QA, QB, QC, QD&#125; &lt;= 4&#x27;b0; else case(&#123;S1, S0&#125;) 2&#x27;b00: ; // 保持 2&#x27;b01: &#123;QA, QB, QC, QD&#125; &lt;= &#123;RIN, QA, QB, QC&#125;; //右移 2&#x27;b10: &#123;QA, QB, QC, QD&#125; &lt;= &#123;QB, QC, QD, LIN&#125;; //左移 2&#x27;b11: &#123;QA, QB, QC, QD&#125; &lt;= &#123;A, B, C, D&#125;; //送数 endcase endendmodule RTL： 波形仿真：","categories":[{"name":"其他","slug":"其他","permalink":"http://ckblogs.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Verilog","slug":"Verilog","permalink":"http://ckblogs.cn/tags/Verilog/"},{"name":"硬件语言 - 实验","slug":"硬件语言-实验","permalink":"http://ckblogs.cn/tags/%E7%A1%AC%E4%BB%B6%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C/"}]},{"title":"信号与系统 Matlab 实验和部分内容解析","slug":"信号与系统大作业","date":"2021-12-14T03:00:00.000Z","updated":"2022-01-13T00:42:08.228Z","comments":true,"path":"2021/12/14/信号与系统大作业/","link":"","permalink":"http://ckblogs.cn/2021/12/14/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%A4%A7%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"信号与系统 Matlab 实验和部分内容解析 此内容为信号与系统课程课内大作业 一、Matlab 实验 1. 实验目的 学会用MATLAB画连续离散系统零极点图； 学会用MATLAB分析连续、离散系统的频率特性； 画出系统的幅频特性曲线 画出系统的相频特性曲线 2. 实验原理 连续系统 sys = tf(num, den) : 传递函数， num 是系统分子向量， den 是系统分母向量 求系统零点极点图： 调用函数 pzmap(sys) 画出系统的零点极点图 求系统的幅频特性，并画出系统的幅频特性曲线和相频特性曲线： 调用函数h = freqs(num, den, w) 根据系数向量计算返回模拟滤波器的复频域响应。freqs 计算在复平面虚轴上的频率响应h，角频率w确定了输入的实向量，因此必须包含至少一个频率点。 离散系统 [z, p, k] = tf2zp(B, A) B 是系统分子向量，A 是系统分母向量， z, p, k 分别是零点、极点和增益 求系统零点极点图： 调用函数 zplane(B, A) 画出系统的零点极点图 求系统的幅频特性，并画出系统的幅频特性曲线和相频特性曲线： 调用函数h = freqz(num, den, w) 根据系数向量计算返回模拟滤波器的复频域响应。freqs 计算在复平面虚轴上的频率响应h，角频率w确定了输入的实向量，因此必须包含至少一个频率点。 3. 实验内容 分别求下面两个函数的零点极点图、幅频特性曲线和相频特性曲线 连续系统：H(s)=0.2s2+0.3s+1s2+0.4+1H(s) = \\cfrac{0.2s^2 + 0.3s+1}{s^2 + 0.4+1}H(s)=s2+0.4+10.2s2+0.3s+1​ 离散系统：H(z)=z−0.5zH(z) = \\cfrac{z-0.5}{z}H(z)=zz−0.5​ 实验源代码： 连续系统： 12345678910% 连续系统clc;clear;a = [1 0.4 1]; % 分母向量b = [0.2 0.3 1]; % 分子向量% logspace 功能：生成从10的a次方到10的b次方之间按对数等分的n个元素的行向量。n如果省略，则默认值为50。w = logspace(-1, 1);sys = tf(b, a); %系统函数figure(1); pzmap(sys); % 画出零点极点图figure(2);freqs(b, a, w);% 画出幅频特性曲线和相频特性曲线 离散系统： 123456789% 离散系统clc;clear;a = [1, 0]; % 分母系数向量b = [1, 0.5]; % 分子系数向量% 求系统零点极点图figure(1);zplane(b, a); % 求系统幅频特性曲线和相频特性曲线figure(2);freqz(b, a, 400); 4. 实验结果 （1) 连续系统：H(s)=0.2s2+0.3s+1s2+0.4+1H(s) = \\cfrac{0.2s^2 + 0.3s+1}{s^2 + 0.4+1}H(s)=s2+0.4+10.2s2+0.3s+1​ 零点极点图： 幅频、相频特性曲线： (2) 离散系统：H(z)=z−0.5zH(z) = \\cfrac{z-0.5}{z}H(z)=zz−0.5​ 零点极点图： 幅频、相频特性曲线： 二、疑难点总结 1. 系统线性、时不变性的判定 统一判定公式： 判定线性系统条件： T[ax1(t)+bx2(t)]=?T[ax1(t)]+T[bx2(t)]T[ax_1(t)+bx_2(t)] \\overset{?}{=} T[ax_1(t)] + T[bx_2(t)] T[ax1​(t)+bx2​(t)]=?T[ax1​(t)]+T[bx2​(t)] 判定时不变系统条件： T[x(t−t0)]=?y(t−t0)T[x(t-t_0)] \\overset{?}{=} y(t-t_0) T[x(t−t0​)]=?y(t−t0​) 例：判定 $y(t) = x(t)^2 $是否为线性系统 解： 根据线性系统的判定条件： T[ax1(t)+bx2(t)]=[ax1(t)+bx2(t)]2T[ax_1(t) + bx_2(t)] = [ax_1(t)+bx_2(t)]^2 T[ax1​(t)+bx2​(t)]=[ax1​(t)+bx2​(t)]2 即：将原式中的 x(t)x(t)x(t) 由 ax1(t)+bx2(t)ax_1(t) + bx_2(t)ax1​(t)+bx2​(t) 所代替 T[ax1(t)]+T[bx2(t)]=[ax1(t)]2+[bx2(t)]2T[ax_1(t)] + T[bx_2(t)] = [ax_1(t)]^2+[bx_2(t)]^2 T[ax1​(t)]+T[bx2​(t)]=[ax1​(t)]2+[bx2​(t)]2 二者并不相等，因此此系统为非线性系统。 例：判定 y(t)=cos(wt)x(t)y(t) = cos(wt)x(t)y(t)=cos(wt)x(t) 是否为时不变系统 解： 根据时不变系统的判定条件： T[x(t−t0)]=cos(wt)x(t−t0)y(t−t0)=cos[w(t−t0)]x(t−t0)T[x(t-t_0)] = cos(wt)x(t-t_0)\\\\ y(t-t_0) = cos[w(t-t_0)]x(t-t_0) T[x(t−t0​)]=cos(wt)x(t−t0​)y(t−t0​)=cos[w(t−t0​)]x(t−t0​) 二者并不相等，因此此系统为时变系统。 2. 流程图写出传递函数 三种基本变换： 串联 ϕ(s)=G1(s)G2(s)\\phi(s) = G_1(s)G_2(s) ϕ(s)=G1​(s)G2​(s) 并联 ϕ(s)=G1(s)+G2(s)\\phi(s) = G_1(s)+G_2(s) ϕ(s)=G1​(s)+G2​(s) 反馈 ϕ(s)=G1(s)1±G2(s)\\phi(s) = \\cfrac{G_1(s)}{1\\pm G_2(s)} ϕ(s)=1±G2​(s)G1​(s)​ 梅森公式： ϕ(s)=∑PkΔkΔ\\phi(s)=\\frac{\\sum P_{k} \\Delta_{k}}{\\Delta} ϕ(s)=Δ∑Pk​Δk​​ Δ\\DeltaΔ : 特征式 Δ=1−∑Li+∑LiLj−∑LiLjLk+⋯\\Delta=1-\\sum L_{i}+\\sum L_{i} L_{j}-\\sum L_{i} L_{j} L_{k}+\\cdots Δ=1−∑Li​+∑Li​Lj​−∑Li​Lj​Lk​+⋯ ∑Li\\sum L_{i}∑Li​ : 所有两两互不接触的回路增益之和 ∑LiLj\\sum L_{i} L_{j}∑Li​Lj​ : 所有回路 (每个单独的回路) 的回路增益之和 ∑LiLjLk\\sum L_{i} L_{j} L_{k}∑Li​Lj​Lk​ : 所有三二互不接触的回路增益之和 PkP_{k}Pk​ : 从输入节点到输出节点的第 $ K $条前向通路的增益 Δk\\Delta_{k}Δk​ :在 $ \\Delta $ 中，将与第 $ K 条前向通路接触的回路去除后，余下的条前向通路接触的回路去除后，余下的条前向通路接触的回路去除后，余下的 \\Delta $，称作余子式 例： 利用梅森公式对下列流程图进行化简： 系统回路： L1=−G1(s)G2(s)H1(s)L2=−G2(s)G3(s)H2(s)L3=−G1(s)G2(s)G3(s)L4=−G1(s)G4(s)L5=−G4(s)H2(s)L_1 = -G_1(s)G_2(s)H_1(s)\\\\ L_2 = -G_2(s)G_3(s)H_2(s)\\\\ L_3 = -G_1(s)G_2(s)G_3(s)\\\\ L_4 = -G_1(s)G_4(s)\\\\ L_5=-G_4(s)H_2(s) L1​=−G1​(s)G2​(s)H1​(s)L2​=−G2​(s)G3​(s)H2​(s)L3​=−G1​(s)G2​(s)G3​(s)L4​=−G1​(s)G4​(s)L5​=−G4​(s)H2​(s) 无相互不接触的回路，即： ∑LiLj=0\\sum L_iL_j=0 ∑Li​Lj​=0 则，特征式为： Δ=1−∑Li=1+G1(s)G2(s)H1(s)+G2(s)G3(s)H2(s)+G1(s)G2(s)G3(s)+G1(s)G4(s)+G4(s)H2(s)\\Delta = 1-\\sum L_i\\\\ =1+G_1(s)G_2(s)H_1(s)+G_2(s)G_3(s)H_2(s)+G_1(s)G_2(s)G_3(s)+G_1(s)G_4(s)+G_4(s)H_2(s) Δ=1−∑Li​=1+G1​(s)G2​(s)H1​(s)+G2​(s)G3​(s)H2​(s)+G1​(s)G2​(s)G3​(s)+G1​(s)G4​(s)+G4​(s)H2​(s) 前向通路： P1(s)=G1(s)G2(s)G3(s)P2=G1(s)G4(s)P_1(s) = G_1(s)G_2(s)G_3(s) \\\\P_2 = G_1(s)G_4(s) P1​(s)=G1​(s)G2​(s)G3​(s)P2​=G1​(s)G4​(s) 对应的余子式为： Δ1=1Δ2=1\\Delta_1 =1\\\\ \\Delta_2 = 1 Δ1​=1Δ2​=1 则对应的传递函数是： ϕ(s)=∑PkΔkΔ=P1+P2Δ=G1(s)G2(s)G3(s)+G1(s)G4(s)1+G1(s)G2(s)H1(s)+G2(s)G3(s)H2(s)+G1(s)G2(s)G3(s)+G1(s)G4(s)+G4(s)H2(s)\\phi(s)=\\frac{\\sum P_{k} \\Delta_{k}}{\\Delta} = \\cfrac{P_1+P_2}{\\Delta}\\\\ =\\cfrac{G_1(s)G_2(s)G_3(s)+G_1(s)G_4(s)}{1+G_1(s)G_2(s)H_1(s)+G_2(s)G_3(s)H_2(s)+G_1(s)G_2(s)G_3(s)+G_1(s)G_4(s)+G_4(s)H_2(s)} ϕ(s)=Δ∑Pk​Δk​​=ΔP1​+P2​​=1+G1​(s)G2​(s)H1​(s)+G2​(s)G3​(s)H2​(s)+G1​(s)G2​(s)G3​(s)+G1​(s)G4​(s)+G4​(s)H2​(s)G1​(s)G2​(s)G3​(s)+G1​(s)G4​(s)​ 3. 由传递函数画流程图 从例题感悟绘制方法 例1： H(s)=1s+3=Y(s)X(s)H(s)=\\frac{1}{s+3}=\\frac{Y(s)}{X(s)} H(s)=s+31​=X(s)Y(s)​ Let E(s)=sY(s)E(s)=s Y(s) E(s)=sY(s) Then, 1sE(s)=Y(s)E(s)=X(s)−3Y(s)\\begin{gathered} \\cfrac{1}{s} E(s)=Y(s) \\\\ E(s)=X(s)-3 Y(s) \\end{gathered} s1​E(s)=Y(s)E(s)=X(s)−3Y(s)​ 例二： H(s)=1s2+3s+2=Y(s)X(s)H(s)=\\cfrac{1}{s^{2}+3 s+2}=\\cfrac{Y(s)}{X(s)} H(s)=s2+3s+21​=X(s)Y(s)​ (1) Direct-form Let F(s)=sY(s)E(s)=sF(s)=s2Y(s)F(s)=s Y(s) \\\\ E(s)=s F(s)=s^{2} Y(s) F(s)=sY(s)E(s)=sF(s)=s2Y(s) Then, E(s)=X(s)−3F(s)−2Y(s)E(s)=X(s)-3 F(s)-2 Y(s) E(s)=X(s)−3F(s)−2Y(s) 例三： H(s)=2s2+4s−6s2+3s+2H(s)=(1s2+3s+2)(2s2+4s−6)=Y(s)X(s) Let Z(s)=1s2+3s+2X(s)(2s2+4s−6)Z(s)=Y(s)F(s)=sZ(s)E(s)=sF(s)=s2Z(s)Y(s)=(2s2+4s−6)Z(s)=2E(s)+4F(s)−6Z(s)H(s)=\\cfrac{2 s^{2}+4 s-6}{s^{2}+3 s+2} \\\\ H(s)=\\left(\\cfrac{1}{s^{2}+3 s+2}\\right)\\left(2 s^{2}+4 s-6\\right)=\\frac{Y(s)}{X(s)} \\\\ \\text { Let } Z(s)=\\cfrac{1}{s^{2}+3 s+2} X(s) \\\\ \\left(2 s^{2}+4 s-6\\right) Z(s)=Y(s) \\\\ F(s)=s Z(s) E(s)=s F(s)=s^{2} Z(s) \\\\ Y(s)=\\left(2 s^{2}+4 s-6\\right) Z(s) \\\\ =2 E(s)+4 F(s)-6 Z(s) H(s)=s2+3s+22s2+4s−6​H(s)=(s2+3s+21​)(2s2+4s−6)=X(s)Y(s)​ Let Z(s)=s2+3s+21​X(s)(2s2+4s−6)Z(s)=Y(s)F(s)=sZ(s)E(s)=sF(s)=s2Z(s)Y(s)=(2s2+4s−6)Z(s)=2E(s)+4F(s)−6Z(s)","categories":[{"name":"其他","slug":"其他","permalink":"http://ckblogs.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"信号与系统","slug":"信号与系统","permalink":"http://ckblogs.cn/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"MATLAB - 课程作业","slug":"MATLAB-课程作业","permalink":"http://ckblogs.cn/tags/MATLAB-%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"}]},{"title":"Python网络爬虫---虫术（进行中）","slug":"Python网络爬虫-虫术-敬请期待","date":"2021-11-07T09:07:00.000Z","updated":"2021-12-14T12:38:29.597Z","comments":true,"path":"2021/11/07/Python网络爬虫-虫术-敬请期待/","link":"","permalink":"http://ckblogs.cn/2021/11/07/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E8%99%AB%E6%9C%AF-%E6%95%AC%E8%AF%B7%E6%9C%9F%E5%BE%85/","excerpt":"","text":"关于爬虫技术的总结博客是我一直早想写的内容，只不过一直没有时间和精力来确保写一篇高质量的博客，最近恰好做了一个爬虫项目，涉猎了很多内容，想要借此机会赶紧把这个坑给补了，也算是给自己的爬虫做一个Demo和总结。 对爬虫的理解 Python 爬虫或者其他语言的什么爬虫技术，在笔者的理解下，无非是包含了两个内容：一个是请求，一个是解析。其中最重要也是最核心关键的技术就在于对数据内容的请求。而解析过程呢，就是一个需要耐心处理获得数据的过程。 请求过程，是爬虫中最为关键也是最核心的内容。它的基本原理就是模拟浏览器向网页发送数据请求，如果你模拟得够像，并没有被网页后端的反爬技术抓获，你就能够得到网页后端根据你的请求给你的响应信息。当然如果你被识破为爬虫，你当然就会被阻拦而得不到你想要的响应信息。 解析过程，建立在请求信息成功而获得响应信息的基础之上，在这个基础上通过多种技术，处理获得的响应信息，来得到你所特定需要的信息，这个过程叫做解析。常用的解析方法根据你获得的响应信息内容来决定。如果你获得的响应信息是 json 格式，那将很好处理，Python 的字典将对应于这种数据结构，可以直接解析。如果你获得的响应信息是 html 文本格式，你将通过某些模块对特定文本进行处理。常用的模块有： lxml，bs4，re（正则表达式）。笔者通常采用 lxml 利用 xpath 进行对 html 文本内容的解析，稍后我将解释采用这种方式的好处和优势。 爬虫请求过程 作为爬虫技术的核心。数据请求当然是最为重要的一个过程，在 Python 中，通常采用 request 模块来进行对浏览器的模拟发送数据请求。具体对哪个网页发送请求，这由你所爬取的内容是动态网页还是静态网页所决定。如何判断某一网页是动态网页还是静态网页呢？下面我将具体介绍两个例子： 动态网页请求 爬虫目标网页：豆瓣热门电视剧 为了查看网页是静态网页还是动态网页，我们当然第一步是检查，选择查看 Network -&gt; 选择查看 Fetch/XHR （Ajax），并刷新页面，看抓取到的响应信息是否有你所需要的内容，上述具体过程如下所示： 我们可以看到，这个网页的这些具体的电视剧信息，包括电视剧标题，得分和电视剧具体信息 url 都在这个响应信息当中。在Headers 中，我们可以得到这个请求所需要的 Request URL，请求方式：GET，以及响应信息格式：json。 观察请求网址 URL，往往可以获得更多的信息： Request URL: https://movie.douban.com/j/search_subjects?type=tv&amp;tag=热门&amp;sort=recommend&amp;page_limit=20&amp;page_start=0 在 ？后的便是我们可以选择的参数了，其中几个比较重要的是 tag=%E7%83%AD%E9%97%A8 这里后面一串采用 URL 像这样，通过刷新页面在 NetWork 中获得响应内容的网页，我们称作动态网页，动态网页获得的数据响应往往是 json 格式，这个格式的数据信息，我们能够不使用 Python 中的任何模块就能很轻松的解析数据。 进一步选择合适的请求头信息。 至此，我们已经找到了","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://ckblogs.cn/tags/Python/"},{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/tags/%E6%8A%80%E5%B7%A7/"},{"name":"爬虫","slug":"爬虫","permalink":"http://ckblogs.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"国奖采访记录","slug":"国奖采访记录","date":"2021-11-07T08:54:36.000Z","updated":"2022-01-13T00:42:37.107Z","comments":true,"path":"2021/11/07/国奖采访记录/","link":"","permalink":"http://ckblogs.cn/2021/11/07/%E5%9B%BD%E5%A5%96%E9%87%87%E8%AE%BF%E8%AE%B0%E5%BD%95/","excerpt":"","text":"很荣幸能在大二学年获得2021年国家奖学金，下面记录的是学院对国家奖学金获得者的一次采访，也是我自内心发出的一些关于获得国家奖学金的感想吧。我把它整理了一下，作为自己的一篇博客，既是一次回忆，也是对自己接下来生活的一次勉励，就像我在采访中所说的，获得国奖并不是一段旅程的结束，而是一段新的旅程的开始！ 题问：入围国奖需要优异的成绩，而成绩取决于学习习惯。能分享一下你平时学习中的一些好的习惯吗？ 我个人认为，大学的学习方式与高中有很大的不同，而其中最为重要的不同，在于大学的学习更需要个人的自觉性。在课内学习的过程中，上课的认真程度决定了一节课的课堂效率，而课堂效率保证了对课上知识的吸收程度，所以，为了提高课堂知识的吸收效率，每一节课，我争取坐到前几排，针对老师的课堂重点知识点和重点例题，及时记录在笔记本上。除了课堂内，课下的及时巩固也是避免知识遗漏与遗忘的必要行动。另外我觉得除了课内知识外，广泛涉猎自己知识圈外的技术技能，找到自己的兴趣所在，掌握一些能够真正用于自己生活中的技能，更能让我感到点亮一个个技能点的快乐。 提问： 相较同是入围国奖答辩的其他选手，你认为自己最终成功获奖的优势有哪些？ 各位入围答辩的同学都很优秀，他们都有或多或少值得我学习的地方。而我有幸能够最终获奖，我觉得可能最大的优势在于我平时对课外知识的好奇与学习，以及在大一期间有幸参与的一次科研项目。我的专业成绩与各位入围的同学相比起来，是明显不高的，而在平时的学习中，我也避免将自己局限于课内的公式与概念，而是真正去付诸于实践中去。而我也相信真正在实践中，发现问题，解决问题的过程中获得的能力提升比做对几道题要高得多。因此呢，我觉得这样一份对自己未知领域的好奇与追求，是相当重要的。 题问： 当得知自己成功获得国奖时，你当时的心情是怎样的？ 本以为自己获得国奖时，会感到非常的兴奋与激动。但当真正通知到我成功获奖时，却没有我想象中的那样激动，而更多的是一份平静，因为我知道国奖给我带来的不仅是一份荣誉，更是一份责任。国奖的获得不是一段旅程的结束，而是另外一段旅程的开始。 题问： 国奖的奖励很丰厚，你打算怎样分配并使用这些奖金呢？ 拿到国家奖学金后，我首先想到的是自己的家人，没有自己父母包括其他亲人的支持与生活保障，不可能有我现在这样的一个学习环境和学习条件，因此当我拿到这部分奖励后，我将更多用于感恩家人，给家人带来一些礼物，与他们一起分享这样一份喜悦，另外也作为自己人生中第一笔补贴家用的较为大额的财富。 题问： 答辩现场面对评委老师的提问，你如何评价自己的临场发挥？ 在我答辩的过程中，侯老师问了我有关GitHub的相关操作问题，针对这个问题，因为我对GitHub还是比较熟悉的，因此我将所知道的都沉着冷静的回答给老师，也得到了老师的认可。钱老师分别问了我做相关公益项目和科研项目的动机，我也将我真正内心所想与老师分享。可以说，对待评委老师的题问，我比自己原本想象中做的好，可能这得益于自己对自己所做的事情的了解程度，知道自己做了什么，知道自己为什么做。在答辩现场将这些冷静梳理表达出来就好啦。 题问： 对于评委老师们的评价，你认为在接下来的学习生活中，你在哪些方面需要改进与完善？ ​ 要将自己的课内知识学得更扎实，更巩固。“经济基础决定上层建筑”，脚踏实地的学好基础学科，对以后更深入的学习生活肯定是有很大意义的。 题问： 国奖答辩对PPT的质量要求很高，请问你是怎样准备自己的PPT的？你觉得还有那些不足吗？ ​ 我花了一天的时间认真准备自己的PPT，因为在答辩过程中，如何将自己所作所为能够逻辑清晰地表达清楚相当重要，而一个精美的PPT也可以让各位评委和同学更愿意看你的PPT。在做PPT之前，我列了一个思维导图，将自己想要讲的一一列出，并把自己的思维创意全部备注在旁边，在做PPT时，以思维导图为依据，这样就不会做的手足无措。PPT一定是避免大量堆积的文字，而要以图片为主，关键词为辅，再附带合适的BGM。不足也是存在的，因为想讲的内容太多，实在难以取舍，PPT内容过多，为了保证三分钟内完成答辩，语速较快，另外bgm声音较大，或多或少带来一点影响。 题问： 国奖，在大多数眼里，是一笔不菲的奖金，是一条耀眼的简历，是一块搭构自信的积木，是一级攀登巅峰的台阶。然而，国奖的意义绝对不仅如此。请问对你来说，国奖究竟意味着什么？ 首先，国奖是对我上一学年大学生活的认可与鼓励。他让我有更大的动力与热情去面对接下来的学习生活。其次，国奖对我来说也是一份责任，一份监督，它让我时刻提醒自己，作为国奖获得者，不能随便放纵自己，而更要以更严格的要求来要求自己。","categories":[{"name":"感想","slug":"感想","permalink":"http://ckblogs.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"},{"name":"国奖","slug":"国奖","permalink":"http://ckblogs.cn/tags/%E5%9B%BD%E5%A5%96/"}]},{"title":"LaTeX 常用语法格式总结","slug":"LaTeX 常用语法格式总结","date":"2021-09-26T03:00:00.000Z","updated":"2022-02-14T11:38:39.171Z","comments":true,"path":"2021/09/26/LaTeX 常用语法格式总结/","link":"","permalink":"http://ckblogs.cn/2021/09/26/LaTeX%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"LaTeX 常用语法格式总结 [TOC] 作为一名 LaTeX 深度爱好者，却因为常常忘记 LaTex 相关语法而被迫停止写作去浪费一定的时间查询相关内容，但长久以来，我发现自己常常查询的也就是这些常用而难以熟记的语法，现将其总结如下： 本文基于用相关模板时所需的语法，部分修改文章整体格式的内容不收录于此，部分相关内容或以链接形式导出。 列表与计数 列表 enumerate与itemize默认结构 enumerate 默认为带序号列表，itemize 默认为无序号圆点列表，默认使用方法如下所示： 1234567891011% 有序列表基本结构\\begin&#123;enumerate&#125; \\item a \\item b \\item c\\end&#123;enumerate&#125;% 无序列表基本结构\\begin&#123;itemize&#125; \\item a \\item b\\end&#123;itemize&#125; enumerate与itemize自设定结构 有时，我们需要将有序列表前的序号改写为（1）（2）而并非1. 2. 时，或者我们需要将无序列表前的符号改写为 * 而非圆点时，我们将使用下面的自设定结构： 方案一： 12345678910% enumerate宏包支持\\begin&#123;enumerate&#125;[(1)]%在中括号内设定 \\item a \\item b\\end&#123;enumerate&#125;\\begin&#123;enumerate&#125;[I.]%在中括号内设定 \\item a \\item b\\end&#123;enumerate&#125; 方案二： 12345678910% 在每个item后加中括号使用，自由度更高，自动化程度较低\\begin&#123;enumerate&#125; \\item[(2)] a \\item[(3)] b\\end&#123;enumerate&#125;\\begin&#123;itemize&#125; \\item[*] a \\item[!] b\\end&#123;itemize&#125; 方案三： 123456% 此等妙计，只可意会，不可言传\\begin&#123;enumerate&#125; \\renewcommand&#123;\\labelenumi&#125;&#123;[\\theenumi].&#125; \\item a \\item b\\end&#123;enumerate&#125; 列表截距细调请见博客 Latex中enumerate的一些参数设置 计数 LaTeX中自动编号都借助于内部的计数器来完成，包括： 章节：part, chapter, section, subsection, subsubsection, paragraph, subparagraph 编号列表: enumi, enumii, enumiii, enumiv 公式和图表: equation, figure, table 其他: page, footnote, mpfootnote 用\\the接上计数器名称的方式来调用计数器，例如\\thechapter。 常用计数器命令 newcounter{}[] 建立新的计数器 \\newcounter&#123;foo&#125;[counter] 这命令定义一个新的计数器名叫 foo 并将其值初始化为 0。 可选的参数 counter 为另一个计数器，counter 比 foo高一级，每当 counter 的值增加时, foo 计数器就将被复位。 setcounter{}{} 赋给计数器的值 \\setcounter&#123;counter&#125;&#123;value&#125; 这条命令将计数器 counter 的值设置为 value。 例： 12&gt;\\section&#123;AAA&#125;&gt;\\section&#123;BBB&#125; 123&gt;\\setcounter&#123;section&#125;&#123;-1&#125;&gt;\\section&#123;AAA&#125;&gt;\\section&#123;BBB&#125; 其他常用计数器命令见 计数器命令 ​ 另外，修改 section 等样式见 LaTeX使用titlesec宏包改变章节编号形式的方法 图 一张图 123456789% 添加所需宏包\\usepackage&#123;graphicx&#125;\\begin&#123;figure&#125;[H] \\centering \\includegraphics[width=\\textwidth]&#123;&#125;% 文件位置 \\caption&#123;\\centering &#125; % 标题 \\label&#123;&#125; % 标签 \\end&#123;figure&#125; [htbp] 为调整图片排版位置选项，说明如下： [h]当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩的页面不够，这一参数将不起作用。 [t]顶部。将图形放置在页面的顶部。 [b]底部。将图形放置在页面的底部。 [p]浮动页。将图形放置在一只允许有浮动对象的页面上。 这一条中，图片位置为latex自动排版，如若我们一定要指定图片在当前位置，仅使用 [h] 命令是达不到效果的，此时方法如下： a) 引入float宏包; b) 将\\begin&#123;figure&#125;[htbp]改为\\begin&#123;figure&#125;[H]，注意是大写的H。 \\centering 为图片居中命令； \\includegraphics[width=0.5\\textwidth]&#123;1.eps&#125; 用于插入图片，可用 [] 添加图片尺寸；花括号中为图片相对路径，通常应将图片放在与latex文档相同的路径下，图片格式采用.eps矢量格式会更清晰； \\caption 命令用于插入图注，其应用在``\\includegraphics的下方即将图注插在图片下方，反之亦然。在其中加入\\centering` 命令可使图片标题居中。 双栏图片变单栏时，只需要将\\begin&#123;figure&#125;[htb] 转变为 \\begin&#123;figure*&#125;[htb]. 多图并列 一张图片显然不能满足我们的要求，我们接下来要使用的是多图并列，让每个小图都有自己的小标题以及，整个图形有个大标题。 双图横排： 12345678910111213141516% 需要宏包\\usepackage&#123;subcaption&#125;\\usepackage&#123;graphicx&#125;\\begin&#123;figure&#125;[H] \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\centering \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\end&#123;minipage&#125; \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\end&#123;minipage&#125; \\caption&#123;\\centering &#125;% 大标题 \\end&#123;figure&#125; 12345678910111213\\begin&#123;figure&#125;[H] \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\centering \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\end&#123;minipage&#125; \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\end&#123;minipage&#125; \\caption&#123;\\centering &#125;% 大标题 \\end&#123;figure&#125; 双图竖排： 四图平铺排列： 1234567891011121314151617181920212223242526\\begin&#123;figure&#125;[!h] \\centering \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\label&#123;&#125;% 标签 \\end&#123;minipage&#125; \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\label&#123;&#125;% 标签 \\end&#123;minipage&#125; \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\label&#123;&#125;% 标签 \\end&#123;minipage&#125; \\begin&#123;minipage&#125;[c]&#123;0.45\\textwidth&#125; \\includegraphics[width=1\\textwidth]&#123;&#125;% 文件位置 \\subcaption&#123;\\centering &#125;% 小标题 \\label&#123;&#125;% 标签 \\end&#123;minipage&#125; \\caption&#123;\\centering &#125;% 大标题 \\label&#123;&#125;% 标签\\end&#123;figure&#125; 公式 公式标号 笔者统一采用 align 环境作为公式环境，默认标号： 1234\\begin&#123;align&#125; x^2+1=0\\\\ 3x+2=1\\end&#123;align&#125; 取消全部编号： 1234\\begin&#123;align*&#125; x^2+1=0\\\\ 3x+2=1\\end&#123;align*&#125; 取消自定义编号： 1234\\begin&#123;align&#125; x^2+1=0 \\notag\\\\ 3x+2=1\\end&#123;align&#125; 公式换行 在 align 环境中，采用 \\\\ 换行，换行自动添加编号，如想合并编号，需要采用下面的方式： 合并编号： 123456\\begin&#123;align&#125; \\begin&#123;split&#125; x^2+1=0 \\\\ 3x+2=1 \\end&#123;split&#125;\\end&#123;align&#125; 多行公式对齐可利用 &amp; 符号，具体使用方法如下所示： 1234\\begin&#123;align&#125; x^2+2x+1&amp;=0 \\\\ 3x^2+2x&amp;=1\\end&#123;align&#125; 对于较为复杂的含 \\right与\\left公式，若换行将其打断，可采用在上一行末添加 \\right.，下一行初添加\\left.的方式。 123456\\begin&#123;align&#125; \\begin&#123;split&#125; \\int_&#123;0&#125;^&#123;s_&#123;0&#125;&#125;&amp;\\left[\\left(&#123;~m&#125; \\omega^&#123;2&#125; r+\\frac&#123;&#123;d&#125; T_&#123;r&#125;&#125;&#123;&#123;~d&#125; s&#125;+F_&#123;r&#125;\\right) \\delta r+\\left(\\frac&#123;d T_&#123;\\theta&#125;&#125;&#123;d s&#125;+F_&#123;\\theta&#125;\\right) r \\delta \\theta \\right.\\\\&amp;\\left. +\\left(\\frac&#123;&#123;d&#125; T_&#123;z&#125;&#125;&#123;&#123;~d&#125; s&#125;+F_&#123;z&#125;\\right) \\delta z\\right] &#123;d&#125; s=0 \\end&#123;split&#125;\\end&#123;align&#125; 表格 基本操作 小工具： 前往表格生成网站自动生成表格代码： https://www.latex-tables.com/ Tables Generator 采用 Excel 插件Excel2LaTeX，具体使用方法：还在手写LaTeX表格？你可能需要这款神器 三线表： 123456789101112131415% 所需宏包提供命令\\toprule、\\midrule、\\bottomrule\\usepackage&#123;booktabs&#125;\\begin&#123;table&#125;[h] \\centering \\caption&#123;这是标题&#125; \\begin&#123;tabular&#125;&#123;ccc&#125; \\toprule A &amp; B &amp; C\\\\ \\midrule 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6\\\\ 7 &amp; 8 &amp; 9\\\\ \\bottomrule \\end&#123;tabular&#125;\\end&#123;table&#125; 列表格式说明： l 本列左对齐(小写的L) c 本列居中 r 本列右对齐 *{（计数）} {（列格式说明）} 将给出的列的格式说明重复多次。 @{ （内容）} 添加任意的内容， 不占表项计数，取消列表间的间隔 t 顶部对齐 b 底部对齐 换行操作 如需要在表格中换行，采用\\makecell命令即可： 1234567891011121314\\usepackage&#123;makecell&#125;\\begin&#123;table&#125; \\centering \\caption&#123;这是标题&#125; \\begin&#123;tabular&#125;&#123;ccc&#125; \\toprule \\makecell&#123;I\\\\love\\\\Apple&#125;&amp;B&amp;C\\\\ \\midrule 1&amp;2&amp;3\\\\ 4&amp;5&amp;6\\\\ 7&amp;8&amp;9\\\\ \\bottomrule \\end&#123;tabular&#125;\\end&#123;table&#125; 多行合并 列的合并： 我们使用\\multicolumn&#123;项数&#125;&#123;新列格式&#125;&#123;内容&#125; 命令将一行中的几个不同的表格合并为一项 123456789101112\\usepackage&#123;multirow&#125;\\begin&#123;table&#125;[h] \\begin&#123;tabular&#125;&#123;|c|c|c|&#125; \\hline \\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;成绩&#125; \\\\ \\hline 语文 &amp; 数学 \\\\ \\hline 87 &amp; 100 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;table&#125; 行的合并： 1234567891011\\begin&#123;table&#125;[h] \\begin&#123;tabular&#125;&#123;|c|c|c|c|&#125; \\hline \\multicolumn&#123;3&#125;&#123;|c|&#125;&#123;成绩&#125; \\\\ \\hline \\multirow&#123;2&#125;&#123;*&#125;&#123;小明&#125;&amp;语文 &amp; 数学 \\\\ \\cline&#123;2-3&#125; %要注意这里线的长度 &amp;87 &amp; 100 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;table&#125; 行间距 \\renewcommand\\arraystretch&#123;1.5&#125; 这个命令放于 \\begin&#123;table&#125;之前，可有效设置行间距 其他表格长度宽度设置：LaTeX各种表格 参考文献环境 据说 bibtex 可是个好东西，可惜我不会，下面这种傻瓜式的文献引用，我倒用的乐此不疲 参考文献 参考文献格式： 12345\\begin&#123;thebibliography&#125;&#123;编号样本&#125;\\bibitem[记号]&#123;引用标志&#125;文献条目1\\bibitem[记号]&#123;引用标志&#125;文献条目2……\\end&#123;thebibliography&#125; 具体使用范例： 其中文献条目包括：作者，题目，出版社，年代，版本，页码等。 引用 一般引用： 引用时候要可以采用：\\cite&#123;引用标志1，引用标志2，…&#125; 下面来看一个具体的例子 12345678引用一篇文章\\cite&#123;article1&#125; \\\\引用一本书\\cite&#123;book1&#125;\\\\等等\\renewcommand\\refname&#123;参考文献&#125;\\begin&#123;thebibliography&#125;&#123;99&#125;\\bibitem&#123;article1&#125;文章标题 作者 期刊 年代 页码\\bibitem&#123;book1&#125;书标题 作者 出版社 年代\\end&#123;thebibliography&#125; 注意要用 LaTeX编译两次才能产生正常的引用标号! 上标无括号引用： 将参考文献作为上标引用，可启用overcite 宏包，然后在文献引用处，用cite 命令引用即可。 1\\usepackage&#123;overcite&#125; %使用宏包 上标有括号引用： 本文采用的是upcite 命令来实现上标引用，其格式为 \\newcommand&#123;\\upcite&#125;[1]&#123;\\textsuperscript&#123;\\textsuperscript&#123;\\cite&#123;#1&#125;&#125;&#125;&#125; 123456789\\usepackage&#123;multirow&#125;\\newcommand&#123;\\upcite&#125;[1]&#123;\\textsuperscript&#123;\\textsuperscript&#123;\\cite&#123;#1&#125;&#125;&#125;&#125;\\begin&#123;document&#125;引用一篇文章\\upcite&#123;article1&#125; 引用一本书\\cite&#123;book1&#125;等等\\begin&#123;thebibliography&#125;&#123;99&#125;\\bibitem&#123;article1&#125;文章标题 作者 期刊 年代 页码\\bibitem&#123;book1&#125;书标题 作者 出版社 年代\\end&#123;thebibliography&#125;\\end&#123;document&#125; 其他注意： 其中\\begin&#123;thebibliography&#125;&#123;99&#125;, 这个数字99 指的是参考文献的项目按照数字进行编号, 并且最多为99个, 如果你有更多的项目, 把这个数字改大一点就行了. 如何你想用对参考文献的项目进行其他类型的编号, 你可以将上面例子中的 thebibliography 环境替换成 1234\\begin&#123;thebibliography&#125;&#123;ABCDEFGHIJK&#125;\\bibitem[authour1]&#123;article1&#125;文章标题 作者 期刊 年代 页码\\bibitem[authour2]&#123;book1&#125;书标题 作者 出版社 年代\\end&#123;thebibliography&#125; 这个时候的引用标记将变成 \\bibitem 后面括号[ ]里面的内容了. 另外一种经常用的小技巧是, 把文档中的 Reference 写成中文的”参考文献” 如果文档类是article之类的, 用\\renewcommand\\refname&#123;参考文献&#125; 如果文档类是book之类的, 用\\renewcommand\\bibname&#123;参考文献&#125; 其他小点 字体不能加粗问题 问题： 最近用latex写英文文章，用\\textbf&#123;&#125;加粗选中字体失效， 解决方法： 引入包 1\\usepackage[T1]&#123;fontenc&#125;","categories":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://ckblogs.cn/categories/LaTeX/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/tags/%E6%8A%80%E5%B7%A7/"},{"name":"LaTex","slug":"LaTex","permalink":"http://ckblogs.cn/tags/LaTex/"}]},{"title":"leetcode 好题笔记 —— [234] 回文链表","slug":"leetcode 好题笔记 —— [234] 回文链表 183514","date":"2021-09-14T08:11:42.000Z","updated":"2021-09-26T03:07:31.789Z","comments":true,"path":"2021/09/14/leetcode 好题笔记 —— [234] 回文链表 183514/","link":"","permalink":"http://ckblogs.cn/2021/09/14/leetcode%20%E5%A5%BD%E9%A2%98%E7%AC%94%E8%AE%B0%20%E2%80%94%E2%80%94%20[234]%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%20183514/","excerpt":"","text":"leetcode 好题笔记 —— [234] 回文链表 题目描述 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 示例1: 12输入：head &#x3D; [1,2,2,1]输出：true 示例2: 12输入：head &#x3D; [1,2]输出：false 提示: 链表中节点数目在范围[1, 105] 内 0 &lt;= Node.val &lt;= 9 实现算法 一、快慢指针 所谓快慢指针，是寻找链表中间节点的有效方法。也可用于判断链表回路是否存在环。 快慢指针算法思想: 定义快慢指针fast和slow，起始均位于链表头部。规定fast每次后移2步，slow后移1步； 若fast遇到null节点，则表示链表无环，结束； 此时slow点所在节点即为链表的中心节点，奇数链表返回中间值，偶数列表返回中间偏前值。 若链中有环，fast和slow一定会再次相遇； 当fast和slow相遇时，额外创建指针ptr，并指向链表头部，且每次后移1步，最终slow和ptr会在入环点相遇。 实现代码： 123456789def helfListNode_of_list(self, head): # 快慢指针返回中间指针 fast = head slow = head while fast.next is not None and fast.next.next is not None: fast = fast.next.next slow = slow.next #! 奇数链表返回中间值,偶数列表返回中间偏前值 return slow 2. 递归反转链表 这里的递归比较难理解，为了翻转链表，首先使用递归找到最后一个节点，在下文的实现代码中，我将其定义为 head_next ，而遍历到此时的 head 的节点即为 最后节点 head_next 的父节点，即倒数第二个节点 123# 子节点指向父节点，并切断父节点指向子节点head.next.next = headhead.next = None 以此递归回去，使每一个节点都指向父节点，而切断原父节点对子节点的指向。需要注意的是，我们在此过程中并未对最后节点 head_next 进行任何操作，所以最终返回的便是翻转后的链表头结点。 实现代码： 1234567891011def reserve_list(self, head:ListNode) -&gt; ListNode: #! 返回翻转链表头结点 if head is None or head.next is None: return head else: # head_next 为最后一个节点,此步骤为了找到最后一个节点 head_next = self.reserve_list(head.next) # 子节点指向父节点 head.next.next = head head.next = None return head_next 3. 总接口函数 **目的操作：**找到前半部分链表的尾节点并反转后半部分链表，对两串列表进行一一对应操作以此判断链表是否为回文链表。 实现代码： 123456789101112131415class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if head is None or head.next is None: return True mid_node = self.helfListNode_of_list(head) reserved_head = self.reserve_list(mid_node.next) while reserved_head is not None: if head.val != reserved_head.val: return False else: head = head.next reserved_head = reserved_head.next return True 复杂度分析 时间复杂度：O(n)，其中 n 指的是链表的大小。 空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1) 二、递归 算法思想： currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val != frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。 算法的正确性在于递归处理节点的顺序是相反的（回顾上面打印的算法），而我们在函数外又记录了一个变量，因此从本质上，我们同时在正向和逆向迭代匹配。 12345678910111213141516171819202122class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: self.front_pointer = head def recursively_check(current_node=head): if current_node is not None: # 不断递归的目的是找到最后一个节点 if not recursively_check(current_node.next): return False # front_pointer 从头开始 current_node 递归从尾开始 if self.front_pointer.val != current_node.val: return False self.front_pointer = self.front_pointer.next return True return recursively_check()作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 复杂度分析 时间复杂度：O(n)，其中 n 指的是链表的大小。 空间复杂度：**O(n) **，其中 n 指的是链表的大小。","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://ckblogs.cn/tags/Python/"},{"name":"算法 - leetcode","slug":"算法-leetcode","permalink":"http://ckblogs.cn/tags/%E7%AE%97%E6%B3%95-leetcode/"}]},{"title":"综合评价理想解法(TOPSIS解法)","slug":"综合评价理想解法(TOPSIS解法)","date":"2021-08-06T15:27:29.000Z","updated":"2021-09-26T03:13:50.717Z","comments":true,"path":"2021/08/06/综合评价理想解法(TOPSIS解法)/","link":"","permalink":"http://ckblogs.cn/2021/08/06/%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E7%90%86%E6%83%B3%E8%A7%A3%E6%B3%95(TOPSIS%E8%A7%A3%E6%B3%95)/","excerpt":"","text":"综合评价理想解法(TOPSIS解法) [TOC] 问题的理想解法,理想解法亦称为 TOPSIS 法，是一种有效的多指标评价方法。这种方法。通过构造评价问题的正理想解和负理想解, 即各指标的最优解和最劣解,通过计算每个方案到理想方案的相对贴近度，即靠近正理想解和远离负理想解的程度，来对方案进行排序，从而选出最优方案。 计算步骤 TOPSIS 法的具体算法步骤如下: 用向量规划化的方法求得规范决策矩阵。设多属性决策问题的决策矩阵 A=(aij)m×n\\boldsymbol{A}=\\left(a_{i j}\\right)_{m \\times n}A=(aij​)m×n​​, 规范化决策矩阵 B=(bij)m×n\\boldsymbol{B}=\\left(b_{i j}\\right)_{m \\times n}B=(bij​)m×n​​​, 其中 bij=aij/∑i=1maij2,i=1,2,⋯ ,m;j=1,2,⋯ ,n∘b_{i j}=a_{i j} / \\sqrt{\\sum_{i=1}^{m} a_{i j}^{2}}, i=1,2, \\cdots, m ; j=1,2, \\cdots, n_{\\circ} bij​=aij​/i=1∑m​aij2​​,i=1,2,⋯,m;j=1,2,⋯,n∘​ 构造加权规范阵 C=(cij)m×n\\boldsymbol{C}=\\left(c_{i j}\\right)_{m \\times n}C=(cij​)m×n​​​ 。设由决策人给定各属性的权重向量为 w=[w1,w2,⋯ ,wn]T\\boldsymbol{w}=\\left[w_{1},w_{2}, \\cdots, w_{n}\\right]^{\\mathrm{T}}w=[w1​,w2​,⋯,wn​]T​​, 则 cij=wj⋅bij,i=1,2,⋯ ,m;j=1,2,⋯ ,n∘c_{i j}=w_{j} \\cdot b_{i j}, i=1,2, \\cdots, m ; j=1,2, \\cdots, n_{\\circ} cij​=wj​⋅bij​,i=1,2,⋯,m;j=1,2,⋯,n∘​ 确定正理想解 C∗\\boldsymbol{C}^{*}C∗​​ 和负理想解 C0\\boldsymbol{C}^{0}C0​​ 。设正理想解 C∗\\boldsymbol{C}^{*}C∗​​ 的第 j\\mathrm{j}j​​ 个属性值为 cj∗c_{j}^{*}cj∗​​​,负理想 解 C0\\boldsymbol{C}^{0}C0​​ 第 jjj​​ 个属性值为 cj0c_{j}^{0}cj0​​​, 则 ​ 正理想解 : cj∗={max⁡icij,j 为效益型属性, min⁡icij,j 为成本型属性, j=1,2,⋯ ,nc_{j}^{*}=\\left\\{\\begin{array}{l}\\max _{i} c_{i j}, j \\text { 为效益型属性, } \\\\ \\min _{i} c_{i j}, j \\text { 为成本型属性, }\\end{array} j=1,2, \\cdots, n\\right. cj∗​={maxi​cij​,j 为效益型属性, mini​cij​,j 为成本型属性, ​j=1,2,⋯,n ​ 负理想解 : cj0={min⁡icij,j 为效益型属性, max⁡cij,j 为成本型属性, j=1,2,⋯ ,nc_{j}^{0}=\\left\\{\\begin{array}{l}\\min _{i} c_{i j}, j \\text { 为效益型属性, } \\\\ \\max c_{i j}, j \\text { 为成本型属性, }\\end{array} j=1,2, \\cdots, n\\right. cj0​={mini​cij​,j 为效益型属性, maxcij​,j 为成本型属性, ​j=1,2,⋯,n 计算各方案到正理想解与负理想解的距离。 备选方案 di\\boldsymbol{d}_{i}di​到正理想解的距离为 si∗=∑j=1n(cij−cj∗)2,i=1,2,⋯ ,m;s_{i}^{*}=\\sqrt{\\sum_{j=1}^{n}\\left(c_{i j}-c_{j}^{*}\\right)^{2}}, i=1,2, \\cdots, m ; si∗​=j=1∑n​(cij​−cj∗​)2​,i=1,2,⋯,m; ​ 备选方案 di\\boldsymbol{d}_{i}di​ 到负理想解的距离为 si0=∑j=1n(cij−cj0)2,i=1,2,⋯ ,m∘s_{i}^{0}=\\sqrt{\\sum_{j=1}^{n}\\left(c_{i j}-c_{j}^{0}\\right)^{2}}, i=1,2, \\cdots, m_{\\circ} si0​=j=1∑n​(cij​−cj0​)2​,i=1,2,⋯,m∘​ 计算各方案的排序指标值(即综合评价指数), 即 fi∗=si0/(si0+si∗),i=1,2,⋯ ,m∘f_{i}^{*}=s_{i}^{0} /\\left(s_{i}^{0}+s_{i}^{*}\\right), i=1,2, \\cdots, m_{\\circ} fi∗​=si0​/(si0​+si∗​),i=1,2,⋯,m∘​ 按 fi∗f_{i}^{*}fi∗​​​ 由大到小排列方案的优劣次序。 示例： 例：科研团队实力评估 为了客观地评价我校各科研团队实力水平，经校领导研究决定组织一次对学校各科研团队的实力评估。为了取得经验，先选了5 个团队，收集有关资料信息进行试评估，下表是给出的部分数据。 承担项目跨学科数量 x1x_1x1​ 平均科研经费 x2x_2x2​ 2018年承担项目数量 x3x_3x3​​ 1 3 375 3 2 6 400 5 3 8 280 3 4 2 425 2 5 1 500 4 第一步：数据预处理 数据的预处理又称属性值的规范化。属性值具有多种类型,包括效益型、成本型和区间型等。这三种属性,效益型属性越 大越好，成本型属性越小越好，区间型属性是在某个区间最佳。 在进行决策时，一般要进行属性值的规范化，主要有如下三个作用: 属性值有多种类型，上述三种属性放在同一个表中不便于直接从数值大小判断方案的优劣,因此需要对数据进行预处理,使得表中任一属性下性能越优的方案变换后的属性值越大。 非量纲化，多属性决策与评估的困难之一是属性间的不可公度性,即在属性值表中的每一列数具有不同的单位(量纲)。即使对同一属性，采用不同的计量单位，表中的数值也就不同。 在用各种多属性决策方法进行分析评价时,需要排除量纲的选用对决策或评估结果的影响，这就是非量纲化。 归一化，属性值表中不同指标的属性值的数值大小差别很大，为了直观,更为了便于采用各种多属性决策与评估方法进行评价，需要把属性值表中的数值 归一化，即把表中数值均变换到 [0,1][0,1][0,1] 区间上。 此外，还可在属性规范时用非线性变换或其他办法，来解决或部分解决某些目标的达 到程度与属性值之间的非线性关系,以及目标间的不完全补偿性。常用的属性规范化方法有以下几种。 **线性变换。**原始的决策矩阵为 A=(aij)m×n\\boldsymbol{A}=\\left(a_{i j}\\right)_{m \\times n}A=(aij​)m×n​ ​, 变换后的决策矩阵记为 B=(bij)m×n,i=1,⋯ ,m;j=1,⋯ ,n∘\\boldsymbol{B}=\\left(b_{i j}\\right)_{m \\times n}, i=1, \\cdots, m ; j=1, \\cdots, n_{\\circ}B=(bij​)m×n​,i=1,⋯,m;j=1,⋯,n∘​​ 设 ajmaxa_{j}^{\\mathrm{max}}ajmax​​ 是决策矩阵第 jjj​ 列中的最大值, ajmin⁡a_{j}^{\\min }ajmin​​ 是决策矩阵第 jjj​ 列中的最小值。若 xjx_{j}xj​​​​ 为效益型属性,则 bij=aij/ajmax⁡b_{i j}=a_{i j} / a_{j}^{\\max } bij​=aij​/ajmax​ 采用上式进行属性规范化时,经过变换的最差属性值不一定为 0 ,最优属性值为 1 。 若 xjx_{j}xj​ 为成本型属性,则 bij=1−aij/ajmax⁡b_{i j}=1-a_{i j} / a_{j}^{\\max } bij​=1−aij​/ajmax​ **标准 0−10-10−1 变换。**为了使每个属性变换后的最优值为 1 且最差值为 0 , 可以进行 标准 0−10-10−1 变换。对效益型属性 xjx_{j}xj​, 令 bij=aij−ajmin⁡ajmax⁡−ajmin⁡ , b_{i j}=\\frac{a_{i j}-a_{j}^{\\min }}{a_{j}^{\\max }-a_{j}^{\\min }} \\text { , } bij​=ajmax​−ajmin​aij​−ajmin​​ , 对成本型属性 xjx_{j}xj​, 令 bij=ajmax⁡−aijajmax⁡−ajmin⁡b_{i j}=\\frac{a_{j}^{\\max }-a_{i j}}{a_{j}^{\\max }-a_{j}^{\\min }} bij​=ajmax​−ajmin​ajmax​−aij​​ **区间型属性的变换。**有些属性既非效益型又非成本型,如生师比。显然这种属 性不能采用前面介绍的两种方法处理。 设给定的最优属性区间为 [aj0,aj∗],aj′\\left[a_{j}^{0}, a_{j}^{*}\\right], a_{j}^{\\prime}[aj0​,aj∗​],aj′​ 为无法容忍下限,aj′′a_{j}^{\\prime \\prime}aj′′​​ 为无法容忍上限,则 bij={1−(aj0−aij)/(aj0−aj′),aj′⩽aij&lt;aj0,1,aj0⩽aij⩽aj∗,1−(aij−aj∗)/(aj′′−aj∗),aj∗&lt;aij⩽aj′′,0, 其他。 b_{i j}= \\begin{cases}1-\\left(a_{j}^{0}-a_{i j}\\right) /\\left(a_{j}^{0}-a_{j}^{\\prime}\\right), &amp; a_{j}^{\\prime} \\leqslant a_{i j}&lt;a_{j}^{0}, \\\\ 1, &amp; a_{j}^{0} \\leqslant a_{i j} \\leqslant a_{j}^{*}, \\\\ 1-\\left(a_{i j}-a_{j}^{*}\\right) /\\left(a_{j}^{\\prime \\prime}-a_{j}^{*}\\right), &amp; a_{j}^{*}&lt;a_{i j} \\leqslant a_{j}^{\\prime \\prime}, \\\\ 0, &amp; \\text { 其他。 }\\end{cases} bij​=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​1−(aj0​−aij​)/(aj0​−aj′​),1,1−(aij​−aj∗​)/(aj′′​−aj∗​),0,​aj′​⩽aij​&lt;aj0​,aj0​⩽aij​⩽aj∗​,aj∗​&lt;aij​⩽aj′′​, 其他。 ​ 变换后的属性值 bijb_{i j}bij​ 与原属性值 aija_{i j}aij​ 之间的函数图形为一般梯形。当属性值最优区间的上 下限相等时,最优区间退化为一个点时, 函数图形退化为三角形。 向量规范化。 无论成本型属性还是效益型属性,向量规范化均用下式进行变换: bij=aii/∑i=1maij2,i=1,⋯ ,m,j=1,⋯ ,n∘b_{i j}=a_{i i} / \\sqrt{\\sum_{i=1}^{m} a_{i j}^{2}}, i=1, \\cdots, m, j=1, \\cdots, n_{\\circ} bij​=aii​/i=1∑m​aij2​​,i=1,⋯,m,j=1,⋯,n∘​ 它与前面介绍的几种变换不同,从变换后属性值的大小上无法分辨属性值的优劣。 它的最大特点是,规范化后,各方案的同一属性值的平方和为 1 , 因此常用于计算各 方案与某种虛拟方案(如理想点或负理想点)的欧几里得距离的场合。 **标准化处理。**在实际问题中,不同变量的测量单位往往是不一样的。为了消除 变量的量纲效应,使每个变量都具有同等的表现力,数据分析中常对数据进行标准化处理,即 bij=aij−aˉjsj,i=1,2,⋯ ,m,j=1,2,⋯ ,n, 式中: aˉj=1m∑i=1maij,sj=1m−1∑i=1m(aij−aˉj)2,j=1,2,⋯ ,n∘\\begin{gathered} b_{i j}=\\frac{a_{i j}-\\bar{a}_{j}}{s_{j}}, i=1,2, \\cdots, m, j=1,2, \\cdots, n, \\\\ \\text { 式中: } \\bar{a}_{j}=\\frac{1}{m} \\sum_{i=1}^{m} a_{i j}, s_{j}=\\sqrt{\\frac{1}{m-1} \\sum_{i=1}^{m}\\left(a_{i j}-\\bar{a}_{j}\\right)^{2}}, j=1,2, \\cdots, n_{\\circ} \\end{gathered} bij​=sj​aij​−aˉj​​,i=1,2,⋯,m,j=1,2,⋯,n, 式中: aˉj​=m1​i=1∑m​aij​,sj​=m−11​i=1∑m​(aij​−aˉj​)2​,j=1,2,⋯,n∘​​ 本例及一般TOPSIS解法采用向量规范化处理数据，规范化后结果如下表所示： 承担项目跨学科数量 x1x_1x1​ 平均科研经费 x2x_2x2​ 2018年承担项目数量 x3x_3x3​​ 1 0.2810 0.4168 0.3780 2 0.5620 0.4445 0.6299 3 0.7493 0.3112 0.3780 4 0.1873 0.4723 0.2520 5 0.0937 0.5557 0.5040 ### 第二步：加权向量规范化 设权向量为 w=[0.2,0.5,0.3]\\boldsymbol{w}=[ 0.2,0.5,0.3 ]w=[0.2,0.5,0.3]​​​​，得到加权后的向量规范属性矩阵见下表: 承担项目跨学科数量 x1x_1x1​ 平均科研经费 x2x_2x2​ 2018年承担项目数量 x3x_3x3​​ 1 0.0562 0.2084 0.1134 2 0.1124 0.2223 0.1890 3 0.1499 0.1556 0.1134 4 0.0375 0.2362 0.0756 5 0.0187 0.2778 0.1512 第三步: 计算正理想解和负理想解 正理想解 : C∗=[0.1499,0.2778,0.1890]C^{*}=[0.1499,0.2778,0.1890]C∗=[0.1499,0.2778,0.1890]​​, 负理想解 : C0=[0.0187,0.1556,0.0756]C^{0}=[0.0187,0.1556,0.0756]C0=[0.0187,0.1556,0.0756]​ 第四步: 计算各方案到达各理想解的距离 分别用下面两式求各方案到正理想解的距离 si∗s_{i}^{*}si∗​​​​ 和负理想解的 距离 si0s_{i}^{0}si0​​​​​​, 列于下表 。 备选方案 di\\boldsymbol{d}_{i}di​到正理想解的距离为 si∗=∑j=1n(cij−cj∗)2,i=1,2,⋯ ,m;s_{i}^{*}=\\sqrt{\\sum_{j=1}^{n}\\left(c_{i j}-c_{j}^{*}\\right)^{2}}, i=1,2, \\cdots, m ; si∗​=j=1∑n​(cij​−cj∗​)2​,i=1,2,⋯,m; 备选方案 di\\boldsymbol{d}_{i}di​ 到负理想解的距离为 si0=∑j=1n(cij−cj0)2,i=1,2,⋯ ,m∘s_{i}^{0}=\\sqrt{\\sum_{j=1}^{n}\\left(c_{i j}-c_{j}^{0}\\right)^{2}}, i=1,2, \\cdots, m_{\\circ} si0​=j=1∑n​(cij​−cj0​)2​,i=1,2,⋯,m∘​ 距离值及综合指标值: $s_{i}^{*} $ si0s_{i}^{0}si0​ $ f_{i}^{*}$ 1 0.1390 0.0750 0.3504 2 0.0670 0.1615 0.7067 3 0.1437 0.1365 0.4870 4 0.1650 0.0827 0.3339 5 0.1365 0.1437 0.5130 第五步: 计算排列指标值 根据上表 $ f_{i}^{*}$​​​ 指标排序，可得各方案​​从优到劣的次序为 4，1，3，5，2 排名 承担项目跨学科数量 x1x_1x1​ 平均科研经费 x2x_2x2​ 2018年承担项目数量 x3x_3x3​ 4 3 375 3 1 6 400 5 3 8 280 3 5 2 425 2 2 1 500 4 MATLAB 实现代码 1234567891011121314151617181920212223clc, cleara=[3 375 3 6 400 5 8 280 3 2 425 1 500 4];[m,n]=size(a);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for j=1:n b(:,j)=a(:,j)/norm(a(:,j)); %向量规划化endw=[0.2 0.5 0.3];c=b.*repmat(w,m,1); %求加权矩阵Cstar=max(c); %求正理想解C0=min(c); %求负理想解%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for i=1:m Sstar(i)=norm(c(i,:)-Cstar); %求到正理想解的距离 S0(i)=norm(c(i,:)-C0); %求到负理想的距离endf=S0./(Sstar+S0);[sf,ind]=sort(f,&#x27;descend&#x27;) %求排序结果","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"Matlab","slug":"Matlab","permalink":"http://ckblogs.cn/tags/Matlab/"},{"name":"评价类算法","slug":"评价类算法","permalink":"http://ckblogs.cn/tags/%E8%AF%84%E4%BB%B7%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://ckblogs.cn/tags/TOPSIS/"}]},{"title":"C语言陌生点总结","slug":"C语言的陌生点","date":"2021-08-06T15:27:29.000Z","updated":"2021-09-26T03:15:37.174Z","comments":true,"path":"2021/08/06/C语言的陌生点/","link":"","permalink":"http://ckblogs.cn/2021/08/06/C%E8%AF%AD%E8%A8%80%E7%9A%84%E9%99%8C%E7%94%9F%E7%82%B9/","excerpt":"","text":"此内容为本人大一第一学期学习C语言中遇到的难点总结，或者是容易忽略的点,并不是C语言的全面知识,而大部分是边角知识！ [TOC] C语言的陌生点 CK出品，必属精品！ 1.变量命名 可以用小写字母、大写字母、数字和下划线（_）来命名 注意：名称的第一个字符必须是字母或下划线，不能是数字！ 有效的名称 无效的名称 cat2 Hot-Yab _kcab 2cat 2.*（了解）位、字节和字 位（bit）：最小的存储单元，可以存储0或1. 字节：常用的计算机存储单位，一字节均为8位（bit）. 8位字节有256即2^8^种不同的组合，通过二进制编码便可表示0~255的整数或一组字符。 字（word）：设计计算机时给定的自然存储单位。 对于8位微型计算机，一个字长只有8位。目前个人计算机字长增长到64位。计算机的字长越大，数据转移越快，允许的内存访问就更多。 3.基本数据类型及相关知识 int类型 一般而言，存储一个int类型的数据需要占用一个机器字长(至少占16位)。而对于32位及以上的计算机而言，int类型数据的取值数有2^32^个。 因为对于32位计算机，一字长有32位，这32位有2的32次方种变化。64位计算机中的int类型数据依然按照32位计算机计算。 因此，对于一个有符号的int数据，它的存储范围是 -2^31^~2^31^-1，而ISO C规定的int类型的最小范围是以16位字长为单位的存储方式，即-32768~32767 -1的原因是0的存在。 b.进制的使用和显示 使用进制： 0x/0X表示十六进制的前缀。eg：0X1001 == 9 0表示八进制前缀。eg：020 == 16 显示进制： %d表示以十进制显示数字； %o表示以八进制显示数字； %x表示以十六进制显示数字； 注意：要显示各进制的前缀0，0x，0X，必须要分别使用%#o，%#x，%#X. c.其他整数类型及其打印 short int （或简写成short）：%hd…(至少占16位) long int (long): %ld…(至少占32位) long long int(long long): %lld(至少占64位) unsigned int(unsigned): %u… unsigned long int: %lu… *溢出：溢出相应类型会重新从起点开始，如下面的例子 1234567891011121314#include &lt;stdio.h&gt;int main (void)&#123; short int i = 32767; unsigned short int j = 65535; printf(&quot;i = %hd,i + 1 = %hd,i + 2 = %hd\\n&quot;,i,i+1,i+2); printf(&quot;j = %hu,j + 1 = %hu,j + 2 = %hu\\n&quot;,j,j+1,j+2); return 0;&#125; /*运行结果： i = 32767,i + 1 = -32768,i + 2 = -32767j = 65535,j + 1 = 0,j + 2 = 1*/ float 类型 a.浮点数的表示方式 数字 科学计数法 指数计数法 100000 1.0$ \\times $10^5^ 1.0e9 322.56 3.2256$\\times$10^2^ 3.2256e2 b.其它浮点型类型及其打印 float :%f double :%f ！！！这里一定要注意，对double类型输入用%lf，输出用%f long double:%Lf 若想用科学计数法表示则需要用%e，或者%Le c.浮点数的上溢和下溢 浮点数的上溢和下溢 char类型 C语言把1字节定义为char类型占用的位（bit）数 a.字符常量的初始化 字符常量以整形数字的形式储存，每个字符对于ASCII码上的码值，如果要把一个字符常量初始化，不必背下ASCII码表： 12char ch;ch &#x3D; &#39;A&#39;&#x2F;&#x2F;这里的单引号理解为获取这个字符的ASCII码值 b.转义序列 C语言转义序列 4.const限定符 const 关键字：用于限定一个变量为只读 1const int MONTHS = 12;//这意味着MONTHS这一变量的值将不会被改变 5.printf() a.转换说明修饰符 修饰符 含义 标记 五种标记见附表（-、+、空格、#、0） 数字 最小字段宽度 eg : “%4d” **注意！！**字段宽度会自动根据所占位数而调整 .数字 保留小数的位数/保留字符串长度 eg ：“%5.2f” 附表： 标记 含义 - 左对齐：从字段的左侧开始打印&quot;%-d&quot; + 有符号若为正则添加+号，为负则添加-号 空格 为正则向前添加空格 # “%#o”、“%#x” 0 前导0代替空格填充字段宽度 b.一个大于255的数转化为字符型会发生什么？ 答：该数以256为模得到的值对应ASCII码的字符。 对于其他超限问题，可以类似这种方式进行强制缩小转换得到对应值 有关这方面的内容请参考《C prime plus》P88~P89 c.printf()返回值 若输出正确，则返回printf()参数个数； 若输出错误，则返回负值； d.打印较长的字符串 可以采用三种方法： 方法一：用多个printf()语句 12printf(&quot;Here&#x27;s one way to print a &quot;);printf(&quot;long string.\\n&quot;); 方法二：在&quot;&quot;中插入\\ 12 printf(&quot;Here&#x27;s one way to print a \\long string&quot;);//注意这里不能让long string缩进 方法三：采用多个&quot;&quot; 12printf(&quot;Here&#x27;s one way to print a&quot; &quot;long string&quot;); 6.scanf() a.从scanf角度看输入 %d :scanf跳过空白字符，直至遇到第一个非空白字符。因为要读取整数，所以scanf希望遇到一个+ -或者数字字符，它将一直保存这类字符直至遇到第一个非数字字符。然后scanf会将此非数字字符返回输入端。 注意：如果scanf遇到的第一个非空白字符是非数字、+、-字符，scanf会将此字符返回输入段，并不会将其赋给变量，程序继续进行！ 注意：如果一个scanf含有多个参数变量时，当前一个读取失败后，不会继续向下读取 %o,%x，%f :与%d相似，不同的是他们或许有更多的可读取字符。 对于%f ：&quot;.&quot;也是可读取字符 对于%x：&quot;a~f&quot;也是合法字符 %s :scanf会跳过空白字符开始读取第一个非空白字符，直至再次遇到空白为止。需要注意的是它会在字符序列的末尾添上’\\0’ b.scanf的返回值 如果scanf读取数据成功，那么返回读取项数； 如果需要读取一个数字而用户却输入一个非数字字符串则返回0； 当检测到文件末尾时，会返回 “EOF” 7.printf与scanf的*修饰符 a.printf中的*修饰符 提供两个额外的参数： &quot;.&quot;之前的参数为数字宽度 &quot;.&quot;之后的参数为保留小数位数 请看下面的例子： 12345678910#include &lt;stdio.h&gt;int main (void)&#123; float i = 666.666; printf(&quot;i = %*.*f&quot;,10,4,i); return 0;&#125; /*运行结果： i = 666.6660*/ b.scanf的*修饰符 把*放在%和转换字母之间，会让scanf跳过对应的数字，请看下面的例子： 123456789101112#include &lt;stdio.h&gt;int main (void)&#123; int a; scanf(&quot;%*d %*d %d&quot;,&amp;a); printf(&quot;a = %d&quot;,a); return 0;&#125; /*运行结果： 输入：123 456 789输出：a = 789*/ 8.负数求模 C99规定“趋零截断”：(int)3.6 = 3; (int)-2.7 = -2.有了此条规则后，负数求模有如下结果： 第一个运算对象是负数，那么求模结果是负数，第一个运算对象是正数，那么求模结果是正数 请看下面的例子： 11 % 5 = 1 11 % -5 = 1 -11 % -5 = -1 -11 % 5 = -1 9.类型转换 char和short类型数据出现在表达式时，会被自动转换成int类型 在函数参数传递过程中：char和short会被自动转换成int类型，float会被自动转换成double类型 赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型 在混合类型的运算中，较小类型会被转换成较大类型 10.逗号运算符 逗号运算符把两个表达式连接成一个表达式，并保证左边的表达式最先求值。整个逗号表达式的值是逗号右侧的表达式。 下面我们看一个逗号表达式的例子（这并不是个优秀程序员敲出来的代码） 1234567891011#include &lt;stdio.h&gt;int main ()&#123; int x,y,z; x = (y = 3, (z = ++y + 2) + 5); printf(&quot;x = %d&quot;,x); return 0;&#125;/*输出结果：x = 11*/ 但是逗号表达式常常被用于for循环中： 12for (step = 2,fargo = 0;fargo &lt; 1000;step *=2) fargo += step; 11.条件运算符 “？：” C语言中的唯一三元运算符。条件表达式的通用格式如下： expression1 ? expression2 :expression3 它的含义是：如果expression1为真，则执行expression2，并将expression2的值赋给整个表达式；否则将执行expression3，并将其值赋给整个表达式； 12//max等于a与b中的最大值max = (a &gt; b) ? a : b; 12.switch的多重标签 示例： 12345678switch( expression )&#123; case label1: case label2:statement1 ; break; case label3:statement2; break;&#125; 在本示例中， 如果expression的值与label1或label2的值相等，则执行statement1； 如果expression的值与label3的值相等，则执行statement2； 13.！！文件结尾EOF 这里有疑惑《C prime plus》p220与测试结果不符合 14.数组的初始化 a.int类型的整形数组 未初始化之前，数组内的每一个元素被赋予了垃圾值，初始化后，若初始化数组元素数小于数组全体元素数，则其余元素自动被赋予0； b.指定初始化器（C99） 可以在初始化列表中使用带方括号的下标指明待初始化元素，请见下例： 1int Arr[6] = &#123;[5] = 212&#125;//将212赋值给Arr[5] 15.sizeof运算符 sizeof操作符以字节形式给出了其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数的存储大小由操作数的类型决定。 用于数据类型：sizeof(type) 用于变量：sizeof(var_name) or sizeof var_name 需要注意以下几点要求： 当操作数具有数组类型时，其结果是数组的总字节数。 联合类型操作数的sizeof是其最大字节成员的字节数。 16.函数的形式参数与实际参数 形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。 实参出现在主调函数中，进入被调函数后，实参变量也不能使用。 形参和实参的功能是作数据传送。发生函数调用时，主调函数把实参的值传送给被调函数的形参从而实现主调函数向被调函数的数据传送。 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回 主调函数后则不能再使用该形参变量 。 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形 参。 因此应预先用赋值，输入等办法使实参获得。 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”的错误 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参本身。所以在函数体内部可以改变实参的值。 17.字符串疑难陌生点 a.字符串数组初始化 字符串的初始化方式： 123char ch1[40]=&#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;,&#x27;,&#x27;W&#x27;,&#x27;o&#x27;,&#x27;r&#x27;,&#x27;l&#x27;,&#x27;d&#x27;,&#x27;!&#x27;,&#x27;\\0&#x27;&#125;;char ch2[] = &quot;Hello,World!&quot;;char *p = &quot;Hello,World!&quot;; 以上三种方式中需要注意： 要确保数组元素个数比字符串长度至少多1，系统在字符串末尾添加空字符 初始化时方式一末尾一定添加字符串空字符’\\0’,添加了后是字符串，否则是字符数组； 初始化后数组中的其他元素被自动置0； b.数组和指针对字符串存储方式的不同 数组形式字符串储存在静态存储区，当程序开始运行时，才为数组分配内存，此后才将字符串拷贝到数组中。注意此时字符串有两个副本，一个在静态存储区，另外一个是存储在数组中的字符串。 指针形式系统为指针变量分配一个指针变量的存储空间后，让指针变量指向字符串首字符的地址。 因此，用指针形式的字符串更加高效！ c.字符串的输入比较 scanf()函数 错误的形式： 12char *a;scanf(&quot;%s&quot;,a); 出错的原因是a指针并没有指向任何地址，它是个野指针。 正确的形式: 12char a[100];scanf(&quot;%s&quot;,a); a指针指向一个分配了100内存的数组的首地址。 用scanf函数输入字符串具有很大的局限性： scanf只能读取到空格处，只能读取到一个单词，面对整行输入时，他显得无能为力 不幸的gets()函数 使用形式： 12char word[100];gets(word); 需要注意的是，gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，存储其余字符，并在字符结尾添加空字符。 与之对应的是puts()函数，用于显示字符串，并且会自动在末尾添加换行符。 gets()函数也具有一定的局限性： 它无法保证字符串长度合适地保存到数组中，也就是说存在缓冲区溢出的情况，并占用其他内存，具有一定的风险。 gets()的替代品fgets()函数 使用形式： 12char a[100];fgets(a,100,stdin); fgsts()函数的第二个参数为n，那么函数将会读入n-1个字符； fgets()函数读到换行符时会将其保存到字符串中； 第三个参数代表要读入的文件，stdin为标准输入端； fgets()函数与fputs函数相对应，fputs()函数不在语句后自动添加换行符。 1fputs(a,stdout)//将字符串输出到标准输出端 18.常见的字符串函数 注意：本节所有函数存储在 &lt;string.h&gt; 头文件中 a.strlen() 功能：测量字符串长度 输入参数：字符串指针 返回值：字符串长度（不包括’\\n’） b.strcat()与strncat 1c = strcat(a,b); 功能： 将 b 字符串接到 a 字符串后 输入参数：两字符串指针 返回值： a 字符串指针 注意必须保证 a 字符串拥有足够的空间存储这两个字符串。 对于 strncat() 函数，与 strcat() 函数不同的是，提供第三个参数指定了最大添加字符数 c.strcmp()与strncmp() 1cmp = strcmp(ch_1,ch_b); 功能： 依次比较字符串 ch_1 与 ch_2 的每一个字符 输入参数： ch_1 与 ch_2 是字符串指针 返回值：若两字符串相同则返回 0 ，若不相同返回非 0 对于 strncmp() 函数，与 strcmp() 函数不同的是，提供第三个参数指定了比较字符数。 d.strcpy()与strncpy() 1234567char target[20];int x;x = 5;//数字赋值strcpy(target,&quot;Hello,World!&quot;);//字符串赋值/*错误的表达方式：target = &quot;Hello,World!&quot;;*/ 功能： strcpy() 函数就像是字符串的赋值函数，能够实现从一个字符串复制到另外一个字符串，值得注意的是赋值前，目标字符串会被清空。 输入参数：目标字符串和源字符串指针 返回值：第一个参数 对于 strncpy() 函数，与 strcpy() 函数不同的是，提供第三个参数指定了可拷贝的最大字符数。 其他常见字符串操作头文件&lt;ctype.h&gt; 函 数 功 能 说 明 1 int isalnum( int ch ); 判断字符变量ch是否为字母或数字 当ch为数字0-9或字母a-z及A-Z时，返回非零值，否则返回零. 2 int isalpha( int ch ); 判断字符变量ch是否为字母 当ch为字母a-z及A-Z时，返回非零值，否则返回零。 3 int islower(int ch ); 判断字符变量ch是否为小写字母 当ch为字母a-z时，返回非零值，否则返回零。 4 int isupper(int ch ); 判断字符变量ch是否为大写字母 当ch为字母A-Z时，返回非零值，否则返回零。 5 int isdigit(int ch); 判断字符变量ch是否为十进制数字 当ch为数字0-9时，返回非零值，否则返回零。 6 intisxdigit(int ch); 判断字符变量ch是否为十六进制数字 当ch为数字0-9 a-f A-F时，返回非零值，否则返回零。 7 int iscntrl(int ch ); 判断ch是否控制字符(其ASCII码 0-31之间). 当ch为控制符时，返回非零值，否则返回零。 8 int isgraph(int ch ); 判断ch是否为可显示的图形字符 当ch为图形字符时，返回非零值，否则返回零。 9 int isspace(int ch); 判断ch是否为空格符或跳格符或换行符 当ch为符合时，返回非零值，否则返回零。 10 int isblank(int ch ); 判断ch是否为空格符或跳格符 当ch为符合时，返回非零值，否则返回零。 11 int isprint(intch ); 与isgraph类似，增加了空格 12 int ispunct( int ch ); 判断ch是否为标点字符 13 int tolower(int ch ); 转换ch（A-Z）对应的小写字母 非（A-Z）字符保持不变 14 int toupper(int ch); 转换ch对应的大写字母 非（a-z）字符保持不变 19.多维数组（二维数组）的指针表示法 二维数组的数组理解 对于一个二维数组Arr[m][n]，可以理解为存在m个一维数组Arr[0]~Arr[m-1]，使每一个这样数组都包括n个元素。 二维数组的指针理解 对于一个二位数组Arr[m][n]，*（Arr+i）代表每一个一维数组的首地址，而 *（ *(Arr+i）+j）代表每一个数组元素，他们有下面的对应方式： 1Arr[m][n]== *(*(Arr+m)+n);//这两种表达方式是等价的 下面我们看一个例子：用指针实现三维矩阵的倒置： 1234567891011int m[3][3]=&#123;1,2,3,4,5,6,7,8,9&#125;;int i,j,tem;for(i = 0;i &lt; 3;i++)&#123; for(j = i;j &lt; 3;j++) &#123; tem = *(*(m+i)+j); *(*(m+i)+j) = *(*(m+j)+i); *(*(m+j)+i) = tem; &#125;&#125; 上述表达用数组形式体现得到下面的结果： 1234567891011int m[3][3]=&#123;1,2,3,4,5,6,7,8,9&#125;;int i,j,tem;for(i = 0;i &lt; 3;i++)&#123; for(j = i;j &lt; 3;j++) &#123; tem = m[i][j]; m[i][j] = m[j][i]; m[j][i] = tem; &#125;&#125; 熟练掌握指针与数组间的关系是需要加强的地方。 20.重点：存储类别 a.作用域 块作用域 作用域描述程序中可访问标识符的区域。块作用域是最常见的C语言作用域，在这里一般指的是一对花括号内括起来的代码区域。 整个函数体是一个块，函数中的任意复合语句也是一个块。 定义在块中的变量具有块作用域，块作用域的变量的可用范围仅在块内。 尽管函数头部的形参声明在花括号外部，我们也称该变量属于函数的作用域。 我们看下面的这个例子： 12345for(int i = 0;i &lt; 10;i++)&#123; getchar(Arr); printf(&quot;Hello,World!&quot;); &#125; 在这个例子中，对于i变量只属于for循环这个块作用域，离开for循环后，i变量失效。 文件作用域 定义在函数外面的变量，具有文件作用域。具有文件作用域的变量，从它的定义处到文件末尾处均可用。 文件作用域变量，即我们所说的全局变量。 b.链接 无链接：具有块作用域的变量都属于无链接变量。这意味着这些变量属于定义他们的块、函数或原型私有。 外部链接和内部链接：具有文件作用域的变量具有外部或内部链接，其中可以在多个文件中空用的是外部链接变量，内部链接变量只能在一个翻译单元中使用。 123456int a = 6;static int b = 7;int main ()&#123;...&#125; 在上面的这个例子中，a 这个变量属于外部链接变量，可以供多个文件使用，而 static 标识符的使用让b这个变量成为了内部链接变量，只能在该文件内部使用。 c.存储期 静态存储期：文件作用域变量具有静态存储期，静态存储内存中的变量从程序开始到程序结束的这段时间内都存在。 自动存储期：块作用域的变量通常具有自动存储期。 d.存储类别！！！ 5 种存储类别: 存储类别 存储期 作用域 链接 声明方式 自动 自动 块 无 块内 寄存器 自动 块 无 块内，使用关键字register 静态外部链接 静态 文件 外部 所有函数外 静态内部链接 静态 文件 内部 所有函数外，使用关键字 static 静态无链接 静态 块 无 块内，使用关键字 static 自动变量（auto） 属于自动存储类别的变量具有自动存储期，块作用域，无链接。默认情况下声明在块或函数头中的任何变量都属于自动变量，可以强调显示使用 auto 存储类别说明符： 12345int main (void)&#123; auto int val; ... &#125; 寄存器变量（register） 在程序运行时，根据需要到内存中相应的存储单元中调用，如果一个变量在程序中频繁使用，例如循环变量，那么，系统就必须多次访问内存中的该单元，影响程序的执行效率。因此，C语言\\C++语言还定义了一种变量，不是保存在内存上，而是直接存储在CPU中的寄存器中，这种变量称为寄存器变量。 C编译程序会自动地将寄存器变量变为自动变量。 由于受硬件寄存器长度的限制，所以寄存器变量只能是char、int或指针型。寄存器说明符只能用于自动存储期变量，因此不允许将外部变量或静态变量说明为&quot;register&quot;。 register变量使用的是硬件CPU中的寄存器，寄存器变量无地址，所以不能使用取地址运算符&quot;&amp;&quot;求寄存器变量的地址。 块作用域的静态变量 可以创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具有相同的块作用域，但是程序离开它们所在的函数后，这些变量不会消失，不过也无法直接使用这些变量，但可以通过访问变量地址的方式使用变量。 12345int main (void)&#123; static int num; ...&#125; 在块内部使用 static 关键字声明块作用域的静态变量。 外部链接的静态变量、内部链接的静态变量 外部链接的静态变量，具有外部链接，静态存储期和文件作用域。放在块之外声明的变量属于该类型变量，可以加存储类别关键字 extern 再次声明加以强调： 注意 extern 的含义是表面声明的变量定义在别处，要求该变量一定具有外部链接。 1234567#include &lt;stdio.h&gt;char Coal// 外部链接的静态变量int main (void)&#123; extern char Coal;//再次声明时可加 extern ...&#125; 如果一个源代码中的文件使用外部变量定义在另一个源文件中，则extern关键字不可省略。 内部链接的静态变量需要在快外部定义变量时加static关键字。 二十一、结构体、共用体与枚举 a.结构体 在相同的数据对象中存储多个不同类型数据项的办法是，使用标记标识一个具体的结构模板，并声明该类型的变量。通过点运算符(.)可以使用结构模板中的标签来访问结构的各个成员。指向结构的指针，可以用该指针和间接成员运算符(-&gt;)来访问各结构成员。 有关结构体的内容这里不再赘述。 b.联合简介 联合，即共用体，是一种数据类型，它能在同一个内存空间中存储不同的数据类型（并非同时存储）。下面是一个带标记的联合模板： 123456union hold&#123; int digit; double bigfl; char letter;&#125;; 根据以上声明的结构可以存储一个int类型数据或一个double类型数据或一个char类型数据。 下面是联合的一种使用方法： 1234union hold fit;fit.digit &#x3D; 23;&#x2F;&#x2F;把23存储在fit，占2字节fit.bigfl &#x3D; 2.3&#x2F;&#x2F;清除23，存储2.3，占8字节fit.letter &#x3D; &#39;a&#39;&#x2F;&#x2F;清除2.3，存储a，占1字节 在联合中，一次只存储一个值。但值得注意的是，编译器会分配给共用体足够的空间以便它存储数据，例如本例中，编译器会给共用体hold分配8字节的存储空间（联合内各数据类型的所占最大存储量）。即使有足够的空间也不能同时存储一个char和一个int类型的数据。 c.枚举类型 使用enum关键字创建一个枚举类型，并指定它拥有的值。 笔者所理解的枚举类型，就是给不同的常量命名，以提高程序的可读性。 例如有下面的用法： 12enum spectrum &#123;red,orange,yellow,green,blue,white&#125;;enum spectrum color; 在本例中创建了枚举类型，而它将 red 赋值 0，将 orange 赋值 1，……以此类推。 12printf(&quot;red = %d,orange = %d\\n&quot;,red,orange);//输出：red = 0,orange = 1 默认情况下枚举给它所包含的标签赋值0、1、2……，但依然可以自行赋值，而部分自行赋值，部分未自行赋值的情况下，编译器会根据实际情况赋值，请看下例自行理解，笔者不再阐释： 123456789enum spectrum&#123;red,orange,yellow = 8,green,blue,white&#125;;/*在本例中：red = 0;orange = 1;yellow = 8;green = 9;blue = 10;white = 11;*/ 二十二、运算符的优先级 说明： 同一优先级的运算符，运算次序由结合方向所决定。 简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符 优先级 运算符 名称或含义 *使用形式 结合方向 说明 1 [] 数组下标 数组名[常量表达式] 左到右 – () 圆括号 (表达式)/ 函数名 (形参表) 左到右 – . 成员选择 （对象） 对象.成员名 左到右 – -&gt; 成员选择 （指针） 对象指针-&gt;成员名 左到右 – 2 - 负号运算符 -表达式 右到左 单目 ~ 按位取反运算符 ~表达式 右到左 单目 ++ 自增运算符 ++变量名/变量名++ 右到左 单目 – 自减运算符 –变量名/变量名– 右到左 单目 ***** 取值运算符 指针变量 右到左 单目 &amp; 取地址运算符 &amp;变量名 右到左 单目 ! 逻辑非运算符 !表达式 右到左 单目 （类型名） 强制类型转换 (数据类型)表达式 右到左 – sizeof 长度运算符 sizeof(表达式) 右到左 – 3 / 除 表达式/表达式 左到右 双目 * 乘 表达式*表达式 左到右 双目 % 余数（取模） 整型%整型 左到右 双目 4 + 加 表达式+表达式 左到右 双目 - 减 表达式-表达式 左到右 双目 5 &lt;&lt; 左移 变量&lt;&lt;表达式 左到右 双目 &gt;&gt; 右移 变量&gt;&gt;表达式 左到右 双目 6 *&gt;* 大于 表达式&gt;表达式 左到右 双目 &gt;= 大于等于 表达式&gt;=表达式 左到右 双目 &lt; 小于 表达式&lt;表达式 左到右 双目 &lt;= 小于等于 表达式&lt;=表达式 左到右 双目 7 == 等于 表达式==表达式 左到右 双目 != 不等于 表达式!= 表达式 左到右 双目 8 &amp; 按位与 表达式&amp;表达式 左到右 双目 ^ 按位异或 表达式^表达式 左到右 双目 | 按位或 表达式|表达式 左到右 双目 &amp;&amp; 逻辑与 表达式&amp;&amp;表达式 左到右 双目 || 逻辑或 表达式||表达式 左到右 双目 ?: 条件运算符 表达式1?表达式2: 表达式3 右到左 三目 9 = 赋值运算符 变量=表达式 右到左 – /= 除后赋值 变量/=表达式 右到左 – *= 乘后赋值 变量*=表达式 右到左 – %= 取模后赋值 变量%=表达式 右到左 – += 加后赋值 变量+=表达式 右到左 – -= 减后赋值 变量-=表达式 右到左 – &lt;&lt;= 左移后赋值 变量&lt;&lt;=表达式 右到左 – &gt;&gt;= 右移后赋值 变量&gt;&gt;=表达式 右到左 – &amp;= 按位与后赋值 变量&amp;=表达式 右到左 – ^= 按位异或后赋值 变量^=表达式 右到左 – |= 按位或后赋值 变量|=表达式 右到左 – 10 ， 逗号运算符 表达式,表达式,… 左到右 – 二十三、文件输入/输出 a.基本知识 C语言文件模式 C语言提供两种文件模式：文本模式和二进制模式。 C语言提供两种访问文件的途径：文本模式和二进制模式。 保存文件地址的指针 使用关键字 FILE 声明指针，并一般用fopen()函数对其初始化 例如可以用下面的方式定义一个文件指针变量： 12FILE * fp;fp = fopen(&quot;HelloWorld.txt&quot;,&quot;r&quot;); 指向标准文件的指针 标准文件 文件指针 通常使用的设备 标准输入 stdin 键盘 标准输出 stdout 显示器 错误输出 stderr 显示器 b.与文件操作有关的函数 fopen() 功能：打开文件 参数：1.待打开文件名称（字符串首地址）2.fopen（）模式字符串 返回值：成功返回文件时，返回文件指针 fopen()模式字符串 fclose() 功能：关闭文件 参数：待关闭文件地址 返回值：如果成功关闭，返回0；否则返回EOF getc()与putc() 12char ch;ch = getc(fp); 这条语句的意思是从fp指定的文件中获取一个字符。 1putc(ch,fpout); 这条语句的意思是把字符 ch 放入 FILE 指针 fpout 指定的文件中。 fprintf()与fscanf() 文件I/O函数 fprintf() 与 fscanf() 与 printf() 与 scanf()函数工作方式类似，不同的是，前者需要用第一个参数指定待处理的文件。 fgets()与fputs() 1234567fgets(ch,LEN,fp);/*目的：将从fp指向的文件中读取LEN大小的字符串存储在ch字符串数组中第一个参数代表存储输入位置的字符串数组地址第二个参数代表待输入字符串的大小第三个参数是文件指针，指定待读取的文件*/ 123456fputs(ch,fp);/*目的：将ch字符串数组中存储的字符串写入fp指向的文件中第一个参数是存储字符串数组的地址第二个参数是待写入文件的文件指针*/ fseek()与ftell() fseek()与ftell()函数用法（了解） ungetc() 亲测好用 把 ch 指定的字符放回输入流以供下次调用输入函数时将读取该字符： 例： c语言输入一行未知个数字符，获取其中的数字并存入数组 问题背景： 1.对于任意输入的一串字符串如何高效地取出指定的部分； 2.对于整形或浮点型数组而未知输入个数之时，如何及时输入与终止； 3.如何让录入的数据重新回到输入流 所需函数： &lt;ctybe.h&gt; isdigit：判断是否为十进制数，是返回非0，否则返回0； &lt;stdio.h&gt; ungetc(c,stdin)：将c中的数据返回输入流； 完整代码见下： 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;int main()&#123; int a[1000]; char c; int i = 0, n = 0; while((c = getchar())!= &#x27;\\n&#x27;) &#123; if(isdigit(c)) &#123; ungetc(c,stdin);//将c送回输入流 scanf(&quot;%d&quot;,&amp;a[n++]); &#125; &#125; for(i = 0;i &lt; n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125; 二进制 I/O fread() 函数用于读取二进制文件 fwrite() 函数用于写入二进制文件 ​","categories":[{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://ckblogs.cn/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"知识点总结","slug":"知识点总结","permalink":"http://ckblogs.cn/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"name":"期末复习","slug":"期末复习","permalink":"http://ckblogs.cn/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}]},{"title":"灰色预测模型","slug":"灰色预测模型","date":"2021-08-01T15:27:29.000Z","updated":"2021-09-26T03:14:21.368Z","comments":true,"path":"2021/08/01/灰色预测模型/","link":"","permalink":"http://ckblogs.cn/2021/08/01/%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"灰色预测模型 [TOC] 模型基本介绍 灰色预测模型是通过少量的、不完全的信息，建立数学模型做出预测的一种预测方法。 基于客观事物的过去和现在的发展规律，借助于科学的方法对未来的发展趋势和状况进行描述和分析，并形成科学的假设和判断。 对于时间序列短，统计数据少，信息不完全系统的分析与建模，具有独特的功效 既含有已知信息又含有未知信息的系统：灰色系统 完全已知：白色系统 完全位置：黑色系统 下面将介绍有关模型的几个相关概念 灰色生成数列 将原始数据列中的数据，按某种要求作数据处理称为生成。 灰色系统理论认为，尽管客观表象复杂，但总是有整体功能的，因此必然蕴含某种内在规律。关键在于如何选择适当的方式去挖掘和利用它。灰色系统时通过对原始数据的整理来寻求其变化规律的，这是一种就数据寻求数据的现实规律的途径，也就是灰色序列的生成。一切灰色序列都能通过某种生成弱化其随机性，显现其规律性。 常用的灰色系统生成方式有: （1）累加生成 （2）累减生成 （3）均值生成 （4）级比生成 累加生成 累加生成，即通过数列间各时刻数据的依个累加以得到新的数据与数列.累加前的数列称原始数列，累加后的数列称为生成数列.累加生成是使灰色过程由灰变白的一种方法，它在灰色系统理论中占有极其重要地位，通过累加生成可以看出灰量积累过程的发展态势,使离乱的原始数据中蕴含的积分特性或规律加以显化.累加生成是对原始数据列中各时刻的数据依次累加，从而生成新的序列的一种手段. 记原始序列为： X(0)=(x(0)(1),x(0)(2),…….,x(0)(n))X^{(0)}=\\left(x^{(0)}(1), x^{(0)}(2), \\ldots \\ldots ., x^{(0)}(n)\\right) X(0)=(x(0)(1),x(0)(2),…….,x(0)(n)) 一次累加生成序列为: X(1)=(x(1)(1),x(1)(2),…….,x(1)(n))X^{(1)}=\\left(x^{(1)}(1), x^{(1)}(2), \\ldots \\ldots ., x^{(1)}(n)\\right) X(1)=(x(1)(1),x(1)(2),…….,x(1)(n)) 其中: x(1)(k)=∑i=0kx(0)(i)=x(1)(k−1)+x(0)(k)x^{(1)}(k)=\\sum_{i=0}^{k} x^{(0)}(i)=x^{(1)}(k-1)+x^{(0)}(k) x(1)(k)=i=0∑k​x(0)(i)=x(1)(k−1)+x(0)(k) 举例： 累减生成 累减生成数实质是累加生成数的逆运算。 记原始序列为： X(1)=(x(1)(1),x(1)(2),……,x(1)(n))X^{(1)}=\\left(x^{(1)}(1), x^{(1)}(2), \\ldots \\ldots, x^{(1)}(n)\\right) X(1)=(x(1)(1),x(1)(2),……,x(1)(n)) 一次累减生成序列 1-IAGO: X(0)=(x(0)(1),x(0)(2),……,x(0)(n))X^{(0)}=\\left(x^{(0)}(1), x^{(0)}(2), \\ldots \\ldots, x^{(0)}(n)\\right) X(0)=(x(0)(1),x(0)(2),……,x(0)(n)) 其中: x(0)(k)=x(1)(k)+x(1)(k−1),k=2,3,……,nx^{(0)}(k)=x^{(1)}(k)+x^{(1)}(k-1), \\quad k=2,3, \\ldots \\ldots, n x(0)(k)=x(1)(k)+x(1)(k−1),k=2,3,……,n 邻值生成 令 Z(1)\\mathrm{Z}^{(1)}Z(1) 为 X(1)\\mathrm{X}^{(1)}X(1) 的紧邻均值 MEAN生成序列: Z(1)=(z(1)(2),z(1)(3),…….,z(1)(n))Z^{(1)}=\\left(z^{(1)}(2), z^{(1)}(3), \\ldots \\ldots ., z^{(1)}(n)\\right) Z(1)=(z(1)(2),z(1)(3),…….,z(1)(n)) 其中: z(1)(k)=αx(1)(k)+(1−α)x(1)(k−1),k=2,3,……,nz^{(1)}(k)=\\alpha x^{(1)}(k)+(1-\\alpha) x^{(1)}(k-1), \\quad k=2,3, \\ldots \\ldots, n z(1)(k)=αx(1)(k)+(1−α)x(1)(k−1),k=2,3,……,n α\\alphaα 为生成系数，取0.5时，称生成的数列为均值生成数，也称等权邻值生成数。 GM（1，1）模型 GM （1,1） 模型是灰色系统理论中应用最广泛的一种灰色动态预测模型，该模型由一个单变量的一阶微分方程构成。 它主要用于复杂系统某一主导因素特征值的拟合和预测，以揭示主导因素变化规律和未来发展变化态势。 其中 G 代表 “Grey” M代表 “Model” （1，1）代表 1 阶方程 1 个变量 灰微分方程模型 定义灰导数： d(k)=x(0)(k)=x(1)(k)−x(1)(k−1)d(k)=x^{(0)}(k)=x^{(1)}(k)-x^{(1)}(k-1) d(k)=x(0)(k)=x(1)(k)−x(1)(k−1) 这里 x(0)(k)k=1,2,...,3x^{(0)}(k)\\qquad k=1,2,...,3x(0)(k)k=1,2,...,3 为原始数列 这里 x(1)(k)k=1,2,...,3x^{(1)}(k)\\qquad k=1,2,...,3x(1)(k)k=1,2,...,3 为累加生成数列（见上文） 结合邻值生成序列，定义 GM(1,1)\\mathrm{GM}(1,1)GM(1,1) 灰微分方程模型为： x(0)(k)+az(1)(k)=bx^{(0)}(k)+a z^{(1)}(k)=b x(0)(k)+az(1)(k)=b 或 d(k)+az(1)(k)=bd(k)+a z^{(1)}(k)=b d(k)+az(1)(k)=b 这里 z(1)(k)k=1,2,...,3z^{(1)}(k)\\qquad k=1,2,...,3z(1)(k)k=1,2,...,3 为邻值生成数列（见上文） 其中, a称为发展系数, z(1)(k)\\mathrm{z}^{(1)}(\\mathrm{k})z(1)(k) 称为白化背景值, b\\mathrm{b}b 称为灰作用量。 现 x(0)、z(1)(k)x^{(0)} 、 z^{(1)}(k)x(0)、z(1)(k) 为已知量, a、ba 、ba、b 待求解， 故将 k=2,3,…,nk=2,3, \\ldots, \\mathrm{n}k=2,3,…,n 待入， 可得到矩阵方程 {x(0)(2)+az(1)(2)=b,x(0)(3)+az(1)(3)=b……,x(0)(n)+az(1)(n)=b\\left\\{\\begin{array}{l} x^{(0)}(2)+a z^{(1)}(2)=b, \\\\ x^{(0)}(3)+a z^{(1)}(3)=b \\\\ \\ldots \\ldots, \\\\ x^{(0)}(n)+a z^{(1)}(n)=b \\end{array}\\right. ⎩⎪⎪⎪⎨⎪⎪⎪⎧​x(0)(2)+az(1)(2)=b,x(0)(3)+az(1)(3)=b……,x(0)(n)+az(1)(n)=b​ 稍做转换： {x(0)(2)=−az(1)(2)+b,x(0)(3)=−az(1)(3)+b,……,x(0)(n)=−az(1)(n)+b\\left\\{\\begin{array}{l} x^{(0)}(2)=-a z^{(1)}(2)+b, \\\\ x^{(0)}(3)=-a z^{(1)}(3)+b, \\\\ \\ldots \\ldots, \\\\ x^{(0)}(n)=-a z^{(1)}(n)+b \\end{array}\\right. ⎩⎪⎪⎪⎨⎪⎪⎪⎧​x(0)(2)=−az(1)(2)+b,x(0)(3)=−az(1)(3)+b,……,x(0)(n)=−az(1)(n)+b​ 令: u=[ab]Y=[x(0)(2)x(0)(3)……x(0)(n)]B=[−z(1)(2)1−z(1)(3)1⋯⋯−z(1)(n)1]\\begin{gathered} u=\\left[\\begin{array}{l} a \\\\ b \\end{array}\\right] \\\\ Y=\\left[\\begin{array}{c} x^{(0)}(2) \\\\ x^{(0)}(3) \\\\ \\ldots \\ldots \\\\ x^{(0)}(n) \\end{array}\\right] \\\\ B=\\left[\\begin{array}{cc} -z^{(1)}(2) &amp; 1 \\\\ -z^{(1)}(3) &amp; 1 \\\\ \\cdots \\cdots &amp; \\\\ -z^{(1)}(n) &amp; 1 \\end{array}\\right] \\end{gathered} u=[ab​]Y=⎣⎢⎢⎢⎡​x(0)(2)x(0)(3)……x(0)(n)​⎦⎥⎥⎥⎤​B=⎣⎢⎢⎢⎡​−z(1)(2)−z(1)(3)⋯⋯−z(1)(n)​111​⎦⎥⎥⎥⎤​​ 此时, GM(1,1)\\mathrm{GM}(1,1)GM(1,1) 模型转化为 Bu=YBu=YBu=Y, 利用矩阵运算， 解得： u=YB−1u=YB^{-1}u=YB−1. 白化方程模型 定义：对于$ GM(1，1)$的灰微分方程，如果将时刻 k=2,3,…,nk=2,3,…,nk=2,3,…,n 视为连续变量 ttt，则之前的$ x(1) 视为时间t函数，于是灰导数视为时间t函数，于是灰导数视为时间t函数，于是灰导数x^{(0)}(k)变为连续函数的导数变为连续函数的导数变为连续函数的导数\\cfrac{dx(1)}{dt}，白化背景值，白化背景值，白化背景值z^{(1)}(k)对应于导数对应于导数对应于导数x^{(1)}(t)$。于是 GM（1，1）的灰微分方程对应于的白微分方程为： dx(1)(t)dt+ax(1)(t)=b\\frac{d x^{(1)}(t)}{d t}+a x^{(1)}(t)=b dtdx(1)(t)​+ax(1)(t)=b 解为： x(1)(t)=(x(0)(1)−ba)e−a(t−1)+bax^{(1)}(t)=\\left(x^{(0)}(1)-\\frac{b}{a}\\right) e^{-a(t-1)}+\\frac{b}{a} x(1)(t)=(x(0)(1)−ab​)e−a(t−1)+ab​ 注意：此处得到的解为累加数列，后续需要将其转化为累减数列 灰微分方程模型与白化方程模型的区别是什么？ 灰微分方程里的初始序列 x(0)(k)x^{(0)}(k)x(0)(k) 是离散的，白化方程里的初始序列是连续的。 详见 灰色系统理论里白化方程的&quot;白化&quot;两个字是什么意思？ 而在正确使用这个模型的过程中，我们通过建立灰微分方程模型来求解 a ，b 并通过白化方程模型来求解 x(1)(t)x^{(1)}(t)x(1)(t) 算法步骤 1. 数据的检验与处理 为了保证GM （1,1） 建模方法的可行性，需要对已知数据做必要的检验处理。 计算数列的级比： λ(k)=x(0)(k−1)x(0)(k),k=2,3,…,n\\lambda(k)=\\frac{x^{(0)}(k-1)}{x^{(0)}(k)}, k=2,3, \\ldots, n λ(k)=x(0)(k)x(0)(k−1)​,k=2,3,…,n 通过范围: (e−2/(n+1),e2/(n+2))\\quad\\left(\\mathrm{e}^{-2 /(\\mathrm{n}+1)}, \\mathrm{e}^{2 /(\\mathrm{n}+2)}\\right)(e−2/(n+1),e2/(n+2)) 否则需要对数列作平移变换，使级比落在范围中 y(0)(k)=x(0)(k)+C,k=1,2,…,ny^{(0)}(k)=x^{(0)}(k)+C, k=1,2, \\ldots, n y(0)(k)=x(0)(k)+C,k=1,2,…,n 2. 建立模型，求出预测值 通过灰微分方程建立： x(0)(k)+az(1)(k)=bx^{(0)}(k)+a z^{(1)}(k)=b x(0)(k)+az(1)(k)=b 代入相关值求解得到 a，b。 建立白化微分方程： dx(1)(t)dt+ax(1)(t)=b\\frac{d x^{(1)}(t)}{d t}+a x^{(1)}(t)=b dtdx(1)(t)​+ax(1)(t)=b 通过对白化方程的解，进行累减，得到预测值。 x(1)(t)=(x(0)(1)−ba)e−a(t−1)+bax^(1)(k+1)=(x(0)(1)−ba)e−ak+bax^(0)(k)=x^(1)(k)+x^(1)(k−1),k=2,3,……,n\\begin{gathered} x^{(1)}(t)=\\left(x^{(0)}(1)-\\frac{b}{a}\\right) e^{-a(t-1)}+\\frac{b}{a} \\\\ \\hat{x}^{(1)}(k+1)=\\left(x^{(0)}(1)-\\frac{b}{a}\\right) e^{-a k}+\\frac{b}{a} \\\\ \\hat{x}^{(0)}(k)=\\hat{x}^{(1)}(k)+\\hat{x}^{(1)}(k-1), \\quad k=2,3, \\ldots \\ldots, n \\end{gathered} x(1)(t)=(x(0)(1)−ab​)e−a(t−1)+ab​x^(1)(k+1)=(x(0)(1)−ab​)e−ak+ab​x^(0)(k)=x^(1)(k)+x^(1)(k−1),k=2,3,……,n​ 3. 检验预测值 方法一： 方法二： 计算相对残差 ξk=x(0)(k)−x^(0)(k)x(0)(k)\\xi_{k}=\\frac{x^{(0)}(k)-\\hat{x}^{(0)}(k)}{x^{(0)}(k)} ξk​=x(0)(k)x(0)(k)−x^(0)(k)​ 若所有的 ∣ξk∣&lt;0.1\\left|\\xi_{k}\\right|&lt;0.1∣ξk​∣&lt;0.1, 则认为达到较高的要求; 若所有的 ∣ξk∣&lt;0.2\\left|\\xi_{k}\\right|&lt;0.2∣ξk​∣&lt;0.2 ， 则认为达到一般的要求。 级比偏差值检验 ρ(k)=1−1−0.5a1+0.5aλ(k)\\rho(k)=1-\\frac{1-0.5 a}{1+0.5 a} \\lambda(k) ρ(k)=1−1+0.5a1−0.5a​λ(k) 若所有的 ρ(k)∣&lt;0.1\\rho(k) \\mid&lt;0.1ρ(k)∣&lt;0.1, 则认为达到较高的要求; 若所有的 ρ(k)∣&lt;0.2\\rho(k) \\mid&lt;0.2ρ(k)∣&lt;0.2 ， 则认为达到一般的要求。 Matlab 编程实现 123456789101112131415161718192021222324252627282930313233343536373839404142%（1）输入前期的小样本数据%（2）输入预测个数%（3）运行y=input(&#x27;请输入数据&#x27;);n=length(y);yy=ones(n,1);yy(1)=y(1);for i=2:n yy(i)=yy(i-1)+y(i)endB=ones(n-1,2);for i=1:(n-1) B(i,1)=-(yy(i)+yy(i+1))/2; B(i,2)=1;endBT=B&#x27;;for j=1:(n-1) YN(j)=y(j+1);endYN=YN&#x27;;A=inv(BT*B)*BT*YN;a=A(1);u=A(2);t=u/a;t_test=input(&#x27;输入需要预测的个数&#x27;);i=1:t_test+n;yys(i+1)=(y(1)-t).*exp(-a.*i)+t;yys(1)=y(1);for j=n+t_test:-1:2 ys(j)=yys(j)-yys(j-1);endx=1:n;xs=2:n+t_test;yn=ys(2:n+t_test);plot(x,y,&#x27;^r&#x27;,xs,yn,&#x27;*-b&#x27;);det=0;for i=2:n det=det+abs(yn(i)-y(i));enddet=det/(n-1);disp([&#x27;百分绝对误差为：&#x27;,num2str(det),&#x27;%&#x27;]); disp([&#x27;预测值为：&#x27;,num2str(ys(n+1:n+t_test))]); 应用实例（重要！！） 灰色预测计算实例 **例：**北方某城市 1986～1992 年道路交通噪声平均声级数据见表，请预测后几年的平均噪声： 序号 年份 LeqL_{eq}Leq​ 序号 年份 LeqL_{eq}Leq​ 1 1986 71.1 5 1990 71.4 2 1987 72.4 6 1991 72.0 3 1988 72.4 7 1992 71.6 4 1989 72.1 解： 第一步：级比检验 建立交通噪声平均声级数据时间序列如下： x(0)=(x(0)(1),x(0)(2),⋯ ,x(0)(7))=(71.1,72.4,72.4,72.1,71.4,72.0,71.6)\\begin{aligned} x^{(0)} &amp;=\\left(x^{(0)}(1), x^{(0)}(2), \\cdots, x^{(0)}(7)\\right) \\\\ &amp;=(71.1,72.4,72.4,72.1,71.4,72.0,71.6) \\end{aligned} x(0)​=(x(0)(1),x(0)(2),⋯,x(0)(7))=(71.1,72.4,72.4,72.1,71.4,72.0,71.6)​ （1）求级比 λ(k)\\lambda(k)λ(k) λ(k)=x(0)(k−1)x(0)(k)\\lambda(k)=\\frac{x^{(0)}(k-1)}{x^{(0)}(k)} λ(k)=x(0)(k)x(0)(k−1)​ λ=(λ(2),λ(3),⋯ ,λ(7))=(0.982,1,1.0042,1.0098,0.9917,1.0056)\\begin{aligned} \\lambda &amp;=(\\lambda(2), \\lambda(3), \\cdots, \\lambda(7)) \\\\ &amp;=(0.982,1,1.0042,1.0098,0.9917,1.0056) \\end{aligned} λ​=(λ(2),λ(3),⋯,λ(7))=(0.982,1,1.0042,1.0098,0.9917,1.0056)​ （2）级比判断 由于所有的 λ(k)∈[0.982,1.0098],k=2,3,⋯ ,7\\lambda(k) \\in[0.982,1.0098], k=2,3, \\cdots, 7λ(k)∈[0.982,1.0098],k=2,3,⋯,7, 故可以用 x(0)x^{(0)}x(0) 作满意的GM（1，1）建模。 第二步: GM（1,1） 建模 （1） 对原始数据 x(0)x^{(0)}x(0) 作一次累加，即 x(1)=(71.1,143.5,215.9,288,359.4,431.4,503)x^{(1)}=(71.1,143.5,215.9,288,359.4,431.4,503)x(1)=(71.1,143.5,215.9,288,359.4,431.4,503) （2） 构造数据矩阵 BBB 及数据向量 YYY B=[−12(x(1)(1)+x(1)(2))1−12(x(1)(2)+x(1)(3))1⋮⋮−12(x(1)(6)+x(1)(7))1],Y=[x(0)(2)x(0)(3)⋮x(0)(7)]B=\\left[\\begin{array}{cc} -\\frac{1}{2}\\left(x^{(1)}(1)+x^{(1)}(2)\\right) &amp; 1 \\\\ -\\frac{1}{2}\\left(x^{(1)}(2)+x^{(1)}(3)\\right) &amp; 1 \\\\ \\vdots &amp; \\vdots \\\\ -\\frac{1}{2}\\left(x^{(1)}(6)+x^{(1)}(7)\\right) &amp; 1 \\end{array}\\right], \\quad Y=\\left[\\begin{array}{c} x^{(0)}(2) \\\\ x^{(0)}(3) \\\\ \\vdots \\\\ x^{(0)}(7) \\end{array}\\right] B=⎣⎢⎢⎢⎢⎡​−21​(x(1)(1)+x(1)(2))−21​(x(1)(2)+x(1)(3))⋮−21​(x(1)(6)+x(1)(7))​11⋮1​⎦⎥⎥⎥⎥⎤​,Y=⎣⎢⎢⎢⎢⎡​x(0)(2)x(0)(3)⋮x(0)(7)​⎦⎥⎥⎥⎥⎤​ （3）计算 u^\\hat{u}u^ u^=(a,b)T=(BTB)−1BTY=(0.002372.6573)\\hat{u}=(a, b)^{T}=\\left(B^{T} B\\right)^{-1} B^{T} Y=\\left(\\begin{array}{l} 0.0023 \\\\ 72.6573 \\end{array}\\right) u^=(a,b)T=(BTB)−1BTY=(0.002372.6573​) 于是得到 a=0.0023,b=72.6573a=0.0023, b=72.6573a=0.0023,b=72.6573 。 （4）建立模型 dx(1)dt+0.0023x(1)=72.6573\\frac{d x^{(1)}}{d t}+0.0023 x^{(1)}=72.6573 dtdx(1)​+0.0023x(1)=72.6573 求解得 x(1)(k+1)=(x(0)(1)−ba)e−ak+ba=−30929e−0.0023k+31000x^{(1)}(k+1)=\\left(x^{(0)}(1)-\\frac{b}{a}\\right) e^{-a k}+\\frac{b}{a}=-30929 e^{-0.0023 k}+31000 x(1)(k+1)=(x(0)(1)−ab​)e−ak+ab​=−30929e−0.0023k+31000 （5） 求生成数列预测值 x^(1)(k+1)\\hat{x}^{(1)}(k+1)x^(1)(k+1) 及模型还原值 x^(0)(k+1)\\hat{x}^{(0)}(k+1)x^(0)(k+1) : 令 k=1,2,3,4,5,6k=1,2,3,4,5,6k=1,2,3,4,5,6, 由上面的时间响应函数可算得 x^(1)\\hat{x}^{(1)}x^(1), 其中取 x^(1)(1)=x^(0)(1)=x(0)(1)=71.1 由 x^(0)(k)=x^(1)(k)−x^(1)(k−1), 取 k=2,3,4,⋯ ,7, 得 x^(0)=(x^(0)(1),x^(0)(2),⋯ ,x^(0)(7))=(71.1,72.4,72.2,72.1,71.9,71.7,71.6)\\begin{aligned} &amp;\\hat{x}^{(1)}(1)=\\hat{x}^{(0)}(1)=x^{(0)}(1)=71.1\\\\ &amp;\\text { 由 } \\hat{x}^{(0)}(k)=\\hat{x}^{(1)}(k)-\\hat{x}^{(1)}(k-1), \\text { 取 } k=2,3,4, \\cdots, 7, \\text { 得 }\\\\ &amp;\\hat{x}^{(0)}=\\left(\\hat{x}^{(0)}(1), \\hat{x}^{(0)}(2), \\cdots, \\hat{x}^{(0)}(7)\\right)=(71.1,72.4,72.2,72.1,71.9,71.7,71.6) \\end{aligned} ​x^(1)(1)=x^(0)(1)=x(0)(1)=71.1 由 x^(0)(k)=x^(1)(k)−x^(1)(k−1), 取 k=2,3,4,⋯,7, 得 x^(0)=(x^(0)(1),x^(0)(2),⋯,x^(0)(7))=(71.1,72.4,72.2,72.1,71.9,71.7,71.6)​ 第三步：模型检验 模型检验结果见下表： 经检验符合标准。 灾变预测 给定原始数据列 x(0)=(x(0)(1),x(0)(2),⋯ ,x(0)(n))x^{(0)}=\\left(x^{(0)}(1), x^{(0)}(2), \\cdots, x^{(0)}(n)\\right)x(0)=(x(0)(1),x(0)(2),⋯,x(0)(n)) 。 如果指定某个定值 ζ\\zetaζ, 并认 为 x(0)x^{(0)}x(0) 中那些大于 ζ\\zetaζ 的点为具有异常值的点，然后将这些数据挑出来另组一数列，则 称这一数列为上限灾变数列。例如，给定数列 x(0)=(3,0.7,8,5)x^{(0)}=(3,0.7,8,5)x(0)=(3,0.7,8,5), 若取 ζ=1\\zeta=1ζ=1, 则其上 限灾变数列为 xζ0=(3,8,5)x_{\\zeta}^{0}=(3,8,5) xζ0​=(3,8,5) 同理, 可定义下限灾变数列这个概念。注意，灾变预测不是预测数据本身的大小, 而是预测异常值出现的时间。我们考虑下面这个问题。 例： 某地区年均降雨量数据如表所示 。规定 ζ=320\\zeta = 320ζ=320 ，并认为 x(0)(i)≤ζx^{(0)}(i) \\le \\zetax(0)(i)≤ζ 为旱灾。预测下一次旱灾发生的时间。 解： 写出初始数列 x(0)=(390.6,412,320,559.2,380.8,542.4,553,310,561,300,632,540,406.2,313.8,576,587.6,318.5)\\begin{gathered} x^{(0)}=(390.6,412,320,559.2,380.8,542.4,553,310,561,300,632, \\\\ 540,406.2,313.8,576,587.6,318.5) \\end{gathered} x(0)=(390.6,412,320,559.2,380.8,542.4,553,310,561,300,632,540,406.2,313.8,576,587.6,318.5)​ 由于满足 x(0)(i)≤320x^{(0)}(i) \\leq 320x(0)(i)≤320 的 x(0)(i)x^{(0)}(i)x(0)(i) 即为异常值, 易得下限灾变数列为 xζ0=(320,310,300,313.8,318.5)x_{\\zeta}^{0}=(320,310,300,313.8,318.5) xζ0​=(320,310,300,313.8,318.5) 其对应的时刻数列为 t=(3,8,10,14,17)t=(3,8,10,14,17) t=(3,8,10,14,17) 将数列 ttt 做 1 次累加，得 t(1)=(3,11,21,35,52)t^{(1)}=(3,11,21,35,52) t(1)=(3,11,21,35,52) 建立 GM(1,1)\\mathrm{GM}(1,1)GM(1,1) 模型，得 u^=(a,b)T=(−0.2536,6.2585)t^(1)(k+1)=27.6774e0.2536k−24.6774\\begin{aligned} &amp;\\hat{u}=(a, b)^{T}=(-0.2536,6.2585) \\\\ &amp;\\hat{t}^{(1)}(k+1)=27.6774 e^{0.2536 k}-24.6774 \\end{aligned} ​u^=(a,b)T=(−0.2536,6.2585)t^(1)(k+1)=27.6774e0.2536k−24.6774​ 通过上式, 预测到第 6 个及第 7 个数据为 t(0)(6)=22.034,t(0)(7)=28.3946t^{(0)}(6)=22.034, \\quad t^{(0)}(7)=28.3946 t(0)(6)=22.034,t(0)(7)=28.3946 由于 22.03422.03422.034 与 17 相差 5.0345.0345.034, 这表明下一次旱灾将发生在五年以后。 模型评价 模型优点： 所需建模信息少 运算方便 建模精度高 模型缺点： 对非线性数据样本预测效果差。 据了解，灰色系统 (Grey System)理论 是我国著名学者邓聚龙教授 20 世纪 80 年代初创立的一种兼备软硬科学特性的新理论。然而，在美国数学建模大赛中，基本不承认此模型，故需要回避使用。 参考博文及文献 【数学建模】灰色预测模型GM(1，1)附例题分析(MATLAB实现) 【数学建模】灰色预测模型（预测） 【数学建模】灰色预测模型 灰色预测模型 《数学建模算法与应用》------司守奎","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"灰色预测","slug":"灰色预测","permalink":"http://ckblogs.cn/tags/%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B/"},{"name":"预测类算法","slug":"预测类算法","permalink":"http://ckblogs.cn/tags/%E9%A2%84%E6%B5%8B%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"2021暑假至微支教总结","slug":"支教总结","date":"2021-07-26T08:11:42.000Z","updated":"2021-09-26T03:13:38.820Z","comments":true,"path":"2021/07/26/支教总结/","link":"","permalink":"http://ckblogs.cn/2021/07/26/%E6%94%AF%E6%95%99%E6%80%BB%E7%BB%93/","excerpt":"","text":"2021暑假至微支教总结 2021.07.26 陈坤 前言 小时候，我很想当一名老师，一是觉得老师很厉害，所有的同学都得听老师的话；二是我很喜欢给同学讲题，尤其是给他讲明白了以后看到其“敬佩的目光”。六年前初一的暑假，一群来自不同大学的哥哥姐姐们，来到了我的母校，在接下来的一个星期里，带领包括我所在的一个班的同学，一起感受世界的魅力。 那个组织是YAPM (又称“芽盼”)中文全称民族未来文化传承人培养计划，隶属于北京大学科技教育交流协会，是一个致力于传承保护少数民族文化的公益项目。 这些一件件小事情就像一颗颗小种子，在我的心中发芽结果，当我得知成电的暑假支教活动时，毅然决然选择了参加！实现自己的心愿，更为了把曾经那份照在我身上的公益之光传下去。 一直以来，我在这次支教中对自己的要求就是，把支教做的纯粹些，这不是让我来体验生活的。纯粹的支教就是要去切身实际的为那些孩子们着想，想想他们需要什么，想想自己能为他们带来些什么，想想经过这几天的支教，又能改变什么。 授课 支教很快就开始了，我的身份，首先是一名授课老师。在选择课程时，我选择了一门“数学思维游戏与数学悖论”，针对这门课，我想让孩子们感受到学数学的快乐，感受到数学的神奇与奥妙，感受到数学的魅力所在，如果能让他们通过这几节课爱上数学，那将是我最大的成功。 一二年级数学思维课程：一笔画与数独 事实上，他们确实爱上这节课，与我想象的相同，孩子们很愿意去参与到课堂中来，也很愿意去探索游戏背后的数学知识，他们也有很多的奇思妙想，甚至有些我都没有想到，如此一来，我上课的兴趣就更加浓厚了，也更愿意把我所学的，把我所了解的都介绍给他们，都与他们一起分享。 另一门课程是“乒乓球”，作为中国的国球，中国从来不缺少会打乒乓球的人，高手如云这句话一点都不假。在四五六年级这些高年级的男生里，有太多太多隐藏的乒乓球高手，他们一下课就来找我切磋，上乒乓球课时也常常要跟我一比高下，说实话，在同样的年级下，我肯定打不过他们，如此一来，我不但更加钦佩他们的乒乓球技术，也对中国未来的乒乓球事业感到莫大的自信！ 刚下过雨后打乒乓球的少年 班级建设 除了一名授课老师外，我更重要的一个身份是一名二年级班主任。以前，常常听到我的班主任说到：“我把你们当作我的孩子一样来看待“。听到这句话时，当时我内心并没有太大的触碰，但当我成为一名班主任，我真真切切感受到这句话的真实性。尤其是作为一群这样天真可爱活泼孩子的班主任，每天早上起来早早到教室与他们交流玩耍，每天放学亲眼目送他们回家。每次从窗边走过，总是会不自禁地往里面瞅两眼，顺便拍张照。当然，不可避免地要去处理一些孩子们的内部矛盾。作为班主任，更重要的是要团结同学，并且要让每一个孩子拥有集体荣誉感。 于是，在班级建设方面，我不断去寻找这样的班级小游戏，想要带领全班同学从小建立正确的价值观念，这比学习成绩重要得多。 班主任安排课上与孩子们做的游戏 让我很高兴的是，他们没有辜负我的希望，他们上课最听话，最认真！运动会上为了班级荣誉洒下汗水，甚至多个项目超过了三年级！文艺汇演每个同学都很认真，不愿意为班级拖后腿。我教他们的同时，他们也在教我。我很庆幸有这么一帮可爱的孩子们！ 运动会上的拼搏！ 课下生活 除了课堂上的生活，支教中的课下生活也很值得咀嚼一番。买菜，切菜，做饭，洗碗这个我本看来很容易的事情，真的没有想象中那么简单，买菜要记得价钱，要挑新鲜的；切菜要小心割手更要注意切菜的形状；做饭要换着花样，更要注意饭量与口感；洗碗要把碗洗干净，同时还要注意收拾整理厨房。每一项都不简单，但每一样都得做好。真正经历过这些，才发现那数十年如一日为我做饭的亲人们有多不容易啊，同时也为这几天了每一位辛勤工作的同学们点赞！每一顿饭都很香！ 具有“陕西特色”的蛋炒饭和一群干饭人！ 尾声 终究是要分别，终究还是要离开，看到同学们的恋恋不舍，直到我们离开还在大巴车后与我们告别，看到第二天我的这群孩子们加了我的QQ，与我打电话说他们的日常。我觉得这至少证明了，我们在这的这几天是让他们开心快乐的几天。 希望我们的出现能带给他们哪怕一点点对广阔世界探索的雄心，希望我们的出现能为他的日常所思所想带来哪怕一点点帮助，希望我们的出现能让他们永远记得我们相处这十七天！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（十一）","slug":"2021 暑假支教日志（十一）","date":"2021-07-19T08:11:42.000Z","updated":"2021-08-13T17:10:11.955Z","comments":true,"path":"2021/07/19/2021 暑假支教日志（十一）/","link":"","permalink":"http://ckblogs.cn/2021/07/19/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（十一） 2021.07.19 陈坤 家庭教育 今天最大的感悟，就是一个良好的家庭教育对一个人有多么大的影响。今天的主角是他——林欢，我对这个小男孩的印象特别深刻，因为他是我来支教见到的第一位小同学。我总能看到他整洁的衣服，精神的面貌，睿智的目光，机敏的动作，文雅的谈吐都让我觉得他是一个与众不同的人啊。 事实证明既是如此，当我第一次在上课就能感觉到他的不同：敏锐的目光，上课时的专注，回答问题时巧妙的思维。都让我对这位二年级小男孩惊叹不已。 做一个“抢数”的小游戏，五年级全班都没人能够发现的秘籍，他玩过一次就发现了。 他也是一个象棋高手，而他的同龄人还不知道象棋该怎么打。 手语里，课堂上最靓的仔就是他！ 当我得知，他与六年级的另外一位非常聪明的林雷是亲兄弟，我就想啊，一个良好的家庭教育，是多么的重要！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（十）","slug":"2021 暑假支教日志（十）","date":"2021-07-18T08:11:42.000Z","updated":"2021-08-13T17:10:31.425Z","comments":true,"path":"2021/07/18/2021 暑假支教日志（十）/","link":"","permalink":"http://ckblogs.cn/2021/07/18/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E5%8D%81%EF%BC%89/","excerpt":"","text":"暑假支教日志（十） 2021.07.18 陈坤 还有最后的两天课，最后的四天的时间，支教生活就要结束了，想想来还是很快的，这十天发生了什么，这十天带给孩子们什么知识，或者带给他们什么收获？接下来的四天内，我还能带给他们什么？我想并不是说我还能带给他什么，而是我还能做什么。我觉得，有一天算一天，不要说四天做什么，而要说我们要尽可能地带给他们更多的关系，更多的关爱，更多的知识。 阳光从窗外直射进来，照在了孩子们的脸上，我觉得让他们多一点扩展，多一点乐趣，多一点知识，真的很有意义啊！ 苏老师的手语课 李老师的电子琴课 其实看到他们这么多的资源，有这么多的电子琴，说实话，比我们小学还要丰富一些。但是更重要的是如何去合理正确的使用他们，而不是放着这些东西去生灰，也是很重要的一个问题。看到他们一脸新奇的玩着电子琴，想到说不定未来这间十个人的小教室里诞生一位钢琴家，那是多么荣耀的一件事呀。 哈哈哈，今天和三年级小朋友玩的游戏，吴老师哭晕在厕所！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（九）","slug":"2021 暑假支教日志（九）","date":"2021-07-17T08:11:42.000Z","updated":"2021-08-13T16:48:15.360Z","comments":true,"path":"2021/07/17/2021 暑假支教日志（九）/","link":"","permalink":"http://ckblogs.cn/2021/07/17/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E4%B9%9D%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（九） 2021.07.17 陈坤 日常杂记 小男孩的快乐 上课前，看到男孩子们搭起了自己的堡垒，秘密地开始自己的小游戏，看他们一个个玩得多高兴啊。看到他们玩得这么高兴，不自禁地我也想到了我小时候，也喜欢像他们那样搭一个“小房子”，不知道为什么，可能这就是男孩子们的快乐吧。 但其实想想，如果是他们真正的老师，或者家长来的话，肯定少不了一顿指责，然后把他们赶出来，臭骂一顿，这对他们来说，少的可能不止是这一个快乐的中午，更损失了一下午的好心情。 在不违背原则的前提下，大胆让孩子们去玩，去造，更要让他们敢玩，敢造。 你玩过橡皮泥吗？ 从初中、高中到大学，发现自己已经很少去玩甚至碰这些小玩意呀，今天看到我们班同学拿来玩橡皮泥，我发现与我当时的小学不同，这里的孩子更愿意分享，一盒橡皮泥，它的主人很愿意与其他同学一起玩，甚至允许他们“胡造”。另外我发现他们真的很有创意，比如说，孔芮惜小同学想要用不同颜色的“粉笔磨子”来改换橡皮泥的颜色，“李世豪”小同学，把橡皮泥做饺子皮还有模有样的。 所以我相信，一昧地读书与学习对孩子来说并不完全是有益的，适当的玩耍与休息，不仅能让孩子们交到更多的朋友，也同样能让孩子们更具有想象力和创造力！ 帮厨生活 “猜猜我是谁？”——“蛋炒饭！” 这两天，我变成了厨房的常客。作为一个做饭小白，其实对厨房的二三事还是很好奇的。这几次的帮厨经历让我越来越感谢我妈，还有那些一直为我做饭的亲人们！首先，做菜真不是一件容易的事情，而他们一做就是数十年，想想来也真不容易，要是换做我，又能天天做饭做多长时间呢呀？另外就是之前让我帮忙做的一些厨房小工，让我这个小白并不是完全小白啊！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（八）","slug":"2021 暑假支教日志（八）","date":"2021-07-16T08:11:42.000Z","updated":"2021-08-13T16:46:00.018Z","comments":true,"path":"2021/07/16/2021 暑假支教日志（八）/","link":"","permalink":"http://ckblogs.cn/2021/07/16/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E5%85%AB%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（八） 2021.7.16 —— 陈坤 爱看书的孩子们 读书是一件好事，从小爱上读书，更是一件对你一生都有意义的事情，当然，我很愿意看到他们在读书，他们也真的很爱读书，可能当前在他们眼里，看书看的是书本中的画吧。但是这又如何呢？让他们去读书吧，自由的徜徉在书的海洋中去吧，这又何不是一件好事呢？ 中国永远不缺会打乒乓球的人 这就是我的最大感触，啊，是啊，虽然他们才五年级，虽然他们才是个小学生，没有自己的拍子，没有经过专业的训练，甚至没有专门的乒乓球老师，但是他们的乒乓球能力确实是很强大。一方面我想说，确实，中国永远不缺打乒乓球的人，另一方面我也想说，是啊，每一个孩子都有自己的优点啊，我们应该善于去挖掘他们的优点，好的地方咱们就应该表扬！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（七）","slug":"2021 暑假支教日志（七）","date":"2021-07-15T08:11:42.000Z","updated":"2021-08-13T16:45:49.705Z","comments":true,"path":"2021/07/15/2021 暑假支教日志（七）/","link":"","permalink":"http://ckblogs.cn/2021/07/15/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（七） 2021.07.15 陈坤 一件棘手的事 不知不觉，支教的时间过去了一半，我与这群小孩子已经相处了一周的时间了，作为二年级班主任，我本自认为非常了解清楚二年级这十位小孩子。他们每一位我都可以在很快的时间内说出他/她的名字，也可以清楚的大概知道他们每一位的性格特点，哪一位爱说话很活泼，哪一位有点内向不愿意说话。我深深为自己班的这群孩子所骄傲，因为他们是所有代课老师喜欢的，常常夸奖的班级的一份子，我也常常感觉到自己很幸运成为他们的班主任。 全家福（少了我！） 我们班的四位小仙女，今天的故事就从他们讲起。 上文说到，本以为自己已经很了解他们，但事实却让我啪啪打脸。不，我并不了解他们。虽然他们都是二年级的小孩子，但不可否认的是，与四五岁的小孩不同，二年级小孩有了自己的看法,甚至有了自己的小圈子。今天发生的一位小女孩被孤立的事情，我相信这不是发生了一天两天了，而是长时间的积累造成的影响。如何让他们团结的成为一个集体，这是一个需要动脑筋的事情，但更要注意一些细节。 首先，我们一定要注意平等地对待每一位同学，虽然一碗水很难端平，但不能让这碗水倾斜到豁出来。更要注意着在同学面前的言行啊。 其次，我们在日常生活中要注意孩子们日常的细节，注意他们的心情，注意他们的言行，要及时针对不同学生的情况合理调整自己对同学们的态度啊。 最后，我们要用聪明的方式去处理这些同学间的关系，比如做一些同学间团结的小游戏，让大家一起分享一些有趣的故事，这该如何去做，我觉得这是自己的使命和任务！ 矛盾常发生，但我相信没有解不开的结，我相信我能帮他们化干戈为玉帛！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（六）","slug":"2021 暑假支教日志（六）","date":"2021-07-14T08:11:42.000Z","updated":"2021-08-13T16:45:18.605Z","comments":true,"path":"2021/07/14/2021 暑假支教日志（六）/","link":"","permalink":"http://ckblogs.cn/2021/07/14/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（六） 2021.07.14 陈坤 最后一课 今天，是我在五年级数学思维游戏与悖论的最后一节课，也是我的第一节结课的课，想想和五年级同学相处的时光，感觉还是很美好的，他们确实和一二年级不一样，他们个别人有手机，个别人爱在课上干其他的事，但他们同时也有着自己独特的想法和思考能力。 他们有非常爱打乒乓球的同学，经常找我借乒乓球拍一起打乒乓球；他们有非常爱数学的同学，上课总坐第一排回答我的问题；他们也有很皮的同学，在桌子上涂满了胶棒糊的满手都是。。。 总之，无论如何，很感谢这四天与他们的沟通与交流，也非常愿意继续与他们做朋友！ 为他们拿快递寄送的礼物，第一次坐摩的。 运动会 我忏悔，现在是北京时间十二点四十，之前的时间都在准备运动会，导致我这次的支教日志晚交并且很水。我很期待这次美妙的运动盛会，也希望运动会能够办好！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（五）","slug":"2021 暑假支教日志（五）","date":"2021-07-12T08:11:42.000Z","updated":"2021-08-13T16:44:56.018Z","comments":true,"path":"2021/07/12/2021 暑假支教日志（五）/","link":"","permalink":"http://ckblogs.cn/2021/07/12/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（五） 2021.07.12 陈坤 记录一节有意义的数学课 在我妈妈的分享中，我决定让五年级的孩子们，做一套特别的“试卷”，在做这张试卷前，我特别强调，希望大家浏览题目后再做。谁做的又快且完整，就可以获得相应的积分，但这套试卷的第二十八题，第三十题告诉你了，快速完成这套试卷的秘密： 如果这些孩子听了我的话，并且懂得浏览题目，那就能够看到这一题，事半功倍，能够少做多少冤枉题啊。 大家不出我所料，孩子们一开始都在疯狂的从头开始完成试卷，直到第一位小同学发现了试卷的秘密，高高举手完成试卷： 听清老师的话！确实很重要，对他们来说无论现在还是以后啊！ 记录和二年级孩子们的日常 虽然我在二年级这几天并没有一节课，但身为班主任，这几天接触最多的，还是与他们啊，无论是早上上课前，放学时，还是下午上课前，放学前的时光，我很愿意与他们待在一起。 乒乓球课后的快乐时光。 以前经常听我的班主任说，自己的班的同学就像是自己的孩子。现在看来，我真的很同意这句话。每天上课前，想要早早到教室去，经过二年级教室也一定要往窗里瞅一眼，听到其他老师在夸二年级的学生，真的就想自己夸自己的孩子一样，心里别提有多高兴啦。 今天，芷涵小妹妹问我“老师，什么时候能再上班会课啊？”，很高兴他们也能期望我的班会课，也期待与他们的第二次“班主任安排课”！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（四）","slug":"2021 暑假支教日志（四）","date":"2021-07-11T08:11:42.000Z","updated":"2021-08-13T16:44:47.906Z","comments":true,"path":"2021/07/11/2021 暑假支教日志（四）/","link":"","permalink":"http://ckblogs.cn/2021/07/11/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（四） 2021.07.11 陈坤 真情催泪 通过几天的相处，渐渐的，我与几位同学已经熟悉了起来，越与他们想接触，我就越能感受到他们内心深处那种纯洁，善良，真诚的美。记几件事： 雨中的乒乓球拍 这里的孩子很爱打乒乓球，也很爱与我一起打乒乓球，在下课后或者上课前的操场上，总能看到他们的身影。 今天早上，一位孩子找我借乒乓球拍，与他的小伙伴一起打乒乓球，外面下起了雨，在雨中，我只减他把我的乒乓球拍子放进了衣服里，放进衣服里后仍说道：“我人可以淋湿，老师的拍子不能淋湿。”听到这，我直接泪目，这些孩子是真的用最真挚的心对你想对你好，这种纯洁的美总是让我动容。 早饭中的棒棒糖 由于经费有限，我们的一日三餐就是有种回归自然般的朴素与健康。 睡醒起来吃早饭，没想到这些孩子们已经有不少人已近进入校园。我们二年级的一位小女孩早早过来给我说一句早上好，看到她眼神里透出的清澈明亮！不一会进来一位五年级的小女孩，她本给她的代课老师和班主任一人一颗棒棒糖，后来看到周围酸酸的其他老师，也与他们分享了其他的棒棒糖。嘿嘿，但是与其不同的是，她又给了我一颗。 两颗棒棒糖是五年级的小女孩给的，“一米阳光”是我们班的一位小女孩给我的。我觉得有小孩子给你送吃的是喜欢你，那收到礼物的我们也更应该去用我们的真心关心，爱护这些可爱的孩子们。 害羞的玩闹 上午上课前，我日常到二年级教室转一圈，突然感觉后背被人拍了一下，转过头来，一个小女孩的身影跑远了，她回过头来，当我用眼神告诉她，“我发现你了哦”，她冲我笑笑，又继续跑啊跑。等我没注意，突然我又被她拍了一下，她又冲我笑一笑。能看出来，这些孩子真的很愿意和我们一起玩，愿意与我们多接触。有时候只是有些害羞。而我们或许可以更主动的加入他们当中去！ 早上上课前，肖荣星与他们研究扑棱蛾子，我们班的孩子很懂得关爱动物，这只蛾子便是从一帮男孩子的扫把下拯救过来的，只不过已经奄奄一息，他们总问我“老师，蛾子是不是也是有生命的呀，我们是不是也不能随便杀它，只要我们不惹它，它也不会咬我们。”，看多懂事啊！ 课程总结反思 近些天来，包括同学与各位老师对我的课程的评价大都是正面的，我很高兴孩子们愿意上我的课，他们把我排在了最有趣的课程第一名，说实话，我压力很大，学生们越喜欢，我就越不能让他们失望，那就需要去备更好的课，做好准备，让孩子们始终保持对这门课程的兴趣。 但是，我并不认为这门课程有多么的成功，当有人问他们，老师的课有趣在哪里呀，他们说“老师带我们做游戏。”，如果他们在课程结束后，只记得我们做过哪些游戏，而不能知道它背后的数学原理，那我觉得，这节课是失败的。 一年级的乒乓球课属实让人有点恼火，对孩子们来说，初学乒乓球有一定的难度，一些小孩子有了放弃的想法，我也相信呢，再接下来的两节课中，他们的乒乓球技术一定会有所进步！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（三）","slug":"2021 暑假支教日志（三）","date":"2021-07-10T08:11:42.000Z","updated":"2021-08-13T16:44:22.842Z","comments":true,"path":"2021/07/10/2021 暑假支教日志（三）/","link":"","permalink":"http://ckblogs.cn/2021/07/10/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（三） 2021.07.10 陈坤 第一节数学课 说实话，因为只接触了低年级的小朋友，第一次与五年级上课，心里还充斥着几分紧张，上课之前，进到教室，有几位女同学拿着手机互相分享，男同学们在掰手腕。看到他们拿着手机，我是最担心的，我知道我的课程或许没有手机里的世界有趣。是收了他们的手机，还是如何去做？我看到他们其中的一位把手机投屏到班级的大电脑上看抖音，我决定和他们一起看，看到我并没有阻止，他们也更放松些，上课时间一到，我便与他们立下约定：“下课期间，我们可以一起看手机，加微信，上课时间一到，谁要拿出手机来玩，那就要没收了”，效果很好，学生们愿意去听从。 我真的很高兴，能看到学生们很愿意参与到数学思维游戏中去，甚至到下课时间，他们也要拉着我继续完成数学思维游戏。他们真的很聪明，当我解释了一遍游戏中蕴含的数学原理时，他们能很快的反应过来，并且能够在接下来的游戏中用到那些数学原理。这是我最愿意看到的。 我有一张 PPT 上写有这样一句话——“小同学们知道为什么吗？”，我原本觉得这句话很合适，看到这句话，他们都笑了，说 “我们才不是小同学”，一瞬间我有些许尴尬，是啊，五六年级已经是大姑娘小伙子，我们更应该以稍微成熟的眼光去看待他们： 从这些他们自己起的队伍名称我们就可以看出来，这真的不是一个充满稚气的小学生啦。 全班都在思考 24 点的时候，竟然没有一个人发现我在偷拍他们啊，这得有多认真。 在做两道我试讲时给咱们几个支教队员准备的 24 点（全部队员在两分钟内都没有做出来）时，时间过去了几分钟，我告诉他们，做不出来没关系，这两道题就算是这几天教你们的大哥哥姐姐，他们也做不出来。听到这，我以为他们会选择放弃，没想到，他们全部激动的说 “再给我们一点时间，我们能做出来”，真的，这种精神我是完全想象不到的，顿时，我也对他们肃然起敬。 二年级班级建设 五年级的弟弟妹妹们很聪明，也确实很有想法很有头脑，我很喜欢。但作为二年级的班主任，肯定更爱自己的孩子。今天二年级没有安排最后一节课，我决定去和他们做一些心理活动方面的游戏活动，他们听了都很高兴，也很愿意参与其中，看到他们都这么期待我也很高兴。 乌鸦与乌龟小游戏 画鼻子小游戏，同学们真的很团结友善，每一位同学都在提醒画鼻子的小同学，甚至着急地想上手，记得当初我小学的时候怎么那么多搞恶作剧来让你画歪的呀哈哈哈。。 这个游戏属实有点难为他们了，因为信任人椅是我高考前期老师搞得游戏。但是完成的也不错呀。 最后，我想升华一下游戏，让他们多一些感悟，但此时此刻我改变了想法，对待低年级小朋友时，我们可能不需要多那么多大道理，不需要让他们听那么多鸡汤。让他们玩的开心，玩的高兴也何尝不是一种收获呢？","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（二）","slug":"2021 暑假支教日志（二）","date":"2021-07-09T12:00:00.000Z","updated":"2021-08-13T16:43:17.371Z","comments":true,"path":"2021/07/09/2021 暑假支教日志（二）/","link":"","permalink":"http://ckblogs.cn/2021/07/09/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（二） 荷桥村一游 今天学校散学典礼的举办打破了正常的教学计划，然而多下来的这一天也并不是个休息的一天，从早到晚，也要开始工作！ 今天是荷桥同学到荷桥小学的一天，我也承担了送他们一程的任务，这一程，真是可谓山重水复疑无路，柳暗花明又一村啊！ 首先是苦苦等待公交车，而这公交车偏偏是一趟也不肯光顾，正当我们等的不耐烦的时候，一位大妈走过来说送我们一程到荷桥，只见大妈及班车过来了，把行李三下五除二送上车，我们出发了。与公交车不同，大妈将我们送到了荷桥小学的门口，这一路上过来，班车里起伏着一群“没见过世面”的大学生的一声声“哇哇”，感叹巴蜀人家的魅力风光。 北方人第一次见到水稻的好奇~ 看到这些景色，就让我想到一句诗：苔痕上阶绿，草色入帘青。 我把这些图片发给家里，恰好妈妈也在车上出差前往另外一个城市，这是她拍的中途的景色。。。 茫茫戈壁，一下子荒凉了很多。 到达荷桥小学，放下行李，准备启程返回，又是漫长的等车时间，又是漫长的等待。直到我们做了一个伟大的决定——走回去。看来是我们低估了路程的远近，一路走来都是美景，但总是顶不住饥饿的肚皮。突然间，又验证了那句诗——“山重水复疑无路，柳暗花明又一村”，公交车来了，班车也来了。 最香的午餐 托学生的光，在经历了连续几天无荤之餐时，居然开荤啦！！！！ 加之走过来已经消耗尽了能量，这一顿吃的真的太香了！所以说嘛，苦尽甘来。 记得我爸以前骂我挑食“你不吃饭，找个时间饿你三天，到时候吃屎都是香的”，我当时只觉得这句话可笑，现在看来，。。。，说不定还真是真的。 备课时光 现在是十一点四十，我又晚交了日志，哎，看教室里，仍有很多人在积极备课。能看得出来，大家真的很用心对待支教，我也很期待明天与小朋友的第一次上课！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2021 暑假支教日志（一）","slug":"2021 暑假支教日志（一）","date":"2021-07-08T12:00:00.000Z","updated":"2021-09-26T03:16:23.378Z","comments":true,"path":"2021/07/08/2021 暑假支教日志（一）/","link":"","permalink":"http://ckblogs.cn/2021/07/08/2021%20%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"2021 暑假支教日志（一） 初次见面 一直很期待与小朋友们的初次见面，身为二年级班主任，更对此次班会抱有很大的期待。在班会前一天，为此做了十足的憧憬与准备，包括想要和孩子们聊的话题，想要和孩子们玩的游戏，想要和孩子们做好的约定。终于，这一刻在突如其来的瞬间来临了。 吃完饭后，原准备休息片刻，小睡一会。队长一个电话的打来，打破了我的唤想，虽然没能得到这短暂的休息，但能看到孩子们这么热情的早到学校，心里也很高兴。 来到了二年级教室，再三查看 PPT 播放无误，便等待孩子们的到来，一个两个，陆陆续续到了教室，与我设想的不同，他们并没有乖巧地坐在位置上好奇地问我各种乱起八糟的问题，也没有乖巧地坐在位置上与我分享他们的假期与日常，而是在疯疯癫癫的“追逐”与 “作法”： 但是你们又能否想到，在李心逸一句话的呼吁下，一个个安静乖巧成了这样啊： 后来我发现，他们很爱拍照，在照相机面前，他们一定是坐的最端正，最安静，最乖巧的小朋友。下面这个小朋友有点与众不同，他有点特立独行的感觉，但是在照相机面前，他显得总有一种朴实，纯净的帅气： 班会 班会前昔 班会前二十分钟，孩子们有点不耐烦了，一声又一声 “无聊” 让我想给他们看点东西，幸好我准备了前几年大学学校的宣传片，问他们想不想看看哥哥的学校？他们齐刷刷的一声“好”，之后便是聚集的目光在投影屏上，看到学校主楼的恢弘，不由地一声“哇”，之后便是寂静。 混进去一个大giegie？^ - ^ 他们说“哥哥，这真的是你们学校吗？有这么大？”，我说是的，透光目光，我看到了他们的羡慕又惊喜，我说“大家好好学习，未来这就是你们的学校，那时候肯定比现在更漂亮”，他们笑了，那是期待的笑容，那是希望的笑容。一瞬间，我感到我来这里的哪怕一点点能带给他们的意义，一瞬间，我期待着他们能够在未来的某一天能够来到电子科技大学乃至比电子科技大学更前沿的高等学府。 班会进行时 我很感谢，二年级的孩子们的乖巧可爱，他们一个个认真听讲的状态，当一个人无意中稍微大声一点时，他旁边的人甚至会对他比出“嘘”的手势。在班会的过程中，和他们的配合也让我把我想说的，把我想与他们做的都能完成得很好。 首先，我与他们交谈了安全事项，上课时对老师的尊重与礼貌，与他们介绍了支教十五天中我们将要进行的课内课程与课外活动，并给出了班主任寄语： 在班主任寄语的过程中，我通过近日中国共产党成立100周年庆典的人民解放军国旗班正步前进的列队视频与神州十二号发射成功的发射视频告诉他们要有集体荣誉感！通过介绍“手工耿”告诉他们要敢于大胆尝试，打开思维！最后综合告诉他们要踊跃参与课程内容，踊跃参加课外活动！ 游戏环节 原本一个半小时显得那么长久，但真正地开下来，发现时间还不够用，准备了三个游戏与他们一起破冰，但最终只做了“心有灵犀”与“写到做到”。给我的感受是，他们真的很聪明，也很有想法，同时也真正具有我之前向他们介绍的集体荣誉感，在游戏的过程中，我能感受到少年时的纯真与快乐，同时与他们相处的这一个多小时内，也让我有了更加年轻的心态。期待接下来与他们相处的十五天！","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"机器学习之 Logistic 回归算法及其 Python 实现","slug":"机器学习之-Logistic-回归算法及其-Python-实现","date":"2021-05-28T15:27:29.000Z","updated":"2021-12-15T03:10:47.151Z","comments":true,"path":"2021/05/28/机器学习之-Logistic-回归算法及其-Python-实现/","link":"","permalink":"http://ckblogs.cn/2021/05/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B-Logistic-%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6-Python-%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"机器学习之 Logistic 回归算法及其 Python 实现 [TOC] 如需要本文所用数据及代码原文件可留言评论。 前言：机器学习分类算法初步 感知器 Frank Rossenblatt 基于 MCP 神经元模型提出第一个感知器学习法则。在此感知器规则中，自学习算法可以自动通过优化得到权重系数，雌蜥属与输入值的乘积决定了神经元是否被激活。在监督学习与分类中，类似算法课用于预测样本所属的类别。 对于一个二分类问题，我们将两个类别记为 1 （正类别）与 -1 （负类别）。定义一个激励函数（activation function）ϕ(z)\\phi(z)ϕ(z) ，它以特定的输入值 xxx 与相应的权值向量 www 的线性组合作为输入，其中，zzz 也称作净输入 (z=w1x1+⋯+wmxm)(z=w_1x_1+\\dots+w_mx_m)(z=w1​x1​+⋯+wm​xm​)。 此时，对于一个特定的样本 x(i)x^{(i)}x(i) 的激励，也就是 ϕ(z)\\phi(z)ϕ(z) 的输出，如果其值大于预设的阈值 θ\\thetaθ ，我们将其划分到 1 类，否则为 -1 类。在感知器算法中，激励函数 ϕ(⋅)\\phi(\\cdot)ϕ(⋅) 是一个简单的分段函数。 ϕ(z)={1若z≥θ−1其他\\phi(z)=\\left\\{ \\begin{aligned} 1 &amp; \\qquad若 z \\ge \\theta \\\\ -1&amp; \\qquad 其他 \\end{aligned} \\right. ϕ(z)={1−1​若z≥θ其他​ MCP 神经元和罗森布拉特阈值感知器的理念就是，通过模拟的方式还原大脑中的单个神经元的工作方式。这样，罗森布拉特感知器最初的规则非常简单，可总结为如下几步： 将权重初始化为零或一个极小的随机数。 迭代所有的训练样本 x(i)x^{(i)}x(i) ，执行如下操作： 计算输出值 y^\\hat{y}y^​ 。 更新权重。 这里的输出值是值通过前面定义的单位阶跃函数预测得出的类标，而这里的权重 www 的更新方式为： wj=wj+Δwjw_j=w_j+\\Delta w_j wj​=wj​+Δwj​ 对于用于更新权重 wjw_jwj​ 的值 Δwj\\Delta w_jΔwj​ ，可通过感知器学习规则计算获得： Δwj=η(y(i)−y^(i))xj(i)\\Delta w_j = \\eta (y^{(i)}-\\hat{y}^{(i)})x_j^{(i)} Δwj​=η(y(i)−y^​(i))xj(i)​ 其中，η\\etaη 为学习速率（一个介于 0 到 1 之间的常数），y(i)y^{(i)}y(i) 为第 iii 个样本的真是类标，y^(i)\\hat{y}^{(i)}y^​(i) 为预测得到的类标。 自适应线性神经元及其学习的收敛性 在 Frank Rosenblatt 提出感知器算法纪念之后，Bernard Widrow 和他的博士生提出了 Adaline 算法，可看作对之前算法的改进。它阐明了代价函数的核心概念，并且对其做出了最小化优化，这是理解 Logistic 回归、支持向量机和后续回归模型的基础。 基于 Adeline 规则的权重更新是通过一个连续的线性激励函数来完成的，而不像感知器那样使用单位阶跃函数，这是二者的主要区别。 线性激励函数在更新权重同时，我们使用量化器对类标进行预测，量化器与前面提到的单位阶跃函数类似。 梯度下降法 机器学习中监督学习算法核心在于定义一个待优化的目标函数，这个目标函数通常是需要我们做最小化处理的代价函数。在 Adaline 中，我们可以将代价函数 JJJ 定义为通过模型得到的输出与实际类标之间的误差平方和： J(w)=12∑i(y(i)−ϕ(z(i)))2J(w) = \\cfrac{1}{2}\\sum\\limits_i (y^{(i)}-\\phi(z^{(i)}))^2 J(w)=21​i∑​(y(i)−ϕ(z(i)))2 与单位阶跃函数相比，这种连续的线性激励函数的主要优点在于：其代价函数是可导的。另一个优点是：他是一个凸函数；这样，我们通过简单、高效的梯度下降优化算法；来得到权重。在每次迭代的过程中，根据给定的学习所率和梯度斜率，能够确定每次移动的步幅，我们按照步幅沿着梯度方向前进一步，直到获得一个局部或全局最小值： $$ w:=w+\\Delta w \\\\ \\Delta w = -\\eta \\cfrac{\\partial J}{\\partial w_i} $$ 为了计算代价函数的梯度，我们需要计算代价函数相对于每个权重$w_j$ 的偏导$\\cfrac{\\partial J}{\\partial w_i}$ 这样我们可以把 $w_j$ 的更新写作： $$ \\Delta w_j=-\\eta\\cfrac{\\partial J}{\\partial w_i}=\\mu\\sum\\limits_i(y^{(i)}-\\phi(z^{(i)}))x_j^{(i)} $$ 逻辑斯蒂（Logistic）回归 基本模型介绍 前言中提到的感知器是机器学习中优雅医用的一个入门级算 法，不过其最大的缺点在于：在样本不是完全线性可分的情况下，它永远不会收敛。为了提高分类效率，可以使用 Logistic 回归模型。注意：Logistic 回归模型是一个分类模型，而不是回归模型。 Logistic 回归是针对线性可分问题的一种易于实现且性能优异的分类模型。 设置激励函数：sigmoid 函数 ϕ(z)=11+e−z\\phi(z)=\\cfrac{1}{1+e^{-z}} ϕ(z)=1+e−z1​ 它的函数图像是这样的： 可以看到，当 zzz 趋向于无穷大时，ϕ(z)\\phi(z)ϕ(z) 趋近于 1，这是由于 e−ze^{-z}e−z 在 zzz 值极大的情况下变得极小。当zzz 趋向于负无穷时，ϕ(z)\\phi(z)ϕ(z) 趋近于 0，这是由于此时分母越来越大的结果。由此可以得出结论： sigmoid 函数以实数值作为输入并将其映射到了 [0,1][0,1][0,1] 区间，其拐点位于 ϕ(z)=0.5\\phi(z)=0.5ϕ(z)=0.5 处。 将 logistic 回归模型与上文中介绍的 Adaline 模型联系起来。在 Adaline 中，我们使用恒等函数 ϕ(z)=z\\phi(z) = zϕ(z)=z 作为激励函数。而在 logistic 回归模型中，只是简单地将前面提到的 sigmoid 函数作为激励函数，如下图所示： 在给定特征 x 及其权重 w 的权重情况下，sigmoid 函数的输出给出了特定的样本 x 所属的概率 ϕ(z)=P(y=1∣x;w)\\phi(z)=P(y=1|x;w)ϕ(z)=P(y=1∣x;w)。预测得到的概率可以通过量化器（单位跃阶函数）简单地转化为二元输出： y^={1若ϕ(z)≥0.50其他\\hat{y}=\\left\\{ \\begin{aligned} 1 &amp; \\qquad若 \\phi(z)\\ge 0.5 \\\\ 0&amp; \\qquad 其他 \\end{aligned} \\right. y^​={10​若ϕ(z)≥0.5其他​ 对照前面给出的 sigmoid 函数图像，它其实相当于： y^={1若z≥0.00其他\\hat{y}=\\left\\{ \\begin{aligned} 1 &amp; \\qquad若 z\\ge 0.0 \\\\ 0&amp; \\qquad 其他 \\end{aligned} \\right. y^​={10​若z≥0.0其他​ 通过代价函数获得权重 在 Adaline 分类模型中，我们定义其代价函数为误差平方和，根据此代价函数并运用梯度下降法更新权重，我们在构建 logistic 回归模型时，首先定义一个最大似然函数 LLL，其计算公式如下： L(w)=P(y∣x;w)=∏i=1nP(y(i)∣x(i);w)=(ϕ(z(i)))y(i)(1−ϕ(x(i)))1−y(i)L(w)=P(y|x;w)=\\prod_{i=1}^nP(y^{(i)}|x^{(i)};w)=\\left(\\phi\\left(z^{(i)}\\right)\\right)^{y^{(i)}}\\left(1-\\phi\\left(x^{(i)}\\right)\\right)^{1-y^{(i)}} L(w)=P(y∣x;w)=i=1∏n​P(y(i)∣x(i);w)=(ϕ(z(i)))y(i)(1−ϕ(x(i)))1−y(i) 作对数化处理后： ln⁡L(w)=∑i=1n(y(i)ln⁡[ϕ(z(i))]+(1−y(i))ln⁡[1−ϕ(z(i))])\\ln L(w)=\\sum_{i=1}^{n}\\left(y^{(i)} \\ln \\left[\\phi\\left(z^{(i)}\\right)\\right]+\\left(1-y^{(i)}\\right) \\ln \\left[1-\\phi\\left(z^{(i)}\\right)\\right]\\right) lnL(w)=i=1∑n​(y(i)ln[ϕ(z(i))]+(1−y(i))ln[1−ϕ(z(i))]) 根据前文提到的梯度下降法做代价函数的最小化处理，求解权重。 logistic 的 Python 实现 实现方式一：不使用机器学习第三方库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# -*- coding:utf-8 -*-&quot;&quot;&quot;@author:Lisa@file:logisticRegression.py@note:logistic回归@time:2018/7/11 0011下午 10:45&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as pltdef loadDataSet(): &quot;&quot;&quot; 函数：加载数据集 &quot;&quot;&quot; dataMat = [] # 列表list labelMat = [] txt = open(&#x27;testSet.txt&#x27;) for line in txt.readlines(): lineArr = line.strip().split() # strip():返回一个带前导和尾随空格的字符串的副本 # split():默认以空格为分隔符，空字符串从结果中删除 dataMat.append([1.0, float(lineArr[0]), float(lineArr[1])]) # 将二维特征扩展到三维，第一维都设置为1.0 labelMat.append(int(lineArr[2])) return dataMat, labelMat&quot;&quot;&quot;函数：sigmoid函数&quot;&quot;&quot;def sigmoid(z): return 1.0/(1+np.exp(-z))&quot;&quot;&quot;函数：梯度上升算法&quot;&quot;&quot;def gradAscent(dataMat, labelMat): dataSet = np.mat(dataMat) # m*n labelSet = np.mat(labelMat).transpose() # 1*m-&gt;m*1 m, n = np.shape(dataSet) # m*n: m个样本，n个特征 alpha = 0.001 # 学习步长 maxCycles = 500 # 最大迭代次数 weights = np.ones((n, 1)) for i in range(maxCycles): y = sigmoid(dataSet * weights) # 预测值 error = labelSet - y weights = weights + alpha * dataSet.transpose()*error #print(type(weights)) return weights.getA(),weights ##getA():将Mat转化为ndarray,因为mat不能用index&quot;&quot;&quot;函数：随机梯度上升算法0.0改进：每次用一个样本来更新回归系数&quot;&quot;&quot;def stocGradAscent0(dataMat,labelMat): m, n = np.shape(dataMat) # m*n: m个样本，n个特征 alpha = 0.001 # 学习步长 maxCycles=500 weights = np.ones(n) for cycle in range(maxCycles): for i in range(m): y = sigmoid(sum(dataMat[i] * weights) ) # 预测值 error = labelMat[i] - y weights = weights + alpha * error* dataMat[i] # print(type(weights)) return weights&quot;&quot;&quot;函数：改进的随机梯度上升法1.0改进：1.alpha随着迭代次数不断减小，但永远不会减小到0 2.通过随机选取样本来更新回归系数&quot;&quot;&quot;def stocGradAscent1(dataMat,labelMat): m, n = np.shape(dataMat) # m*n: m个样本，n个特征 maxCycles = 150 weights = np.ones(n) for cycle in range(maxCycles): dataIndex=list( range(m)) for i in range(m): alpha = 4 / (1.0 + cycle + i) + 0.01 # 学习步长 randIndex=int(np.random.uniform(0,len(dataIndex) )) #随机选取样本 y = sigmoid(sum(dataMat[randIndex] * weights )) # 预测值 error = labelMat[randIndex] - y weights = weights + alpha * error * dataMat[randIndex] del(dataIndex[randIndex]) # print(type(weights)) return weights&quot;&quot;&quot;函数：画出决策边界&quot;&quot;&quot;def plotBestFit(weights): dataMat, labelMat = loadDataSet() dataArr=np.array(dataMat) m,n=np.shape(dataArr) x1=[] #x1,y1:类别为1的特征 x2=[] #x2,y2:类别为2的特征 y1=[] y2=[] for i in range(m): if (labelMat[i])==1: x1.append(dataArr[i,1]) y1.append(dataArr[i,2]) else: x2.append(dataArr[i,1]) y2.append(dataArr[i,2]) fig=plt.figure() ax=fig.add_subplot(1,1,1) ax.scatter(x1,y1,s=30,c=&#x27;red&#x27;,marker=&#x27;s&#x27;) ax.scatter(x2,y2,s=30,c=&#x27;green&#x27;) #画出拟合直线 x=np.arange(-3.0, 3.0, 0.1) y=(-weights[0]-weights[1]*x)/weights[2] #直线满足关系：0=w0*1.0+w1*x1+w2*x2 ax.plot(x,y) plt.xlabel(&#x27;X1&#x27;) plt.ylabel(&#x27;X2&#x27;) plt.show()def main(): dataMat,labelMat=loadDataSet() weights = gradAscent(dataMat,labelMat)[0] weights = stocGradAscent0(np.array(dataMat), labelMat) weights = stocGradAscent1(np.array(dataMat), labelMat) plotBestFit(weights)if __name__ == &#x27;__main__&#x27;: main() 运行结果： 实现方式二：使用 sklearn 模块 模块介绍： sklearn.linear_model.LogisticRegression官方API： 官方API：http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html 1class sklearn.linear_model.LogisticRegression (penalty=&#x27;l2&#x27;, dual=False, tol=0.0001, C=1.0,fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None,solver=&#x27;liblinear&#x27;, max_iter=100, multi_class=&#x27;ovr&#x27;, verbose=0,warm_start=False, n_jobs=1) 参数说明： penalty： 惩罚项，可为’l1’ or ‘l2’。‘netton-cg’, ‘sag’, ‘lbfgs’只支持’l2’。‘l1’正则化的损失函数不是连续可导的，而’netton-cg’, ‘sag’, 'lbfgs’这三种算法需要损失函数的一阶或二阶连续可导。调参时如果主要是为了解决过拟合，选择’l2’正则化就够了。若选择’l2’正则化还是过拟合，可考虑’l1’正则化。若模型特征非常多，希望一些不重要的特征系数归零，从而让模型系数化的话，可用’l1’正则化。 dual：选择目标函数为原始形式还是对偶形式。 将原始函数等价转化为一个新函数，该新函数称为对偶函数。对偶函数比原始函数更易于优化。 tol： 优化算法停止的条件。当迭代前后的函数差值小于等于tol时就停止。 C： 正则化系数。其越小，正则化越强。 fit_intercept： 选择逻辑回归模型中是否会有常数项b intercept_scaling： 仅在正则化项为&quot;liblinear&quot;，且fit_intercept设置为True时有用。 class_weight： 用于标示分类模型中各种类型的权重，{class_label: weight} or ‘balanced’。 ‘balanced’：类库根据训练样本量来计算权重。某种类型的样本量越多，则权重越低。 若误分类代价很高，比如对合法用户和非法用户进行分类，可适当提高非法用户的权重。 样本高度失衡的。如合法用户9995条，非法用户5条，可选择’balanced’，让类库自动提高非法用户样本的权重。 random_state： 随机数种子。 solver： 逻辑回归损失函数的优化方法。 **‘liblinear’：**使用坐标轴下降法来迭代优化损失函数。 ‘lbfgs’： 拟牛顿法的一种。利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。 **‘newton-cg：’**牛顿法的一种。同上。 **‘sag’：**随机平均梯度下降。每次迭代仅仅用一部分的样本来计算梯度，适合于样本数据多的时候。 多元逻辑回归有OvR(one-vs-rest)和MvM(many-vs-many)两种，而MvM一般比OvR分类相对准确一些。但是，'liblinear’只支持OvR。 max_iter： 优化算法的迭代次数。 multi_class： ‘ovr’ or ‘multinomial’。'multinomial’即为MvM。 1. 若是二元逻辑回归，二者区别不大。 2. 对于MvM，若模型有T类，每次在所有的T类样本里面选择两类样本出来，把所有输出为该两类的样本放在一起，进行二元回归，得到模型参数，一共需要T(T-1)/2次分类。 verbose： 控制是否 print 训练过程。 warm_start： 是否热启动，如果是，则下一次训练是以追加树的形式进行（重新使用上一次的调用作为初始化），bool：热启动，False：默认值 n_jobs： 用cpu的几个核来跑程序。 demo 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-&quot;&quot;&quot;@author:Lisa@file:sklearn_horse_colic.py@note:利用sklearn的LR方法实现 疝气马预测@time:2018/7/13 0013上午 11:30@reference:&quot;&quot;&quot;from sklearn.linear_model import LogisticRegression&quot;&quot;&quot;函数：疝气预测&quot;&quot;&quot;def colicTest(): trainData=open(&#x27;data\\horseColicTraining.txt&#x27;) testData = open(&#x27;data\\horseColicTest.txt&#x27;) trainSet=[] trainLabel=[] for line in trainData.readlines(): curLine=line.strip().split(&#x27;\\t&#x27;) lineArr=[] for i in range(21): lineArr.append(float (curLine[i])) trainSet.append(lineArr) trainLabel.append(float(curLine[21])) testSet = [] testLabel = [] for line in testData.readlines(): curLine=line.strip().split(&#x27;\\t&#x27;) lineArr=[] for i in range(21): lineArr.append(float (curLine[i])) testSet.append(lineArr) testLabel.append(float(curLine[21])) #分类器 classifier = LogisticRegression(solver=&#x27;sag&#x27;, max_iter=5000).fit(trainSet, trainLabel) test_accurcy = classifier.score(testSet, testLabel) * 100 print(&quot;the accurate rate is: %f&quot; % test_accurcy) 运行结果： the accurate rate is: 73.134328 实现方式三：使用 Pytorch 模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import torchimport torch.nn as nnimport matplotlib.pyplot as pltimport numpy as nptorch.manual_seed(10) # ============================ step 1/5 生成数据 ============================sample_nums = 100mean_value = 1.7bias = 1n_data = torch.ones(sample_nums, 2)x0 = torch.normal(mean_value * n_data, 1) + bias # 类别0 数据 shape=(100, 2)y0 = torch.zeros(sample_nums) # 类别0 标签 shape=(100, 1)x1 = torch.normal(-mean_value * n_data, 1) + bias # 类别1 数据 shape=(100, 2)y1 = torch.ones(sample_nums) # 类别1 标签 shape=(100, 1)train_x = torch.cat((x0, x1), 0)train_y = torch.cat((y0, y1), 0) # ============================ step 2/5 选择模型 ============================class LR(nn.Module): def __init__(self): super(LR, self).__init__() self.features = nn.Linear(2, 1) self.sigmoid = nn.Sigmoid() def forward(self, x): x = self.features(x) x = self.sigmoid(x) return x lr_net = LR() # 实例化逻辑回归模型 # ============================ step 3/5 选择损失函数 ============================loss_fn = nn.BCELoss() # ============================ step 4/5 选择优化器 ============================lr = 0.01 # 学习率optimizer = torch.optim.SGD(lr_net.parameters(), lr=lr, momentum=0.9) # ============================ step 5/5 模型训练 ============================for iteration in range(1000): # 前向传播 y_pred = lr_net(train_x) # 计算 loss loss = loss_fn(y_pred.squeeze(), train_y) # 反向传播 loss.backward() # 更新参数 optimizer.step() # 清空梯度 optimizer.zero_grad() # 绘图 if iteration % 20 == 0: mask = y_pred.ge(0.5).float().squeeze() # 以0.5为阈值进行分类 correct = (mask == train_y).sum() # 计算正确预测的样本个数 acc = correct.item() / train_y.size(0) # 计算分类准确率 plt.scatter(x0.data.numpy()[:, 0], x0.data.numpy()[:, 1], c=&#x27;r&#x27;, label=&#x27;class 0&#x27;) plt.scatter(x1.data.numpy()[:, 0], x1.data.numpy()[:, 1], c=&#x27;b&#x27;, label=&#x27;class 1&#x27;) w0, w1 = lr_net.features.weight[0] w0, w1 = float(w0.item()), float(w1.item()) plot_b = float(lr_net.features.bias[0].item()) plot_x = np.arange(-6, 6, 0.1) plot_y = (-w0 * plot_x - plot_b) / w1 plt.xlim(-5, 7) plt.ylim(-7, 7) plt.plot(plot_x, plot_y) plt.text(-5, 5, &#x27;Loss=%.4f&#x27; % loss.data.numpy(), fontdict=&#123;&#x27;size&#x27;: 20, &#x27;color&#x27;: &#x27;red&#x27;&#125;) plt.title(&quot;Iteration: &#123;&#125;\\nw0:&#123;:.2f&#125; w1:&#123;:.2f&#125; b: &#123;:.2f&#125; accuracy:&#123;:.2%&#125;&quot;.format(iteration, w0, w1, plot_b, acc)) plt.legend() plt.show() plt.pause(0.5) if acc &gt; 0.99: break 参考博文: logistic回归原理与实现 Sklearn-LogisticRegression逻辑回归 sklearn 官方API Pytorch：通过pytorch实现逻辑回归","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://ckblogs.cn/tags/Python/"},{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"机器学习","slug":"机器学习","permalink":"http://ckblogs.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"基于深度优先搜索回溯法的人狼羊菜过河模型","slug":"狼羊菜过河模型","date":"2021-05-05T14:44:12.000Z","updated":"2021-09-26T03:15:51.705Z","comments":true,"path":"2021/05/05/狼羊菜过河模型/","link":"","permalink":"http://ckblogs.cn/2021/05/05/%E7%8B%BC%E7%BE%8A%E8%8F%9C%E8%BF%87%E6%B2%B3%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"基于深度优先搜索回溯法的人狼羊菜过河模型 本文介绍一个农夫过河的小模型，算法 Python 实现，感觉还挺有趣的，因原为笔者课程作业论文改版而来，所以文章内容比起其他博客文章可能会比较严肃与严谨。期待与你的思维碰撞。 摘要 本文介绍了一种合理规划农夫携带狼、羊、菜安全过河问题。对问题合理分析，将人、狼、羊、菜四者的某时刻状态量化为一向量，基于此结构建立安全位置状态集合，与安全运输状态集合，存储运输过程中可能的位置状态与运输状态。以初始状态向量为起点，采用回溯法，深度优先遍历所有可行路径，将符合题目条件并未重复的可行路径添入历史路径集合中，并记录此时的位置状态。递归至搜索到终止状态集合，输出所有历史位置状态集合，即为一条可行方案。回溯弹出，即可搜寻到所有可行路径。并根据所搜寻到的可行路径输出最短路径。 通过上述模型及算法，本文基于 Python 语言，实现模型求解最终找到此问题唯二解： 农夫带羊过河→\\rightarrow→农夫返回→\\rightarrow→农夫带狼过河→\\rightarrow→农夫带羊返回→\\rightarrow→农夫带菜过河→\\rightarrow→农夫返回→\\rightarrow→农夫带羊过河 农夫带羊过河→\\rightarrow→农夫返回→\\rightarrow→农夫带菜过河→\\rightarrow→农夫带羊返回→\\rightarrow→农夫带狼过河→\\rightarrow→农夫返回→\\rightarrow→农夫带羊过河 为检验模型的正确性与普适性，本文假定当狼、羊同时存在时（农夫不存在），狼不会吃羊。即添加两安全位置状态向量。得到更改后问题的唯八解（见正文），并且所得到的最短路径更少。验证模型准确性高，具有普适性。拓展到日常生活的规划问题时，具有一定的参考意义。 关键字: 回溯法 深度优先搜索DFS 空间状态树 Python 问题重述 问题描述 本文致力于解决一位农夫的过河问题。在此问题中，一位农夫，携带狼、羊、菜，准备过河，在只有一艘船只且每次过河农夫只能携带狼、羊、菜其中一件个体的前提下，保证农夫与每件个体安全渡河。而在过河过程中，由于缺少农夫的看管，当狼与羊单独在一岸时，狼可以吃羊使得渡河失败；由于缺少农夫的看管，当羊与菜单独在一岸时，羊可以吃菜使得渡河失败。如何让狼、羊、菜同时保证安全的前提下，让农夫顺利过河，取决于农夫每次过河时所携带的个体。本文建立合适的模型，并选择合适的算法，寻找所有的渡河决策。 这个问题属实离谱，《养狼的农夫》，而且农夫还没有绳子可以把羊和狼拴起来，哎大家别较真。 问题要求 在此问题中的求解中，需要满足下列条件： 保证狼与羊不单独在同一岸边； 保证羊与菜不单独在同一岸边； 农夫每次运输只能携带狼、羊、菜中的一位，或者不携带其中的任何一位； 决策需要在有限次完成，并保证前后互不重复。 在保证狼、羊、菜全部安全的前提下，建立合适模型，并选择合适算法求解，找出决策变化规律。寻找到所有有限次符合要求的农夫渡河决策。 问题分析 在此问题中，由于对狼、羊、菜相关约束条件，为保证每一件个体的安全，不单独将狼与羊或羊与菜放在同一岸边，对于这一人、狼、羊、菜四者的所在位置状态的约束，考虑河岸的任意一边，通过穷举，不难想出，各河岸有且仅有下面的十种安全位置状态（如下表所示），由对称性，另一边的安全位置状态与此相同。 在此问题中，由于农夫和小船运输限制，每次渡河农夫必须在船上，并且农夫可以选择携带狼、羊、菜中的任何一个，当然农夫可以选择不携带其中的任何一个，而单独过河。在上述情况中，通过穷尽，不难想出，每次渡河，从河的一边运输到另外一边，在运输船中，有且仅有下面四种运输状态（如下表所示），由对称性，从河的另一岸到此岸的运输状态相同。 问题的起始状态为：人、狼、羊、菜在此岸，而本文所要寻找的决策便是由一系列的人狼羊菜安全运输状态组成，使最终的人狼羊菜位置状态为：人、狼、羊、菜在彼岸。 注：其中√\\surd√表示存在，◯\\bigcirc◯表示不存在。 为合理量化模型状态，本文采用二进制向量数据结构，四位向量数据因子分布存储人、狼、羊、菜的位置状态与运输状态： 位置状态：每个个体所处位置状态仅有两种情况，在此岸与未在此岸，设定 1 为在此岸， 0 为位未在此岸； 运输状态：每个个体所处运输状态仅有两种情况，被运输与未被运输，设定 1 为被运输， 0 为未被运输。 搜寻可行路径，使得每次状态向量均为安全状态向量。状态起点为(1,1,1,1)(1,1,1,1)(1,1,1,1)，当搜寻至状态终点(0,0,0,0)(0,0,0,0)(0,0,0,0)时，成功完成渡河，即为所搜索到的一条运输策略。记录运输策略集合中所包含的状态向量个数。则最短路径即为当包含的状态向量个数最少时的最优解。 ## 名词解释与模型假设 名词解释 本文部分所用具体符号如下表所示： 符号表示 说明 集合Sk{k=1,2,...,10}S_k\\quad \\{k=1,2,...,10\\}Sk​{k=1,2,...,10} 人狼羊菜安全位置状态集合 集合Mk{k=1,2,3,4}M_k\\quad \\{k=1,2,3,4\\}Mk​{k=1,2,3,4} 人狼羊菜安全运输状态集合 集合Gk{k=1,2,...,n}G_k \\quad \\{k=1,2,...,n\\}Gk​{k=1,2,...,n} 历史位置状态集合 集合Hk{k=1,2,...,m}H_k \\quad \\{k=1,2,...,m\\}Hk​{k=1,2,...,m} 历史运输状态集合 模型假设 为使所建立模型更加合理，避免异常情况干扰模型结果，在满足客观条件下，设定下面的模型假设： 运输过程，不因时间或利益成本而丢弃或放弃任意一件个体； 当狼、羊单独存在时，假设二者不会自主逃跑或丢失； 每次运输过程除运输个体外，环境条件完全相同，不考虑风浪及农夫体力对运输的影响； 农夫所养之狼并不会出现恶意攻击农夫或不服从农夫命令的行为。 模型的建立与求解 模型的建立 为合理量化模型状态，本文采用二进制向量数据结构，四位向量数据因子分布存储人、狼、羊、菜的位置状态与运输状态： 位置状态：每个个体所处位置状态仅有两种情况，在此岸与未在此岸，设定 1 为在此岸， 0 为位未在此岸； 运输状态：每个个体所处运输状态仅有两种情况，被运输与未被运输，设定 1 为被运输， 0 为未被运输。 由此结构，可将安全位置状态集合量化如下： S={(1,1,1,1)(1,1,1,0)(1,1,0,1)(1,0,1,1)(1,0,1,0)(0,0,0,0)(0,0,0,1)(0,0,1,0)(0,1,0,0)(0,1,0,1)S = \\begin{cases} (1, 1, 1, 1)\\quad (1, 1, 1, 0)\\quad (1, 1, 0, 1)\\quad (1, 0, 1, 1)\\quad (1, 0, 1, 0)\\\\ (0, 0, 0, 0)\\quad(0, 0, 0, 1)\\quad (0, 0, 1, 0)\\quad (0, 1, 0, 0)\\quad (0, 1, 0, 1) \\end{cases} S={(1,1,1,1)(1,1,1,0)(1,1,0,1)(1,0,1,1)(1,0,1,0)(0,0,0,0)(0,0,0,1)(0,0,1,0)(0,1,0,0)(0,1,0,1)​ 可将安全运输状态集合量化如下： M={(1,0,0,0)(1,1,0,0)(1,0,1,0)(1,0,0,1)}M = \\{ (1, 0, 0, 0)\\quad (1, 1, 0, 0)\\quad (1, 0, 1, 0)\\quad (1, 0, 0, 1) \\} M={(1,0,0,0)(1,1,0,0)(1,0,1,0)(1,0,0,1)} 由位置状态及运输状态定义可知，满足下面条件： Gk+1=Gk+HkGk,Gk+1∈SHk∈MG_{k+1} = G_{k} + H_{k}\\\\ G_{k},G_{k+1} \\in S\\\\ H_{k} \\in M Gk+1​=Gk​+Hk​Gk​,Gk+1​∈SHk​∈M 其中Gk{k=1,2,...,n}G_k \\quad \\{k=1,2,...,n\\}Gk​{k=1,2,...,n}为历史位置状态集合，存储运输过程中符合条件的个体位置状态，Hk{k=1,2,...,m}H_k \\quad \\{k=1,2,...,m\\}Hk​{k=1,2,...,m}为历史运输状态集合，存储运输过程中符合条件的个体运输状态。并且一定有 m=n−1m = n - 1 m=n−1 由于两种状态向量的特殊关系，对应状态向量因子之间的相加运算符合下列条件： $ 1 + 1 = 0$，在此岸个体被运输去后，位置状态向量为 0，表示已不在此岸； 1+0=11 + 0 = 11+0=1，在此岸个体未被运输后，位置状态向量仍为 1，表示仍在此岸； 0+1=10 + 1 = 10+1=1，未在此岸个体被运输来后，位置状态为 1，表示来到此岸； 0+0=00 + 0 = 00+0=0，未在此岸个体未被运输后，位置状态仍为 0，表示仍未在此岸。 为避免所寻路径重复，需要补充条件： Gk∉Gii&lt;k G_{k} \\notin G_{i} \\qquad i &lt; k Gk​∈/Gi​i&lt;k 所建模型初始位置状态向量：G1=(1,1,1,1)G_1=(1, 1, 1, 1)G1​=(1,1,1,1)，当模型满足上述(1),(2),(3),(4)(1),(2),(3),(4)(1),(2),(3),(4)条件，并且搜寻到目标状态向量：Gn=(0,0,0,0)G_n=(0, 0, 0, 0)Gn​=(0,0,0,0)时，成功完成渡河，所搜索到的运输策略即为 Hk其中k=1,2,...,n−1H_{k}\\qquad \\text{其中}k=1,2,...,n-1 Hk​其中k=1,2,...,n−1 记录m=n−1m=n-1m=n−1，当全部搜索遍历结束后，取到$\\min m $的路径集合即为最短路径方案。 考虑模型数据结构，基于此问题，由于面对同一状态向量下，可能有多个安全运输状态，有多种运输方法策略，本文用空间状态树，存储遍历搜索路径中的可行位置状态，故空间状态树的根节点为(0,0,0,0)(0,0,0,0)(0,0,0,0)，当搜索到叶子节点为(1,1,1,1)(1,1,1,1)(1,1,1,1)时，从根节点到该叶子节点的一条路径便是一条可行路径。 模型的求解 回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。 具体回溯步骤如下图流程图所示： 回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。本题中，约束函数在于下面几点： 可行位置状态向量属于安全位置状态向量，可行运输状态向量属于安全运输状态向量； 历史位置状态不重复； 运输时农夫所携带个体与农夫位于同一侧。 问题的关键在于如何定义问题的解空间，转化成树（即解空间树）。解空间树分为两种：子集树和排列树。两种在算法结构和思路上大体相同。 考虑模型的搜索遍历算法，有此问题可以分解，但是又不能得出明确的递归解法，因此本文采用回溯法解决此问题。回溯法的优点在于其程序结构明确，可读性强，易于理解，而且通过对问题的分析可以大大提高运行效率。本文用采回溯法，按照深度优先搜索策略，遍历构建的位置空间状态树，输出得到的所有路径。 求解得到所有可行路径之后，根据可行路径集合中元素个数多少确定路径长短，最短路径即为所含元素最少的路径。 模型求解结果 通过回溯算法求解所建立模型，由程序语言实现（完整代码见附录）后，得到下面对模型的求解结果： 12345方案1:[[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [0, 0, 0, 1], [1, 0, 1, 1], [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0]]方案2:[[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0]] 模型检验 为检验模型的正确性与普适性，现假定当狼、羊同时存在时 (农夫不存在 )，狼不会 吃羊。即添加安全位置状态向量 S11=(0,1,1,0),S12=(1,0,0,1)S_{11}=(0,1,1,0), S_{12}=(1,0,0,1)S11​=(0,1,1,0),S12​=(1,0,0,1) 。代入原模型中，利 用回溯算法求解所有符合条件的农夫过河策略，得到下面的求解方案状态向量: 12345678910111213141516171819202122方案1:[[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [0, 0, 0, 1], [1, 0, 0, 1], [0, 0, 0, 0]]方案2:[[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [0, 0, 0, 1], [1, 0, 1, 1], [0, 0, 1, 0], [1, 0,1, 0], [0, 0, 0, 0]]方案3:[[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 1, 0], [1, 0,1, 0], [0, 0, 0, 0]]方案4:[[1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 0], [0, 0, 1, 0], [1, 0,1, 1], [0, 0, 0, 1], [1, 0, 0, 1], [0, 0, 0, 0]]方案5:[[1, 1, 1, 1], [0, 1, 1, 0], [1, 1, 1, 0], [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0]]方案6:[[1, 1, 1, 1], [0, 1, 1, 0], [1, 1, 1, 0], [0, 0, 1, 0], [1, 0, 1, 1], [0, 0, 0, 1], [1, 0,0, 1], [0, 0, 0, 0]]方案7:[[1, 1, 1, 1], [0, 1, 1, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 1], [0, 0, 0, 1], [1, 0,0, 1], [0, 0, 0, 0]]方案8:[[1, 1, 1, 1], [0, 1, 1, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 1], [0, 0, 0, 1], [1, 0,1, 1], [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0]] 得到的最短路径为: 农夫带羊过河 →\\rightarrow→ 农夫返回农夫 →\\rightarrow→ 带狼过河 →\\rightarrow→ 农夫返回 →\\rightarrow→ 农夫带菜过河 农夫带羊过河 →\\rightarrow→ 农夫返回 →\\rightarrow→ 农夫带狼过河 →\\rightarrow→ 农夫返回 →\\rightarrow→ 农夫带菜过河 放宽约束要求后，所得到的合理方案数更多，最优方案所需路径更少。这与实际情况相符合。经检验，本文模型具有较高的普适性，所求方案完整准确，适用于此类约束性规划过河问题，具有较高的实际意义。 这里有点扯淡，因为我也无法说明为啥这就是只有这八种方案 模型评价 模型优点 巧妙地将问题约束条件量化，构造空间状态树的数据结构，使求解结果更加准确全 面。 模型轻便，具有普适性，适于推广到不同的问题中去。 采用回溯法，DFS，提高遍历效率。在分支界限法中，一般用的是 FIFO 或最小耗费其思想是一次性将一个节点的所有子节点求出并将其放入一个待求子节点的队列。通过遍历这个队列（队列在遍历过程中不断增长）完成搜索。而 DFS 的作法则是将每一条合法路径求出后再转而向上求第二条合法路径。而在回溯法中，采用DFS。可以通过约束函数杀死一些节点从而提高算法效率，由于 DFS 是将路径逐一求出的，通过在求路径的过程中杀死节点即可省去求所有子节点所花费的时间。 模型缺点 建模方法单一，对于同一问题没有建立多个模型，无法进行多个模型的分析与比较。 模型初始化需要用户提供所有的安全位置状态集合与安全路径集合，虽简便了算法 的实现，但在使用方面增加了一定的复杂程度。 参考博文 [1] https://blog.csdn.net/ltx06/article/details/24110171 [2] https://www.cnblogs.com/wj033/p/9129984.html [3] https://www.jianshu.com/p/d28b01b3edae [4] https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html [5] https://wenku.baidu.com/view/9005d511f18583d049645937.html","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"小玩意","slug":"小玩意","permalink":"http://ckblogs.cn/tags/%E5%B0%8F%E7%8E%A9%E6%84%8F/"},{"name":"回溯法","slug":"回溯法","permalink":"http://ckblogs.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"VScode让敲代码成为享受(敬请期待)","slug":"VScode让敲代码成为享受","date":"2021-04-24T15:59:25.000Z","updated":"2021-05-28T16:30:43.342Z","comments":true,"path":"2021/04/24/VScode让敲代码成为享受/","link":"","permalink":"http://ckblogs.cn/2021/04/24/VScode%E8%AE%A9%E6%95%B2%E4%BB%A3%E7%A0%81%E6%88%90%E4%B8%BA%E4%BA%AB%E5%8F%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"“开启我的博客之旅”","slug":"“开启我的博客之旅”","date":"2021-04-24T15:52:54.000Z","updated":"2021-08-19T10:19:31.546Z","comments":true,"path":"2021/04/24/“开启我的博客之旅”/","link":"","permalink":"http://ckblogs.cn/2021/04/24/%E2%80%9C%E5%BC%80%E5%90%AF%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85%E2%80%9D/","excerpt":"","text":"开启我的博客之旅 我是谁？ 可以在我的关于界面了解关于这个网站的主人！ 我为什么要搭建个人博客? 可能在多数人的心中，作为一个典型理工科学校的工科学生，大学生活应该被无数枯燥的代码、各种电路焊板、以及实验仪器所包围。想想上大学以来，自己也确实很少写些东西。当我看到目前在上中文系的一位好兄弟，在大学期间与同学一起创办的微信公众号，发布了一篇篇自己所写的文章，配上优美的图片。我那一刻突然好羡慕这样优雅的生活。 然而，在某一个晚自习的晚上，我在查询相关资料的时候，无意间闯入一位学长的个人博客： geminiplanet 我被其精美的博客布置，丰富的文章内容所惊艳，再欣赏了一篇篇文章后，无意间发现他是我的同校学长，更巧的是，他是至微（所在暑假支教队）的前辈。在他的个人博客中，有各种学习知识的总结、日常生活的感悟，以及一些小技巧的分享。看过他的一篇篇博文之后，我深深地感受到了拥有一个个人博客，这是一个多么有意义的事情。 继续深入了解之后，我注意到了更多人自我搭建的个人博客： 糖果屋 张洪HEO akilar’s 糖果屋 我深深被这一个个精美的博客网站所吸引，这不也是我们的浪漫吗？ 说干就干，等到正式搭建完成博客框架，当我输入ckblogs.cn在浏览器中，弹出自己的博客网站时，那一刻心中的惊喜是难以言表的！当我列好我想要书写，上传的文章，发现嘿自己能写的东西还挺多。于是我的博客就正式建立了。 在正式公布此博客前，我将此待完工博客分享给了几位朋友，得到了一个问题：“这样的博客与微博、知乎上的文章有什么不同呢？维护域名，购买oss存储，这都要花钱啊？”，看到这个问题，我当时竟一时间不能以让人十分信服的理由回击，现在我想了想，其实应该是这么个道理：当你在微博发文章时，只是在微博发文章，而当你创建一个个人博客时，你已经创建了一个微博！哈哈哈 我是如何搭建个人博客的 这是一个痛苦而又快乐的过程，这并不矛盾。搭建个人博客本身并不十分困难，不需要你有专业的计算机编程能力（当然你会一些前端搭建将更轻松），我是完全自学搭建，主要根据两位教程，一位是知乎的，链接如下： 从零开始搭建个人博客（超详细） 一位是 B 站的，链接如下： 手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo 事实上，正式搭建的过程中，耗时不长，但并不会一帆风顺的，我在搭建过程中遇到了无数的坑，但你要相信网络的力量是无限的，出错了就查查查！当你离成功越来越近的时候，你也将感受不到那些踩过的坑的痛苦了。 未来将考虑写我自己的搭建博客教程（敬请期待） 期待着同样对搭建个人博客感兴趣的你也能拥有一个自己的个人博客，到时候可以免费挂在我的友情链接里！！！ 我要写些什么? 事实证明，按时维护，持续更新博客是一件很难的事情，因为我总是被各种杂七杂八的事情所充斥。博客正式搭建完毕（未上传文章）大概是二一年的四月二十一日，我想写一些文章后再正式公布我的博客，但拖到了今天（五月底），陆陆续续完成了几篇，仍有几篇想要写的东西还没有完成。我想，在接下来的每段时间内，我都将保持记录生活，或者记录学习历程的态度，持续维护更新博客，不能只图一时之乐。目前，我想在我的博客中记录下面的内容： 生活感悟 记录一下生活中有趣的，或者值得回味，引发自己思考的事情。希望让每一天都更有意义。 学习历程 透露一点，博客内文章全由 Markdown 书写完成，Markdown 是一种笔记形式的文档格式，与 word 不同，Markdown 的书写是个享受的过程，另外 Markdown 对数学公式的支持和对编程代码的支持都很有助于我记录一些学习历程， 毕竟记忆一天不如一天。。。 有位同学给我说过，工科生应该掌握一个能力，就是先做，然后遇到不会的地方，再去查，再去做。任何时候需要去查阅相关资料。我想把博客变为一个可供我查阅资料的百宝箱，当然这里的资料应当是我自己总结而不是剽窃他人的。 “奇技淫巧” 在“探索世界”的过程中，我渐渐发现了些小妙招，这些小妙招将大大提高我们的工作效率，我将这些小妙招也总结为文，上传至博客中，希望各位也能获得启发，感叹妙哉！ 如何联系到我？ 当您有任何问题相与我交流时，可以通过首页个人介绍中添加我的个人ＱＱ或微信，关注我的哔哩哔哩也可以直接在文章下评论区留言，留下自己的邮箱，我将通过邮箱的方式回复您（悄悄说一声，回复有惊喜哦）。","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"},{"name":"感念","slug":"感念","permalink":"http://ckblogs.cn/tags/%E6%84%9F%E5%BF%B5/"}]},{"title":"不一样的浏览器体验——油猴篇","slug":"不一样的浏览器体验-——油猴篇","date":"2021-04-24T15:52:29.000Z","updated":"2021-09-26T03:15:10.375Z","comments":true,"path":"2021/04/24/不一样的浏览器体验-——油猴篇/","link":"","permalink":"http://ckblogs.cn/2021/04/24/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%93%E9%AA%8C-%E2%80%94%E2%80%94%E6%B2%B9%E7%8C%B4%E7%AF%87/","excerpt":"","text":"不一样的浏览器体验——油猴篇 当本文侵犯了您的利益时，请立即联系本人，文章将即刻下架。 厌恶“破解”之人不建议阅读本文，建议支持正版（doge） 上一节中，我们介绍了浏览器几个插件的基本用法，在最后提出了油猴插件，那么油猴插件具体有哪些用呢？这一节，我将介绍几个油猴脚本的常见的强大功能！ 戳我重看上篇文章 本篇基于已经安装好油猴插件的谷歌或 edge 浏览器使用 寻找脚本 油猴插件属于脚本运行器，单单插件本身是没有具体功能的，需要我们添加油猴脚本，那我们应该从哪里寻找我们需要的油猴脚本呢？我提供下面的方案： 安装好油猴脚本后，我们可以在浏览器的右上角看到这个小猴子标志，左键点开后选择获取新脚本 点开之后，我们可以看到各个不同的脚本网站，我们选择最受欢迎的 GreasyFork . 点开脚本列表，你就可以看到各个开源脚本了，搜索框内支持脚本搜索，选择你想要的脚本，（一般在相应脚本介绍中有具体使用说明）并点击安装，即可成功运行。 脚本推荐 全网视频解析 脚本名称：【电脑 &amp;&amp; 手机 全网唯一全自动脚本】VIP会员视频自动解析 脚本地址：【电脑 &amp;&amp; 手机 全网唯一全自动脚本】VIP会员视频自动解析 脚本介绍：脚本功能目前有：1–（视频解析失败的话请自己 （电脑：左上角按钮 &amp;&amp; 手机：右下角按钮） 切换接口，不用乱反馈，手机 哔哩哔哩 视频解析的话，需要切换电脑UA）A站、B站、优酷、土豆、腾讯、芒果、爱奇艺、搜狐、乐视、PPTV、1905…等各大视频网站 （普通视频–自动跳过视频广告 &amp;&amp; 自动暂停视频，会员视频–自动会员解析,解放双手），2–A站,B站,优酷,腾讯,爱奇艺,芒果TV,PPTV,搜狐,乐视视频关闭弹幕，3–豆瓣资源 可以搜索观看视频，4–支持 网易云音乐、QQ音乐、酷狗、酷我、虾米、咪咕、5SING、喜马拉雅、懒人听书、全民K歌、一听音乐、九酷音乐网、echo回声、四季电台、快手视频、抖音视频、好看视频…等（非付费 和 非会员）音乐 和 MV 嗅探下载（先播放，然后再点击网页右上角–猫咪按钮）。（请不要相信“解析”出现的一切任何形式的广告，江小白无聊作品，单纯写好玩的） 脚本使用： 成功安装后，让我们打开优酷视频的任意一个VIP专属视频： 自动跳过广告！视频自动播放！ 发现旁边多了个这样的小图标，我们将鼠标滑动到小图标上可以看到很多解析方法，当系统自动解析失败后，可以选择换一个解析方法，继续破解，肯定有一款适合你！ 一部需要 VIP 才能观看的视频，我们不需要登录也可以自由高清观看了： 注意： 其他视频网站如爱奇艺、芒果TV、腾讯视频操作与此相同 加密视频不支持破解，付费视频具有一定的成功率 支持正版！如有侵权，请联系我！ 百度网盘直接下载 本插件的使用需要安装 IDM 下载器，具体安装方法在上篇博客有所介绍： 戳我重看上篇文章 相信你一定在百度网盘中下载过东西，也一定被百度网盘的限速下载而强制冲会员。这个插件可以让你脱离百度网盘，直接将文件通过 idm下载器高速下载，远离被限速的烦恼。 脚本名称：百度网盘简易下载助手（直链下载复活版） 脚本地址：百度网盘简易下载助手（直链下载复活版） 脚本介绍：大概是目前唯一真正能用的直链下载助手了。免SVIP会员，免安装浏览器扩展，无视黑号。只要你有个Aria2或IDM，就可以使用你自己的帐号，享受极速下载的快感！ 脚本使用方法： 一、配置idm下载器 打开你的idm下载器：点开下载并选择选项 在选项页面选择“下载”，并将UA用户代理设置为: 1softxm;netdisk 完成后选择 “连接”，并设定最大链接数为4. 二、使用 我们在浏览器中打开百度网盘并登录自己的账号后勾选需要下载的文件：我们会发现，出现了这个简易下载助手选项： 选择点击获取支链地址（这时有时会进行人机验证，没关系我们验证就好了）让人恼火的是，我们需要关注这个公众号获取验证码才可获得支链地址。 没办法，谁叫这是人家自己写的脚本呢！我们照做就好了。 复制获得下载地址后，我们继续打开idm下载器： 选择新建任务: 将链接粘贴到地址栏中点击确定: 等待下载器确认下载类型后，选择合适的保存位置，就可以开始下载了： 你被它的速度惊艳到了吗？ 文本选中复制 相信在你查阅资料的过程中，想要复制一篇文章中的一段文字时，一定遇到过下面的情况： 百度文库： 道客巴巴： 什么？复制一段文字竟然还需要充值VIP！ 下面介绍的这个插件可以让你完全解除这个烦恼： 脚本名称：文本选中复制 脚本地址：文本选中复制 脚本描述：解除网站不允许复制的限制，文本选中后点击复制按钮即可复制，主要用于 百度文库 道客巴巴 无忧考网 学习啦 蓬勃范文 思否社区 力扣 知乎 语雀 等 脚本使用方法： 使用方法非常简单，当我们启用脚本后，继续像往常一样选中想要复制的文字时，你会发现文字旁边出现了一个“复制”小图标，点击这个图标，便可以免费复制了。 注意：当您复制的文字非个人使用时，一定要标注文章来源，尊重原创作者。 HTML5 视频播放器增强脚本 你是否想要掌控视频播放的一切：可以实现视频快进快退、倍速播放/加速播放、视频画面截图、画中画、网页全屏、调节亮度、饱和度、对比度、自定义配置功能增强等功能。 本插件完全可以提供上述功能，并且全部可以依靠键盘快捷键实现！ 什么？“被隐藏进度条的网课视频可以快进吗？”当然可以，在上篇文章中，介绍了可以最高十六倍速的快进插件，此油猴脚本更强大的便在于可以自主快进视频了！ 脚本名称：HTML5视频播放器增强脚本 脚本地址：HTML5视频播放器增强脚本 脚本描述：HTML5视频播放增强脚本，支持所有H5视频播放网站，全程快捷键控制，支持：倍速播放/加速播放、视频画面截图、画中画、网页全屏、调节亮度、饱和度、对比度、自定义配置功能增强等功能。 脚本使用方法：打开视频页面，使用下面快捷键进行控制： 快捷键列表 快捷键 说明 ctrl+\\ 快捷键是否全网页可用，默认true Ctrl+space 禁用/启用 该播放插件 → 快进5秒 ← 后退5秒 Ctrl+→ 快进30秒 Ctrl+← 后退30秒 ↑ 音量升高 10% ↓ 音量降低 10% Ctrl+↑ 音量升高 20% Ctrl+↓ 音量降低 20% C 加速播放 +0.1 X 减速播放 -0.1 Z 正常速度播放 shift+C 放大视频画面 +0.1 shift+X 缩小视频画面 -0.1 shift+Z 恢复视频画面 shift+P 进入或退画中画功能 shift+S 截图，截取当前画面并保存 shift+R 启用或禁止自动恢复播放进度功能 shift+→ 画面向右移动10px shift+← 画面向左移动10px shift+↑ 画面向上移动10px shift+↓ 画面向下移动10px Enter 进入全屏 shift+Enter 进入网页全屏 N 下一个/集视频（仅部分网站支持） D 上一帧 (截图时进行微调以找到质量最佳的一帧) F 下一帧 (不支持netflix，因为快捷键冲突) E 亮度增加% W 亮度减少% T 对比度增加% R 对比度减少% U 饱和度增加% Y 饱和度减少% O 色相增加 1 度 I 色相减少 1 度 K 模糊增加 1 px J 模糊减少 1 px Q 图像复位 S 画面旋转 90 度 总结一下 上述推荐的油猴脚本只是所有油猴脚本的冰山一角，还有更加强大的脚本在文章中不便诉说，等待着你的探索哦！ 文章完全原创，转载请注明出处。ru’yu","categories":[{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/tags/%E6%8A%80%E5%B7%A7/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ckblogs.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"2021暑假支教课程设计","slug":"2021暑假支教课程设计","date":"2021-04-24T08:11:42.000Z","updated":"2021-09-26T03:16:12.955Z","comments":true,"path":"2021/04/24/2021暑假支教课程设计/","link":"","permalink":"http://ckblogs.cn/2021/04/24/2021%E6%9A%91%E5%81%87%E6%94%AF%E6%95%99%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"本课程是本人为 2021 至微公益团队暑假支教所作课程设计，教学对象分三至六年级不等，课程设计仍在不断优化中。 课程一： 数学思维游戏与数学悖论 授课背景与目的 当前教育体系下，学校的数学教育主要面向应试，而“能做题，做对题”不应该是数学教育的目标。在一昧追求数学成绩的背景下，数学成为不少孩子厌恶的学科。为了提高孩子们的数学思维与逻辑创新能力，培养孩子们对数学的兴趣，本课程让孩子们进行发现、归纳、演绎和推理训练，为高等教育的研究学习撤下种子、打下基础，从而成就了他们的创造性思维与逻辑思维。让孩子们在生活中学数学，在数学中感受生活。课程以小组内合作，小组间竞争的方式进行，以锻造孩子们的集体荣誉感，打造有效、有活力的趣味课堂。 课堂信息 人数：30人左右 助教：0-1人 课时：4课时 简要安排: 具体划分为前两节课交流数学思维游戏&lt;一笔画&gt;&lt;抢数与24点&gt;，后两节课介绍简单数学悖论&lt;悖论初步&gt;&lt;著名数学悖论&gt;。课程以小组内合作，小组间竞争的方式进行，授课人提供游戏题目和思路，由孩子们讨论提供游戏方案，最后由授课人总结所蕴含的数学思维逻辑。 需要物资：小奖品、（暂定：扑克牌一副、橡皮筋50条）、最好有支持PPT播放的多媒体设备。 课程规划 第一节课： 一笔画 课前介绍： 自我介绍 我们的课程是什么？数学游戏又是什么呢？ 课堂规则说明： 同学们以小组为单位，5-6 人为一组，每个人都是每一组不可或缺的一份子，在本课程的进行中会有很多的抢答和比赛活动，游戏中表现好的一组会获得更高的积分，积分更高的一组将会得到奖励。 重点强调：课堂中有专门的时间供大家交流，但在老师介绍游戏的时候，为了每一位同学都能明白游戏规则，每一位同学需要保持安静，在老师多次警告时，可能会扣除该小组的积分哦 游戏介绍： “一笔画”是指笔不离开纸，而且每条线都只画一次不准重复而画成的图形。 你能用一笔画出下列图形吗？ 那么，像汉字“日”和“中”字的图形可以一笔画成吗？“田”和“目”形呢？ 游戏策略 上面的图形都可以一笔画成。“日”和“中”字形可以一笔画成，但是“田”和“目”字形不能一笔画成。这是为什么呢？ 柯尼斯堡七桥问题是图论中的著名问题。这个问题是基于一个现实生活中的事例：当时东普鲁士柯尼斯堡（今日俄罗斯加里宁格勒）市区跨普列戈利亚河两岸，河中心有两个小岛。小岛与河的两岸有七条桥连接。在所有桥都只能走一遍的前提下，如何才能把这个地方所有的桥都走遍？ 数学家欧拉给了我们答案，原来这与一个图形的“奇点”和“偶点”有关。我们先来了解什么是“交点”。数一数下列图形各有几个交点？ 交点分为两种： 从这点出发的线的数目是单数的，叫单数点（奇点）。比如下面的图形就是这样的： 从这点出发的线的数目是双数的，叫双数点（偶点）。比如下面的图形就是这样的： 总结如下：一个图形能否一笔画成，关键在于图中双数点的多少。 （1）一笔画必须是连通的（图形的各部分之间连接在一起）； （2）凡是图形中没有单数点的一定可以一笔画成。可选任一个点做起点，且一笔画后可以回到出发点。 （3）凡是图形中只有两个单数点，一定可以一笔画成。画时必须从一个单数点为起点，以另一单数点为终点。 （4）凡是图形中单数点的个数多于两个时，此图肯定是不能一笔画成。 下列哪些图形能一笔画出来，哪些不能？ 我们主要来看每个图形的“奇数点”和“偶数点”的个数。通过观察与数点，我们发现：上面一排的中间一个图形、最后一个图形和下面一排的最后一个图形的“奇数点”个数超过了两个，所以不能一笔画成。其他三个图形是可以一笔画成的。 不可以一笔画成的图形有： ​ （二）（三）（六） 可以一笔画成的图形有： ​ （一）（四）（五） 拓展思考： 想想为什么会有上面的结论呢？ 练习： 上面的图中，3、4不能一笔画成，其他都能一笔画成。 第二节课: 抢数与二十四点 抢数 游戏介绍： 两个小朋友一起做报数游戏，从1开始按数的顺序报数报道30，每人每次可以报一个数或两个数，不能不报，谁抢到30谁就赢。 在这里与小朋友们互动，让两组间的小朋友进行两两PK，并记录获胜分数 在紧张的游戏之后，授课人提出自己一定能赢，并让小朋友们与自己尝试“注意自己要是后者”，利用必胜策略，勾起小朋友的好奇。 必胜策略： 要抢到 30，必须抢到 27 ;要抢到 27，必须抢到 24 。如此倒推回去，可得到一系列关键数 30、27、24、21、18、……9、6、3。 根据以上分析，抢30游戏本身并不是一个公平的游戏，初始数和先后顺序已经决定了最后的结果，因为只有后报数者才能抢到3的倍数，后报数者有必胜策略。 拓展思考： （1）每人每次可以报一个数或两个数，不能不报，谁抢到50谁就赢。 （2）每人每次可以报一至三个数，不能不报，谁抢到30谁就赢。 （3）每人每次可以报一至四个数，不能不报，谁抢到30谁就赢。 你学到了什么： 数学递归思想 数学是如此，人生其实也是这样，为什么我们必须要让自己比别人先迈出第一步呢？后来者居上，后发制人，看其实生活中处处有数学，数学中也处处包含着生活的道理。 二十四点 游戏介绍 ： 任意抽取一副扑克（去除J、Q、K、大王、小王）的 4 张牌，最快用加、减、乘、除（可加括号）把牌面上的数通过四则运算的方式算出 24 者胜。 举例介绍： 由授课人现场出题(或抽题)，让各个小组讨论协商，提供合理解者，获得得分。 给出下面的试题准备： 试题答案1 4 9 10 6 6 2 10 6 9 3 8 9 3 1 3 4 8 1 8 8 2 1 8 3 4 5 6 3 6 6 1 4 5 1 3 2 10 2 2 2 2 4 7 2 2 10 3 7 7 1 2 5 7 2 9参考答案： 1＋4＋10＋9＝24 6＋6＋2＋10＝24 9÷（6－3）×8＝24 9×3－3×1＝24 8×4－8×1＝24 8×2＋8×1＝24 [5-（4－3）]×6＝24 6×3＋6×1＝24 4×5＋（3＋1）＝24 2×10＋2＋2＝24 （4＋7）×2＋2＝24 （10＋3）×2－2＝24 （7×7－1）÷2＝24 5×7－2－9＝24 游戏策略： 最常见的算法是3×8,4×6,2×123\\times 8 , 4\\times 6, 2\\times 123×8,4×6,2×12所以最先考虑的应该是上述3种算法。一般情况已有其中的一个因子，而用其他 3 个数去另一个因子。 eg: 3 2 1 4 消去法。3个数就可以算出24，多出来一个数，用消去法，可将多余的数除去。 eg：3 5 9 10 eg：2 5 8 8 上天法。先将数乘得很大，最后再除于一个数得24 eg: 10 10 4 4 入地法。先将数算成分数或小数，最后乘于一个数得24 eg : 3 3 7 7 极限挑战： 引出编程求解。 你学到了什么 凑配、主元、消元法 常怀对数学的热情 探索更神奇的世界 第三节课：悖论初步 小蚂蚁爬橡皮绳 问题描述：一只蚂蚁沿着一条长100米的橡皮绳以每秒1厘米的匀速由一端向另一端爬行。每过1秒钟，橡皮绳就拉长 100米，比如 10秒后，橡皮绳就伸长为1000米了。现在假定橡皮绳可任意拉长，并且拉伸是均匀的；蚂蚁也会不知疲倦地一直往前爬，在绳子均匀拉长时，蚂蚁的位置理所当然地相应均匀向前挪动。现在要问：如此下去，蚂蚁能否最终爬到橡皮绳的另一端？ 让孩子们思考并让他们举手提出自己的看法，在三四个左右的回答后提出答案“小蚂蚁可以爬到橡皮绳的另一端”让孩子们理解“橡皮绳是拉伸均匀的”，可以拿一个橡皮绳画一道黑色笔记（代表蚂蚁），拉伸橡皮绳，观察黑色印记的前进方式，领会本题的要点。 悖论介绍： 上面的这种说法是正确的。但要解释清楚，却又觉得很难。这种看似这样，其实那样的数学问题（命题），数学史把它们称作“数学悖论”。什么是悖论？从数学理论的角度讲，即从一些貌似正确或看来可接受的约定出发，经过简明正确的推理，却得到自相矛盾的结论，这样的议论就称为悖论。悖论的起源几乎与数学史同步，却导致三次“数学基础危机”，使人们对数学产生怀疑，同时也从侧面促进了数学的发展。 与孩子们交流常见的悖论问题： 1、“说谎者悖论”。 这个悖论最早是在公元前六世纪出现的。当时克里特岛哲学家爱皮梅尼特曾说过： “所有的克里特岛人都说谎”。 那么这句话是真话还是假话呢？ 2、这是“说谎者悖论”的又一个变例。 让孩子们在同一张纸上写出下列两句话： ①下一句话是谎话 ②上一句话是真话 这两句话该怎样理解？你能理解出来吗？ 3、罗素悖论 一天，萨维尔村理发师挂出了一块招牌：村里所有不自己理发的男人都由我给他们理发。于是有人问他：“您的头发谁给理呢？”理发师顿时哑口无言。 4、上帝悖论 有个虔诚的教徒，他在演说中口口声声说上帝是无所不能的，什么事都做得到。一位过路人问了一句话：“上帝能创造一块他自己也举不起来的石头吗？” 同学们，这个虔诚的教徒能回答路人的提问吗？ 5、‘不’与‘是’悖论 让孩子们进行下面的有趣的对话： 甲对乙说：“你下面要讲的是‘不’，对不对？请用‘是’或‘不’来回答！” 这句话，乙同学能回答出来吗？ 第四节课：著名数学悖论 一块钱去哪了？ 问题描述： 请各位小侦探们办办案，大家能否找到丢掉的一块钱呢？ 有三个人去投宿,一晚三十元.三个人每人掏了10元凑够三十元交给了老板 . 后来老板说今天优惠只要25元就够了,拿出5元命令服务生退还给他们, 服务生偷偷藏起了2元, 然后,把剩下的3元钱分给了那三个人,每人分到1元.这样,一开始每人掏了10元,现在又退回1元,也就是10-1=9元，三人一共3*9=27元，加上服务员自己偷偷藏得2元一共29元，还有一元去哪里了呢？ 引导孩子们思考交流其中的逻辑陷阱 个人解答： 那一元钱本身是不存在的 ，三个人住店共30元，老板退回5元，那就是说他们三人总共花了25元；然后服务员又退回每人一元，也就是说他们一共花了28元，加上老板弟弟拿的2元，刚好30元 1.总共的钱（30）=住店的人花出去的钱（27）+身上剩余的钱（3） 2.总共的钱（30）≠住店的人花出去的钱（27）+弟弟偷的钱（2） 3.住店的人花出去的钱（27）=老板赚的钱（25）+弟弟偷的钱（2） 芝诺乌龟悖论 问题描述： 阿溪里斯是古希腊神话中善跑的英雄，现在让他和乌龟赛跑。假定他的速度为乌龟的10倍。乌龟先出发，走了1米。阿溪里斯开始追赶它，当阿溪里斯走完这1米时，乌龟又向前走了0.1米；阿溪里斯再走完这0.1米时，乌龟又向前走了0.01米……阿溪里斯的速度再快，走过一段路总得花一段时间，乌龟速度再慢，在这一段时间里也总要再向前走一段路程。这样说来，阿溪里斯是永远追不上乌龟了。同学们，你认为这种说法正确吗？你能说出其中的理由吗？ 从这个悖论介绍到0.9九的循环等于1这个概念 让同学们小组交流谈谈自己的看法。 结课升华： 这个问题困扰了科学家近两千多年，直到十八世纪牛顿等科学家用微积分彻底解决了这个难题，数学悖论不断推动着人类的进步。通过数学游戏，数学悖论这四节课，希望同学们能真正感受到数学的魅力，时刻保持着学习数学，解决数学难题的热情和决心，相信数学也能帮助你在今后的生活中保持缜密的思维逻辑，严谨的求实精神，真正将数学与生活联系起来，甚至帮助并推动人类数学的进步！我相信大家，我也期待你们的好消息，谢谢大家！ 注意事项： 强调教课中小组间竞争与小组内合作的必要性，对较有难度的问题要有耐心、多举例的分析问题，对孩子们比较感兴趣的游戏要加以拓展。培养孩子们的数学兴趣需要及时活跃课堂气氛，但也要保证课堂纪律及课程的正常进行，将数学游戏与数学游戏中所剖析出的人生哲理要加以分析，让孩子们在游戏中学到真正受益一生的道理，拥有对数学学科的兴趣，锻炼数学思维是本课程的最高目标。 课程二：快乐乒乓 授课背景与目的 乒乓球是中国的国球，这项运动是集健身、竞技和娱乐为一体的运动，同时又是技术和战术完美结合的典型。乒乓球是一项集力量、速度、柔韧、灵敏和耐力素质为一体的球类运动，同时乒乓球具有明显的竞技性特点和娱乐功能，又使其成为一项培养机智果断等品质和保持青春活力，调节神经的有效运动。通过参加乒乓球训练可以培养人坚忍不拔的韧性，培养团队精神通过参加乒乓球训练能提高儿童少年的身体协调性、反应灵敏度，促进新陈代谢通过参加乒乓球训练可以强身健体。乒乓球运动要求全身性的协调与配合，可极大程度地改善孩子的体质，增强其心肺功能，并完善其不均衡的体型通过参加乒乓球训练可以增强体质，对保护眼睛，提高视力有很多帮助通过学习乒乓球，青少年可以扩大自己的社交范围，感受运动的激情与快乐，共同的兴趣爱好，可以结交许多朋友。打乒乓球不止是拥有一项特长，而是在打球的过程中，学会刻服，学会勤奋，学会控制情绪，学会做人！乒乓球具有安全，易上手，所需场地条件低等特点，利于小学三-六年级的小朋友培养体育兴趣爱好，增强国家自信。本课程将教授乒乓球基本规则和基本打法，致力于让每一个孩子学会基本的乒乓球玩法，培养基本的乒乓球爱好，能在今后的生活中感受乒乓球的魅力，爱上乒乓球运动。 课堂信息 人数: 30人左右 助教：1-2人 课时: 4-5课时 简要安排: 本课程将教学与学生练习相结合，通过对乒乓球具体规则的介绍开始，讲解了乒乓球基本握拍，发球，击打方法，让每一位同学会玩乒乓球。在此基础上进行旋转球、扣杀球的拓展提高，并对多人乒乓球（双打和团体）进行介绍。在每节课有充分的时间交给孩子们自主练习，学生以每四人为一组，这个过程需要授课者到每一组前去纠正孩子们的具体姿势和动作，致力于培养孩子们的运动兴趣。 需要物资: 乒乓球拍（数量为具体上课人数的一半）、乒乓球（数量为具体上课人数）、需要学校有一定数量的乒乓球桌 课程规划 第一节课：乒乓球介绍与乒乓球基本规则 室内上课，进行如下： 自我介绍和介绍对乒乓球在中国的发展： 建国后我国处于积贫积弱的状态，美国等资本主义国家封锁我国的经济，1958年以后和苏联的关系恶化，更加剧恶化了我国的国际生存空间，中国基本处于自力更生的状态。而在这个时候想要证明自己也只能从体育口取得突破，特别是1959年容国团获得世乒赛单打冠军，这是新中国的第一个世界冠军，一下子振奋人心，当时中国体育只有乒乓球一枝独秀，所以乒乓球也就是人们茶余饭后的谈资，乒乓球器材简单，所以从国家领导人到普通人都在打乒乓球，乒乓球逐渐确立了国球地位。 1961年世乒赛在北京举办，中国队取得了好成绩，男团五虎将勇夺男团冠军，团体冠军最能体现一个国家乒乓球实力。1961年1963年1965年中国连续三次获得世乒赛团体冠军，而且出现了乒乓球界的传奇人物庄则栋，因为他也连续三次获得世乒赛单打冠军，获得了圣勃莱德杯的复制杯，只有连续三次或者不连续四次才能获得世乒赛奖杯的复制杯，我印象中只有两位选手获得此殊荣：庄则栋、王楠。 中国队至此开始了长盛不衰，中间可能会有几年的低谷但都会很快重登巅峰，相对的低谷就是1989年以瓦尔德内尔佩尔森为代表的瑞典队的崛起，中国队陷入低谷，整个80年代末90年代初，中国队都在与世界强队竞争，直到1995年世乒赛中国队重夺男团冠军，中国队正式走出低谷，新一代的国乒人才出现：刘国梁孔令辉。到了王励勤马琳王皓这一批运动员中国乒乓球重登巅峰，成为世界绝对强队，变得不可战胜，2001年之后重大赛事团体赛再无失手（2010年莫斯科世乒赛女团失手），到了马龙张继科许昕三驾马车中国队已经难觅对手。 一代一代的国乒人，通过他们的努力才达到今天的成就和底蕴，今天乒乓球有完备的人才培养体系，有世界最强大的人才储备，也有世界杯强大教练队伍，当今国乒，有这样的成绩是几辈人的努力。 介绍乒乓球在中国的发展史，建立小朋友们对乒乓球的自信心：中国人擅长乒乓球 此处可以放乒乓球的精彩视频勾起小朋友的兴趣 为什么要学习乒乓球 乒乓球是一项集力量、速度、柔韧、灵敏和耐力素质为一体的球类运动，同时乒乓球具有明显的竞技性特点和娱乐功能，又使其成为一项培养机智果断等品质和保持青春活力，调节神经的有效运动。通过参加乒乓球训练可以培养人坚忍不拔的韧性，培养团队精神通过参加乒乓球训练能提高儿童少年的身体协调性、反应灵敏度，促进新陈代谢通过参加乒乓球训练可以强身健体。乒乓球运动要求全身性的协调与配合，可极大程度地改善孩子的体质，增强其心肺功能，并完善其不均衡的体型通过参加乒乓球训练可以增强体质，对保护眼睛，提高视力有很多帮助通过学习乒乓球，青少年可以扩大自己的社交范围，感受运动的激情与快乐，共同的兴趣爱好，可以结交许多朋友。打乒乓球不止是拥有一项特长，而是在打球的过程中，学会刻服，学会勤奋，学会控制情绪，学会做人！ 强调说明上课纪律 以四人为一小组，第一节课在室内讲解具体规则，第二节课开始在室外学习乒乓球，具体纪律如下： 注意安全，不得擅自离开乒乓球场地，严格听从老师和助教安排。 不得损坏乒乓球拍，乒乓球和乒乓球桌，上课后先听从老师讲解具体操作，经老师同意练习后，方可散开练习。 四人一小组，轮流练习，不得与同学发生冲突与争执，有任何问题第一时间告诉老师，要主动谦让同学。 下课后主动归还乒乓球拍和乒乓球，依次回到教室，不得逗留嬉戏。 乒乓球基本规则介绍 合法发球 合法击球 常见犯规错误 第二节课：握拍、发球、基本击打、具体分析乒乓球策略 根据小朋友的乒乓球基础，调整授课着重点 组织同学们有序到底体育场，并做热身运动 在这里可以与助教进行乒乓球比赛表演 教学内容：(大概15分钟左右) 一、握拍： 提供两种握拍方式供同学们选择，横排（有利于进攻）与直拍（有利于防守），建议初学者以直拍的方式击球，规范每位同学的握拍方式。 二、发球： 在乒乓球桌上，讲解乒乓球发球规则，并做演示，初学者可以采用弹发球的形式 三、基本击打： 在乒乓球桌上，讲解乒乓球击打的具体规则，要点，和具体扣分情况，并与助教进行演示（横排与直拍都演示） 练习（25分钟左右）： ​ 每组成员四人轮流交替，授课者依次前往每一组具体指导乒乓球发球击打动作。注意关注每一位同学。对表现优异的同学要加以表扬，对暂时打的不好的同学要加以耐心的鼓励和指导。 下课（提前5分钟）： 距离下课时间提前五分钟集结队伍并点数，确保每一位同学均在队伍中，询问本节课的收获、疑惑和建议，后整齐带入教学楼中。 第三节课：反手拉杆球、正手攻球 组织同学们有序到底体育场，并做热身运动 在这里可以与助教进行乒乓球比赛表演 教学内容：（大概15分钟左右） 一、反手拉杆球： 注意讲解反手拉杆球的运用时机，具体的动作、姿势要领、反手握乒乓球拍的手势、以及乒乓球拍的角度和反手拉球的力度。 &lt;与助教进行一对一的反手拉杆球对拉，注意强调乒乓球的运球节奏。&gt; 二、正手攻球： 注意讲解正手攻球的运用时机，具体的动作。姿势要领、正手握乒乓球拍的手势、以及乒乓球拍的角度和正手攻球的力度。 与助教进行一对一的正手攻球对攻，注意强调乒乓球的正手攻球节奏 练习：（25分钟左右） ​ 每组成员四人轮流交替，每两位同学进行五组反手拉杆球，五组正手攻球训练。授课者依次前往每一组，注意纠正同学们的动作和姿势和握拍。对表现优异的同学要加以表扬，对暂时打的不好的同学要加以耐心的鼓励和指导。 下课（提前5分钟）： 距离下课时间提前五分钟集结队伍并点数，确保每一位同学均在队伍中，询问本节课的收获、疑惑和建议，后整齐带入教学楼中。 第四节课：&lt;暂定：旋转球、扣杀球/若小朋友接受较好则上这节提高课，否则跳过&gt; 组织同学们有序到底体育场，并做热身运动 在这里可以与助教进行乒乓球比赛表演 教学内容：（大概15分钟左右） 此内容为提高内容，注意因材施教 一、旋转球： 讲解旋转球的基本原理，旋转球的基本威胁方式，旋转球的基本应对方式，重点讲解旋转球的打法和旋转球的应对方法。 二、扣杀球： 讲解扣球的基本操作，重点讲解扣球的动作要领和击打力度与击打角度。讲解扣球的基本应对方式（包括防守和反攻）。 三、人生升华： 旋转球与扣球是一柔一刚，各有特点，这与中国阴阳观点相似。一昧的旋转球缺乏攻击力，一昧的扣杀球失误率高，并且防守性低，只有兼并刚柔，并内化于心，才能真正学好乒乓球，乒乓球如此，人生也是如此，这就是唯物辩证。 练习：（25分钟左右） ​ 每组成员四人轮流交替，对不同接受程度的同学进行自主的训练，乒乓球基础较好者可以继续训练旋转球与扣杀球，或者其他同学可选择复习训练上节课内容。授课者依次前往每一组，注意纠正同学们的动作和姿势和握拍。对表现优异的同学要加以表扬，对暂时打的不好的同学要加以耐心的鼓励和指导。 下课（提前5分钟）： 距离下课时间提前五分钟集结队伍并点数，确保每一位同学均在队伍中，询问本节课的收获、疑惑和建议，后整齐带入教学楼中。 第五节课：&lt;多人乒乓球初步&gt; 本节课注重培养小朋友的团队协作能力与团队默契，丰富更多的乒乓球打法 组织同学们有序到底体育场，并做热身运动 在这里可以与助教进行乒乓球比赛表演 教学内容：（大概15分钟左右） 一、乒乓球双打介绍 （男子双打、女子双打、混合双打）： 中国乒乓球双打获得的荣誉 具体击打的方式与规则 注意事项 这里可以和助教选择两位同学进行双打示范 二、团体乒乓球介绍 （男子团体、女子团体） 中国团体乒乓球获得的荣誉 具体规则 练习：（25分钟左右） 每两组同学组合，先进行双打练习，注意强调乒乓球击打的顺序。 两组同学练习双打后，可进行乒乓球团体对打训练。 对表现优异的同学要加以表扬，对暂时打的不好的同学要加以耐心的鼓励和指导。 下课（提前5分钟）： 距离下课时间提前五分钟集结队伍并点数，确保每一位同学均在队伍中，询问五节乒乓球课后学生们的收获，并承诺对感兴趣的同学可以在空闲时间与自己进行乒乓球的训练和比赛，后整齐带入教学楼中。 注意事项： 室外体育课的学生安全是首位，在此前提下进行乒乓球的授课；对学生的课程教授要有耐心，并给予奖励与鼓励；在乒乓球的教学中，致力于培养孩子们运动的兴趣，并注意对孩子们民族自信、中国自信力的培养。对不同的学生要因材施教，不能以唯一标准评判每一位学生的努力。","categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"不一样的浏览器体验——插件篇","slug":"不一样的浏览器体验——插件篇","date":"2021-04-22T13:02:33.000Z","updated":"2021-09-26T03:15:25.972Z","comments":true,"path":"2021/04/22/不一样的浏览器体验——插件篇/","link":"","permalink":"http://ckblogs.cn/2021/04/22/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%E7%AF%87/","excerpt":"","text":"不一样的浏览器体验—— 插件篇 作为你手中的浏览器，它是一个什么样的存在呢？ 只是单纯的一个搜索引擎 偶尔看看浏览器里的小说和小视频 获取重要学习资料的场所 本文将改变你对传统浏览器的认识，用神奇的浏览器插件小技巧，为你的生活带去你难以想象的方便！ 本文基于 Windows 端浏览器，支持 Windows 7及以上的用户使用，手机端浏览器亦可以有相关操作，具体还看博主的后续文章更新。 浏览器的选择 远离他们： 你是否还在受下面浏览器所“毒害”： QQ 浏览器： 我承认QQ 浏览器功能确实多：看小说、解压缩、查看文件，但它体积过于庞大，浏览器内部广告众多，并充斥着“软色情”，不够简洁，重要的是不支持插件 360 浏览器： 360 全家桶一直是我认为最流氓的流氓软件，与QQ浏览器一样，360浏览器体积庞大，内部广告众多，让人用着很是不爽，重要的是不支持插件 IE 浏览器： 曾经称霸浏览器界的老大哥 IE 浏览器，目前已经是个充满诟病的浏览器，作为各大前端程序员眼中最为痛恨的存在，“是时候升级你的浏览器了！”，亦不支持插件 本文推荐： 细心的读者可能注意到了，我所强调好用的浏览器，至少应该满足下面的特点： 轻便快捷 简洁无广告 支持浏览器插件 基于上面的特点，强烈推荐大家使用下面的两款浏览器： 谷歌浏览器 我愿称谷歌浏览器为当今时代的浏览器王者，不仅因为它具有及其简介的页面，还以为它强大的内核。但由于某某原因，谷歌浏览器内的部分应用在国内无法正常使用，（如果你会科学上网的话，还是推荐使用谷歌浏览器）下面放出它的官网下载地址： chrome 浏览器官方网站 edge浏览器 当前微软公司推出的 edge 浏览器已经完全有了与谷歌浏览器相抗衡的实力，它支持谷歌浏览器内部的所有插件，拥有着同样简介的页面和人性化的设置，重要的是，它的全部应用皆在墙内，通过国内网皆可直接打开，对于插件小白选手，选择 edge 浏览器入手，绝对是不错的选择，下面放出它的官网下载地址： Microsoft Edge 浏览器官方网站 安装包蓝奏云网盘下载 密码:33jq 插件简介 浏览器的插件可谓浏览器的“灵魂”，本文以 edge 浏览器为例，展开介绍，谷歌浏览器与此大同小异。首先点开浏览器右上角那三个点，选择扩展，这里就是浏览器插件的管理面板。 注意你的浏览器打开的样式可能与我不同，不要慌张，不影响接下来的步骤，在我一步步的介绍中，你也可以把你的浏览器调试的比我的更好看，更好用！ 接下来打开扩展商店： 你将会看到下面的页面: 但是这样的方式得到的插件不全，因为众多功能强大的插件是未能获得edge扩展商店收录，所以我介绍下面的安装方式： 打卡开发者模式： 将我提供的插件直接拖入其中： 即可成功安装。好了，至此，你已经成功开启了插件之旅，那么又有哪些值得推荐的插件呢？下这些插件，我将一一介绍！这些插件我都将以网盘蓝奏云的方式提供给大家 选择蓝奏云而非百度网盘的原因是：无需登录、无限速 插件推荐 Infinity新标签页 插件介绍插件安装 还记得我的个人标签页面嘛，简洁、高效、美观，这得益于插件“ Infinity 新标签页 ”，获取扩展并在扩展管理面板选择启用后，你的个人标签页就可以启动了，你可以自行设置标签页快捷应用和壁纸。是不是很帅呢！此扩展可在扩展商店直接搜索安装，也可在，蓝奏云网盘处下载到本地再拖入管理面板中： Infinity 蓝奏云下载 密码:b9nr AdBlock插件 插件介绍插件安装接下来的插件可谓是广告杀手! AdBlock 是一款免费但是强大的拦截广告插件，它可以有效阻断百分之九十的浏览器页面广告，更强大的是，倘若出现了未能拦截的广告，可以自行选择设定拦截规则。 在首页最热门的插件中，AdBlock 扩展当然不容我们忽视，它是最强的广告阻止插件 Edge 浏览器可以直接在扩展商店首页看到它,将他直接安装后,可以在这里看到它的标志。 其他用户可以在我的蓝奏云处下载到本地，并将插件拖入到扩展的面板管理处！ AdBlock 蓝奏云插件安装包 密码:a36q Video Speed 插件介绍插件安装这款插件由好兄弟 ‭ShatteredXZ 向我提供，在这里向他表示感谢！ 这款插件的强大之处就是，它可以解析绝大部分的视频网页，可以对视频选择最高 16 倍速的快进速度。博主亲测16倍速后，播放快慢只取决于你的网速能不能跟上它播放的速度！ “我需要那么快的播放速度，我还看什么视频啊！” “哎，对了，你的军理网课看完了吗？” “噢 ~ ” 没错，无论视频网页是否限制快进、限制拖进度条，此插件均可以提高播放速度。 我们以学习通的视频为例,来看看它的威力: 有人问，那有可以拖进度条的插件吗？上方的课程是因为我完成了任务点，可以开启拖动进度条，但对于这个插件而言，没有拖动进度条的功能，只能倍速播放。但强大的插件总是能满足你的幻想，再下一章“ 详解油猴插件 ”中我将具体介绍，那里可是满满的干货！ 此款插件只支持蓝奏云本地下载并拖入浏览器扩展中 Video Speed 插件压缩包 密码：9bt1 IDM Integration Module 插件 插件介绍插件安装我们下载东西的过程中，最让人头大的莫过于龟速般的下载速度了，这款插件的强大之处有两方面 绝对高速下载任何文件 自由下载页面的所有视频／影评资源 当你想要下载一部B站的视频时，并不支持直接下载到本地，这时你就可以采用IDM下载插件，具体操作如下图所示： 将会弹出下面的提示信息，选择合适的保存路径你就会感受到飞一般的下载速度！！！ 很多小伙伴是不是想让这个下载器下载存储在百度网盘内被百度网盘限速的文件呢？没错，接下来的借用下面将要介绍的强大的油猴插件，将实现这个功能，不再被百度网盘这个**限速。IDM 插件依靠外部 IDM 下载器，将 IDM 外部下载器正确安装后即可自动将插件部署到你对应的浏览器中，但可惜的是，正版 IDM 下载器只提供 30 天免费试用期，后期需要交钱才能继续使用。 因此，我提供下方的 IDM 破解版的下载地址，并提供一个 B 站 up 主的破解教程，破解很方便，几分钟就能成功了！！！ IDM 安装包 IDM 破解教程 TamperMonkey油猴插件 插件介绍插件安装这个插件可谓浏览器插件之王！它更像一个脚本运行器，无数牛人的开源脚本皆可运行在这个插件中，为你服务。 你是否渴望着： 爱奇艺、优酷、腾讯、芒果等各大网站免费去广告看VIP视频 百度网盘高速下载不被限速 百度搜索不再显示广告 包括百度文库在内的所有网站不被限制复制文字 只有你想不到，没有它做不到！ 还有一些不能说的功能，可以悄悄给大家透露一点（这只是冰山一角！）： 由于其功能的强大和丰富，我决定为油猴插件再专门新建一篇博文（不是水文章！）大家敬请期待。Edge 浏览器可以直接在扩展商店下载： 也可以用我提供的蓝奏云网盘地址，将插件下载到本地，再拖入扩展的管理面板中： 油猴蓝奏云网盘地址 密码:fbug 总结 以上介绍的只是我所常用的插件的一部分，浏览器插件的功能还有很多很多，等待着你的探索，欢迎各位与我一同交流分享你的发现哦！ 有任何问题，大家可以加我的个人QQ（在主页），或微信！","categories":[{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/tags/%E6%8A%80%E5%B7%A7/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ckblogs.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"记 2021 UESTC 数学建模新生杯","slug":"记 2021 UESTC 数学建模新生杯","date":"2021-04-13T11:04:55.000Z","updated":"2021-09-26T03:16:02.656Z","comments":true,"path":"2021/04/13/记 2021 UESTC 数学建模新生杯/","link":"","permalink":"http://ckblogs.cn/2021/04/13/%E8%AE%B0%202021%20UESTC%20%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%96%B0%E7%94%9F%E6%9D%AF/","excerpt":"","text":"记 2021 UESTC 数学建模新生杯 2021 数学建模新生杯落下帷幕，在两天半的头脑风暴后，我想把这一切，包括所想所感所学，全部记录下来，作为 CK’s blogs 的一篇正式的博客。希望这是一个美好而有意义的记录。 准备比赛 电子科技大学的数学建模文化一直很浓厚，作为一个什么比赛都想试试的人来说，数学建模当然要参加。在第一学期已经很幸运地寻找到两位志同道合的队友，并成功参赛第一学期美赛模拟赛的基础上，我对这次新生杯比赛已经不再陌生，甚至会有一些期待。 期待比赛意味着必须要对这次比赛做好万足准备，对于这次新生杯比赛，有哪些做的好的地方，又有哪些需要改进的地方呢？做一个系统的总结在这时显得非常有必要，接下来，我将从准备与进行两方面展开我的想法。 建模准备 数学建模的核心当然是编程提前学习了解各大模型及其算法程序，这当然是一个数学建模人必修的功课，但在比赛前昔，我们可以粗略地浏览一遍各大类型模型，比如规划模型类、评价模型类、预测模型类如下图所示等等， 做到心中有数，拿到比赛题目时就可以直接划分题目大概属于哪一个个类型，在那个类型的模型中，再逐一去具体地找合适的模型。 在这里也列出我的一位校友学长的个人博客，这篇博客是我在比赛前昔查阅到的，这篇博客以至于这位学长的其他博客深深震撼、惊艳了我，因此这也成为了我开发个人博客的源动力，这篇数学建模模型总结也具有相当高的质量，下面这篇博客也正是这位学长的： geminiplanet.cn 编程准备 编程想要速成是很难的，能做的可能只有祈祷模型所需要的求解算法已经有很多前人做好了轮子。但依然可以找到所谓的“算法程序包”，抱歉这里不方便列出，但会熟练地使用程序包是意义不大的，因为就像本次比赛一样，在原有的算法基础上，题目条件偏偏要给你改变一下，要你不得不修改或者重新编写自己的程序。这就要靠长久的学习和积累。说实话，这也是我想要努力提升自己的一方面。正式比赛前的准备依然可以从各大算法开始着手了解。 写作准备 我至今都相信，建模编程占五分，写作一家就占五分，可能会更多，一篇好的模型，倘若写的稀巴烂也没有任何意义，但是一个连自己都无法说服的模型，只要写作手能圆好，一样有可能可以受到青睐。 “我能把正的忽悠邪了，能把奸人忽悠苶了，小两口过的挺好，我给他忽悠分别了。今天卖拐，一双好腿我能给他忽悠瘸了” 而对于比赛前写作的准备，我认为首先需要提前清楚待参加数学建模比赛类别（如国赛、美赛）及其写作要求，并做好或找到 LaTeX 模板准备，对于LaTeX 模板，可以去 GitHub （需要科学上网）上寻找，在这里列出本次新生杯所用的国赛模板 GitHub 地址： GitHub 上国赛 LaTeX模板 拿到 LaTeX 模板，clone 到本地后一定要在自己的编译器上做好调试，出现了任何问题都有时间及时解决，不能把比赛的宝贵时间浪费在无用的调试 LaTeX 代码上，这肯定是没有意义的。一般提供的模板是以模板使用说明的方式提供的，所以需要备份两份，一份作为使用说明，一份准备套入写作模板。 本次比赛就在这方面尝到了甜头，一路写下来非常顺利，即使我已经很久没有用过 LaTeX 了！ 除了对模板的准备外，写作格式需要有所约束，我在比赛前一天，研究了一下历年来的国赛一等奖论文，尤其是被我们学校数模教练推荐的获奖论文，从这些论文里，你发现一定可以提炼出一套写作模板。在正式比赛当中也可以随题目小做修改。下面是这次的写作格式模板: 1234567891011121314151617181920 \\section&#123;问题重述&#125; \\subsection&#123;问题背景&#125; \\subsection&#123;问题要求&#125;\\section&#123;问题分析&#125; \\section&#123;名词的解释与变量符号说明&#125; \\subsection&#123;名词解释&#125; \\subsection&#123;变量符号说明&#125; \\section&#123;模型的建立与求解&#125; \\subsection&#123;XXX模型&#125; \\subsubsection&#123;XXX模型的建立&#125; \\subsubsection&#123;XXX模型的求解&#125; \\subsection&#123;XXX模型&#125; \\subsubsection&#123;XXX模型的建立&#125; \\subsubsection&#123;XXX模型的求解&#125; \\section&#123;模型检验&#125; \\section&#123;模型评价&#125; \\subsection&#123;模型优点&#125; \\subsection&#123;模型缺点&#125; \\subsection&#123;模型改进&#125; \\section&#123;参考文献与引用&#125; 进行比赛 1. 读清题意 在本次比赛的过程中，我认为我们所犯的最严重的错误便是没有一开始确定自己理解的题意，当题目概念众多且陌生，条件纷纭变换，题目中的每一个关键的词都有可能影响对题目的判断。 负载能力、处理能力、阈值、任务属性消耗因子、风险因子。。。 最可怕的当是，三个人有三个对题目的理解，有三个不同的概念解释，这是恐怖的，这当然也是绝对不可行的。所以当题目发布后，第一时间组内统一题目理解，统一概念解释是非常有必要的。而在正式建模的过程中需要对题目概念理解做出改变的时候，再统一改变也不迟。 读清题目变量概念 负载能力、处理能力、阈值、任务属性消耗因子、风险因子、消减因子。。。 读清题目约束条件 “部分特殊任务”到达阈值时将对工作台负载能力造成一个常数的消减 读清题目所问问题 2. 查阅资料 除了扎实的数学功底外，数学建模同样需要的一项重要的能力便是信息检索和数据收集能力。反应到正式的比赛中，我认为能够查询到合适、相关的论文，也是致胜的一个关键。 论文搜集必备网站（UESTC 学生入口：） 国内： 中国知网 CNKI 万方数据知识服务平台 维普智立方知识资源服务平台 国外： Science Direct SCI 国外学位论文中国集团全文检索平台 ACM digital Library 非 UESTC 学生用户需要具体前往各大官方网站查阅相关资料 数学建模组内另建资料群显得尤为重要，发题后三位组员开始在各大资源网站疯狂寻找相关论文，并总结发送在资料群内，我相信肯定有一篇能为你的建模或算法提供灵感。 3. 抽象的模型 其实我一直把握不准一篇数学建模论文中抽象与具体的平衡关系，但我内心深处是向往抽象的数学符号，而不是一串串相对丑陋的具体的阿拉伯数字。但我确定的是，在建模的过程中，模型的建立与表达一定是用抽象的数学语言来展示。这除了需要我们了解众多模型的核心内涵，并通过题目条件套入其中外，针对这次比赛，我还想谈谈其他的细节。 模型假设 模型的建立往往少不了对一些相关条件的假设，而在这次与上次比赛中，条件的假设往往是我们所忽略的或者不重视的，条件统一的假设不仅有助于我们简化和统一模型条件，也让模型的建立更加合理。所以，需要我们尽可能的去考虑周全问题的所有条件，在必要之时，做出问题假设。 符号说明 抽象意味着将具体的量用抽象的符号来表示，而在变量纷纭复杂的情况下，如何用符号去代表变量，这是一个问题。 在比赛的过程中，模型建立时一个又一个变量，让我巴不得 a，b，c，d 这样轮流用下去，但这肯定是不合适的，我尝试在网上寻找答案，好像也没有所谓的规定，那该如何定义符号量的数学意义呢？我觉得需要正确把握人们的习惯性思维和对称性原则，比如 iii，jjj ，kkk 就是常用于角标量作为计数，而 μ\\muμ、λ\\lambdaλ ，等希腊字母常做系数常数。但更重要的是，自己定义的变量需要牢牢记在自己的脑海里，绝对不能在写作的过程中把他们搞得凌乱不堪。另外同一个符号不能拥有多层含义，符号含义应当区分开来并在正式建立模型之前交代清楚。 模型的检验与评价 模型的建立是一篇论文的高潮，但模型的检验和评价一样不能被忽略或轻视。本次比赛中，我们采用具体实例的模型检验 是否可行有待商榷 ，但据张神马之言，模型的检验需要大家公认的方法，具体的模型有着相应的检验方式。而在模型的评价过程中，一定要控制模型的优势多余模型的劣势，并且尽量说明模型的劣势为难以操控的不可抗因素。 4. 具体的编程 最快捷的编程方法是“Ctrl + C，Ctrl + A， Ctrl + V 一键三连！”。 第一时间寻找成品代码固然没错，但此次比赛也让我发现了这样做的一些弊端。首先，网络上的代码成品层次不齐，并不是每一个都很有效，代码中也会出现莫名其妙的 Bug ，最重要的是代码成品不一定适合你将要做的问题，这往往需要你做出改变。 值得反思的是，在第一天模型建立成功的晚上，我几乎浪费了一晚上的时间去寻找成品代码，却坚信题目要求难以编程实现。而在第二天早上，清醒头脑再看待这个问题时，发现其实编程实现是可行的并成功实现。—— 这就是一昧相信三连大法造成的惰性！ 有时真正难以实现的部分，可以通过两个方法去解决： 修改模型 牺牲功能 修改模型，需要与模型手商量，削弱部门模型条件，让编程实现变得可行。但在保证编程功能可以满足大部分条件的情况下，我认为完全可以牺牲编程代码的部分功能，因为美赛和校内赛是不要求提供代码的（doge）。当然，这适用于自建模型并自建实例，对于提供数据的赛题而言，还是需要尽可能实现代码功能。而我想强调的是，不要过于依赖各大网站的代码成品，而更应该自己去动手敲！ 5. 纠结的写作 在前期 LaTeX 的准备后，写作的过程只是一个仅需要关注写作内容而非写作格式的过程，而写作内容，我认为是纠结的过程，推敲 应当是常态。对于我们小组这样先分写再合并的过程，虽提高了写作效率，减轻了写作压力，但缺点也是显然易见的。首先是写作风格不统一，用词不统一。例如我习惯以“本文”代第一人称，而另外两位队友习惯以“我们”代第一人称。所以，这就需要合并文章时统一写作用词，统一写作风格。再精益求精一些，需要注意标点符号的统一与字母、符号、数字的准确。 演算寰宇方寸间，运筹万物帷幄中！ 小时候，总是调侃自己学的数学只能用在买菜上，而数学建模却真正是让你的数学知识转换为应对生活实际问题的过程，这个过程是美妙的，也是神奇的，希望各位数模人能一直保持对数模的这一份热爱和追求！！！","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"感念","slug":"感念","permalink":"http://ckblogs.cn/tags/%E6%84%9F%E5%BF%B5/"},{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]}],"categories":[{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/categories/%E7%94%9F%E6%B4%BB/"},{"name":"编程","slug":"编程","permalink":"http://ckblogs.cn/categories/%E7%BC%96%E7%A8%8B/"},{"name":"其他","slug":"其他","permalink":"http://ckblogs.cn/categories/%E5%85%B6%E4%BB%96/"},{"name":"感想","slug":"感想","permalink":"http://ckblogs.cn/categories/%E6%84%9F%E6%83%B3/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://ckblogs.cn/categories/LaTeX/"},{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"支教","slug":"支教","permalink":"http://ckblogs.cn/tags/%E6%94%AF%E6%95%99/"},{"name":"生活","slug":"生活","permalink":"http://ckblogs.cn/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Qt - C++","slug":"Qt-C","permalink":"http://ckblogs.cn/tags/Qt-C/"},{"name":"Python - 混合编程","slug":"Python-混合编程","permalink":"http://ckblogs.cn/tags/Python-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"},{"name":"Matlab - 混合编程","slug":"Matlab-混合编程","permalink":"http://ckblogs.cn/tags/Matlab-%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://ckblogs.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Python","slug":"Python","permalink":"http://ckblogs.cn/tags/Python/"},{"name":"技巧","slug":"技巧","permalink":"http://ckblogs.cn/tags/%E6%8A%80%E5%B7%A7/"},{"name":"数据结构","slug":"数据结构","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法 - C语言","slug":"算法-C语言","permalink":"http://ckblogs.cn/tags/%E7%AE%97%E6%B3%95-C%E8%AF%AD%E8%A8%80/"},{"name":"Verilog","slug":"Verilog","permalink":"http://ckblogs.cn/tags/Verilog/"},{"name":"硬件语言 - 实验","slug":"硬件语言-实验","permalink":"http://ckblogs.cn/tags/%E7%A1%AC%E4%BB%B6%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C/"},{"name":"信号与系统","slug":"信号与系统","permalink":"http://ckblogs.cn/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"},{"name":"MATLAB - 课程作业","slug":"MATLAB-课程作业","permalink":"http://ckblogs.cn/tags/MATLAB-%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"},{"name":"爬虫","slug":"爬虫","permalink":"http://ckblogs.cn/tags/%E7%88%AC%E8%99%AB/"},{"name":"国奖","slug":"国奖","permalink":"http://ckblogs.cn/tags/%E5%9B%BD%E5%A5%96/"},{"name":"LaTex","slug":"LaTex","permalink":"http://ckblogs.cn/tags/LaTex/"},{"name":"算法 - leetcode","slug":"算法-leetcode","permalink":"http://ckblogs.cn/tags/%E7%AE%97%E6%B3%95-leetcode/"},{"name":"数学建模","slug":"数学建模","permalink":"http://ckblogs.cn/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"Matlab","slug":"Matlab","permalink":"http://ckblogs.cn/tags/Matlab/"},{"name":"评价类算法","slug":"评价类算法","permalink":"http://ckblogs.cn/tags/%E8%AF%84%E4%BB%B7%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://ckblogs.cn/tags/TOPSIS/"},{"name":"C语言","slug":"C语言","permalink":"http://ckblogs.cn/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"知识点总结","slug":"知识点总结","permalink":"http://ckblogs.cn/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"name":"期末复习","slug":"期末复习","permalink":"http://ckblogs.cn/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"灰色预测","slug":"灰色预测","permalink":"http://ckblogs.cn/tags/%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B/"},{"name":"预测类算法","slug":"预测类算法","permalink":"http://ckblogs.cn/tags/%E9%A2%84%E6%B5%8B%E7%B1%BB%E7%AE%97%E6%B3%95/"},{"name":"机器学习","slug":"机器学习","permalink":"http://ckblogs.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"小玩意","slug":"小玩意","permalink":"http://ckblogs.cn/tags/%E5%B0%8F%E7%8E%A9%E6%84%8F/"},{"name":"回溯法","slug":"回溯法","permalink":"http://ckblogs.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"name":"感念","slug":"感念","permalink":"http://ckblogs.cn/tags/%E6%84%9F%E5%BF%B5/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ckblogs.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}